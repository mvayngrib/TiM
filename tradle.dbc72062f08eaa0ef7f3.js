webpackJsonp([6,7],{

/***/ 1149:
/***/ function(module, exports, __webpack_require__) {

	
	const tradle = module.exports = exports
	// tradle.keeper = require('./lib/keeper')
	tradle.protocol = __webpack_require__(1150)
	tradle.sender = __webpack_require__(1206)
	tradle.sealer = __webpack_require__(1378)
	tradle.sealwatch = __webpack_require__(1379)
	tradle.dbs = {
	  objects: __webpack_require__(1380),
	  // tx: require('./lib/dbs/txs'),
	  seals: __webpack_require__(1401),
	  watches: __webpack_require__(1402),
	  addressBook: __webpack_require__(1403),
	  simpleCustom: __webpack_require__(1405),
	  msgMeta: __webpack_require__(1406),
	}
	
	tradle.retrystream = __webpack_require__(1377)
	tradle.validator = __webpack_require__(1407)
	tradle.types = __webpack_require__(1223)
	tradle.utils = __webpack_require__(1225)
	tradle.constants = __webpack_require__(1224)
	// tradle.constants = {
	//   status: require('./lib/status'),
	//   topics: require('./lib/topics')
	// }
	
	tradle.topics = __webpack_require__(1221)
	tradle.protobuf = __webpack_require__(1323)
	tradle.node = __webpack_require__(1408)
	tradle.partial = __webpack_require__(1330)
	
	tradle.typeforce = __webpack_require__(1207)


/***/ },

/***/ 1150:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {
	'use strict'
	
	const crypto = __webpack_require__(904)
	const clone = __webpack_require__(859)
	const extend = __webpack_require__(1151)
	const typeforce = __webpack_require__(1054)
	const stringify = __webpack_require__(1152)
	const merkleProofs = __webpack_require__(1156)
	const merkleGenerator = __webpack_require__(1173)
	const secp256k1 = __webpack_require__(1174)
	const flatTree = __webpack_require__(1171)
	const constants = __webpack_require__(1181)
	const parallel = __webpack_require__(1182)
	const proto = __webpack_require__(1183)
	const utils = __webpack_require__(1203)
	const types = __webpack_require__(1204)
	const DEFAULT_CURVE = 'secp256k1'
	const SIG = constants.SIG
	const SEQ = constants.SEQ
	// const PREV_TO_SENDER = constants.PREV_TO_SENDER
	const TYPE = constants.TYPE
	const PREV = constants.PREVLINK
	const ORIG = constants.PERMALINK
	const FORWARD = constants.FORWARD
	const HEADER_PROPS = [SIG]
	
	module.exports = {
	  DEFAULT_MERKLE_OPTS: {
	    leaf: function leaf (node) {
	      return sha256(node.data)
	    },
	    parent: function parent (a, b) {
	      return concatSha256(a.hash, b.hash)
	    }
	  },
	  types: types,
	  stringify: stringify,
	  merkleHash: sha256,
	  secp256k1: secp256k1,
	  tree: createMerkleTree,
	  merkleRoot: computeMerkleRoot,
	  object: createObject,
	  parseObject: parseObject,
	  nextVersion: nextVersion,
	  sealPubKey: calcSealPubKey,
	  sealPrevPubKey: calcSealPrevPubKey,
	  verifySealPubKey: verifySealPubKey,
	  verifySealPrevPubKey: verifySealPrevPubKey,
	  sign: merkleAndSign,
	  // message: createMessage,
	  // validateMessage: validateMessage,
	  // getSigPubKey: getSigPubKey,
	  sigPubKey: getSigKey,
	  verifySig: verifySig,
	  verify: verifySig,
	  // validateObject: validateObject,
	  validateVersioning: validateVersioning,
	  prove: prove,
	  prover: prover,
	  verifyProof: verifyProof,
	  leaves: getLeaves,
	  indices: getIndices,
	  protobufs: proto,
	  linkString: getStringLink,
	  link: getLink,
	  prevSealLink: getSealedPrevLink,
	  // prevLink: getPrevLink,
	  header: getHeader,
	  body: getBody,
	  // serializeMessage: serializeMessage,
	  // unserializeMessage: unserializeMessage,
	  genECKey: utils.genECKey,
	  constants: constants,
	  utils: utils
	}
	
	function createObject (opts) {
	  typeforce({
	    object: types.rawObject,
	    prev: typeforce.maybe(types.merkleRootOrObj),
	    orig: typeforce.maybe(types.merkleRootOrObj)
	  }, opts, true)
	
	  // shallow copy not too safe
	  const obj = getBody(opts.object)
	  if (opts.prev) {
	    obj[PREV] = getStringLink(opts.prev)
	  }
	
	  if (opts.orig) {
	    obj[ORIG] = getStringLink(opts.orig)
	  }
	
	  return obj
	}
	
	function nextVersion (object, link) {
	  link = link || getStringLink(object)
	  object = clone(object)
	  HEADER_PROPS.forEach(prop => {
	    delete object[prop]
	  })
	
	  // delete object[SIG]
	  object[PREV] = link
	  object[ORIG] = object[ORIG] || link
	  return object
	}
	
	// function createMessage (opts, cb) {
	//   typeforce({
	//     author: types.author,
	//     body: types.messageBody
	//   }, opts)
	
	//   const message = opts.body
	//   if (!message[TYPE]) message[TYPE] = constants.MESSAGE_TYPE
	
	//   merkleAndSign({
	//     object: message,
	//     author: opts.author
	//   }, cb)
	// }
	
	// function validateMessage (opts) {
	//   return validateVersioning(opts)
	//   // typeforce({
	//   //   message: typeforce.Object,
	//   //   prev: typeforce.maybe(typeforce.Object)
	//   // }, opts)
	
	//   // const message = opts.message
	//   // if (message[PREV] || opts.prev) {
	//   //   if (message[PREV] && !opts.prev) {
	//   //     throw new Error('expected "prev"')
	//   //   }
	
	//   //   if (!message[PREV] && opts.prev) {
	//   //     throw new Error(`message missing property "${PREV}"`)
	//   //   }
	
	//   //   const expectedPrev = getLink(opts.prev)
	//   //   if (!message[PREV].equals(expectedPrev)) {
	//   //     throw new Error(`object[${PREV}] and "prev" don't match`)
	//   //   }
	//   // }
	// }
	
	function merkleAndSign (opts, cb) {
	  typeforce({
	    author: types.author,
	    object: types.rawObject
	  }, opts)
	
	  const author = opts.author
	  const object = opts.object
	  if (object[SIG]) throw new Error('object is already signed')
	
	  const tree = createMerkleTree(getBody(object), getMerkleOpts(opts))
	  const merkleRoot = getMerkleRoot(tree)
	  author.sign(merkleRoot, function (err, sig) {
	    if (err) return cb(err)
	
	    const encodedSig = utils.encodeSig({
	      pubKey: author.sigPubKey,
	      sig: sig
	    })
	
	    sig = utils.sigToString(encodedSig)
	    const signed = extend({ [SIG]: sig }, object)
	
	    cb(null, {
	      tree: tree,
	      merkleRoot: merkleRoot,
	      sig: sig,
	      object: signed
	    })
	  })
	}
	
	/**
	 * calculate a public key that seals `link` based on `basePubKey`
	 */
	function calcSealPubKey (opts) {
	  typeforce({
	    basePubKey: types.chainPubKey,
	    object: typeforce.maybe(typeforce.Object),
	    link: typeforce.maybe(typeforce.Buffer)
	  }, opts)
	
	  const link = opts.link || getLink(opts.object)
	  return utils.publicKeyCombine([
	    opts.basePubKey,
	    pubKeyFromLink(link)
	  ])
	}
	
	function calcSealPrevPubKey (opts) {
	  typeforce({
	    basePubKey: types.chainPubKey,
	    object: typeforce.maybe(typeforce.Object),
	    prevLink: typeforce.maybe(typeforce.Buffer)
	  }, opts)
	
	  const link = getSealedPrevLink(opts.prevLink || opts.object)
	  return link && utils.publicKeyCombine([
	    opts.basePubKey,
	    pubKeyFromLink(link)
	  ])
	}
	
	function verifySealPubKey (opts) {
	  typeforce({
	    object: typeforce.Object,
	    basePubKey: types.chainPubKey,
	    sealPubKey: types.chainPubKey
	  }, opts)
	
	  const object = opts.object
	  if (!object[SIG]) throw new Error('object must be signed')
	
	  const expected = utils.publicKeyCombine([
	    opts.basePubKey,
	    pubKeyFromObject(object)
	  ])
	
	  return utils.ecPubKeysAreEqual(expected, opts.sealPubKey)
	}
	
	function verifySealPrevPubKey (opts) {
	  typeforce({
	    sealPrevPubKey: types.chainPubKey
	  }, opts)
	
	  const expected = calcSealPrevPubKey(opts)
	  return utils.ecPubKeysAreEqual(expected, opts.sealPrevPubKey)
	}
	
	/**
	 * Calculate destination public key
	 * used by the recipient of a transaction
	 *
	 * @param  {Object}   opts
	 * @param  {Function} cb(?Error)
	 */
	// function validateObject (opts, cb) {
	//   typeforce({
	//     object: typeforce.Object
	//   }, opts)
	
	//   validateVersioning(opts)
	//   return {
	//     sigPubKey: getSigKey(opts)
	//   }
	// }
	
	function parseObject (opts) {
	  const object = opts.object
	  const body = getBody(object)
	  const parsedSig = utils.parseSig(object[SIG])
	  return {
	    merkleRoot: computeMerkleRoot(body, getMerkleOpts(opts)),
	    body: body,
	    sig: parsedSig.sig,
	    pubKey: parsedSig.pubKey
	  }
	}
	
	function getSigKey (opts) {
	  typeforce({
	    object: typeforce.Object,
	    verify: typeforce.maybe(typeforce.Function)
	  }, opts)
	
	  const object = opts.object
	  // necessary step to make sure key encoded
	  // in signature is that key used to sign
	  const merkleRoot = computeMerkleRoot(getBody(object), getMerkleOpts(opts))
	  const body = getBody(object)
	  return utils.getSigKey(merkleRoot, object[SIG], opts.verify)
	}
	
	function verifySig (opts) {
	  try {
	    return !!getSigKey(opts)
	  } catch (err) {
	    return false
	  }
	}
	
	/**
	 * validate object sequence
	 * @param  {[type]} object     [description]
	 * @param  {[type]} prev       [description]
	 * @param  {[type]} merkleOpts [description]
	 * @return {[type]}            [description]
	 */
	function validateVersioning (opts) {
	  const object = opts.object
	  const prev = opts.prev
	  if (object[PREV] || prev) {
	    if (object[PREV] && !prev) {
	      throw new Error('expected "prev"')
	    }
	
	    if (!object[PREV] && prev) {
	      throw new Error(`object missing property "${PREV}"`)
	    }
	
	    const expectedPrev = typeof prev === 'string' ? prev : getStringLink(prev)
	    if (object[PREV] !== expectedPrev) {
	      throw new Error(`object[${PREV}] and "prev" don't match`)
	    }
	  }
	
	  const orig = opts.orig
	  if (object[ORIG] || orig) {
	    if (object[ORIG] && !orig) {
	      throw new Error('expected "orig"')
	    }
	
	    if (!object[ORIG] && orig) {
	      throw new Error(`object missing property "${ORIG}"`)
	    }
	
	    const expectedOrig = typeof orig === 'string' ? orig : getStringLink(orig)
	    if (object[ORIG] !== expectedOrig) {
	      throw new Error(`object[${ORIG}] and "orig" don't match`)
	    }
	
	    if (prev[ORIG] && prev[ORIG] !== object[ORIG]) {
	      throw new Error(`object and prev have different ${ORIG}`)
	    }
	  }
	}
	
	function createMerkleTree (obj, opts) {
	  if (typeof opts === 'function') {
	    cb = opts
	    opts = null
	  }
	
	  if (obj[SIG]) throw new Error('merkle tree should not include signature')
	
	  const gen = merkleGenerator(getMerkleOpts(opts))
	
	  // list with flat-tree indices
	  const nodes = []
	  const keys = getKeys(obj)
	  keys.forEach(function (key, i) {
	    gen.next(stringify(key), nodes)
	    gen.next(stringify(obj[key]), nodes)
	  })
	
	  nodes.push.apply(nodes, gen.finalize())
	  const sorted = nodes.sort(byIndexSort)
	  return {
	    nodes: sorted,
	    roots: gen.roots,
	    indices: getIndices(obj, keys)
	  }
	}
	
	function prover (object, opts) {
	  const tree = createMerkleTree(object, getMerkleOpts(opts))
	  const leaves = []
	  const builder = {
	    add: function (opts) {
	      typeforce({
	        property: typeforce.String,
	        key: '?Boolean',
	        value: '?Boolean'
	      }, opts, true)
	
	      const prop = opts.property
	      const propNodes = tree.indices[prop]
	      if (opts.key) leaves.push(tree.nodes[propNodes.key])
	      if (opts.value) leaves.push(tree.nodes[propNodes.value])
	
	      return builder
	    },
	    leaves: function () {
	      return leaves.slice()
	    },
	    proof: function (cb) {
	      return prove({
	        nodes: tree.nodes,
	        leaves: leaves
	      }, cb)
	    }
	  }
	
	  return builder
	}
	
	function prove (opts) {
	  // return nodes needed to prove leaves at leafIndices are part of the tree
	  typeforce({
	    nodes: typeforce.arrayOf(types.merkleNode),
	    leaves: typeforce.arrayOf(types.merkleLeaf)
	  }, opts)
	
	  const prover = merkleProofs.proofGenerator(opts.nodes)
	  const leaves = opts.leaves
	  for (var i = 0; i < leaves.length; i++) {
	    prover.add(leaves[i])
	  }
	
	  return prover.proof()
	}
	
	function verifyProof (opts, cb) {
	  typeforce({
	    proof: typeforce.arrayOf(types.merkleNode),
	    node: types.merkleNode
	  }, opts)
	
	  const vOpts = getMerkleOpts(opts)
	  vOpts.proof = opts.proof
	
	  const verify = merkleProofs.verifier(vOpts)
	  return verify(opts.node)
	}
	
	function sha256 (data, enc) {
	  return crypto.createHash('sha256').update(data).digest(enc)
	}
	
	function concatSha256 (a, b, enc) {
	  return crypto.createHash('sha256').update(a).update(b).digest(enc)
	}
	
	// function importPriv (key, curve) {
	//   return typeof key === 'string'
	//     ? curve.keyFromPrivate(key)
	//     : key
	// }
	
	// function importPub (key, curve) {
	//   return typeof key === 'string'
	//     ? curve.keyFromPublic(key)
	//     : key
	// }
	
	function alphabetical (a, b) {
	  const al = a.toLowerCase()
	  const bl = b.toLowerCase()
	  return al < bl ? -1 : al > bl ? 1 : 0
	}
	
	function byIndexSort (a, b) {
	  return a.index - b.index
	}
	
	function getMerkleOpts (opts) {
	  const defaults = module.exports.DEFAULT_MERKLE_OPTS
	  if (!opts) return defaults
	
	  return {
	    leaf: opts.leaf || defaults.leaf,
	    parent: opts.parent || defaults.parent
	  }
	}
	
	function getLeaves (nodes) {
	  return nodes.filter(function (n) {
	    return n.index % 2 === 0
	  })
	}
	
	function find (arr, match) {
	  if (arr.find) return arr.find(match)
	
	  for (let i = 0; i < arr.length; i++) {
	    if (match(arr[i], i)) return arr[i]
	  }
	}
	
	function getKeys (obj) {
	  return Object.keys(obj).sort(alphabetical)
	}
	
	function getIndices (obj, keys) {
	  keys = keys || getKeys(obj)
	  const indices = {}
	  for (let i = 0; i < keys.length; i++) {
	    const key = keys[i]
	    indices[key] = {
	      key: flatTree.index(0, i * 2),
	      value: flatTree.index(0, i * 2 + 1)
	    }
	  }
	
	  return indices
	}
	
	function getKeyInputData (objInfo) {
	  typeforce({
	    sig: typeforce.Buffer,
	  }, objInfo)
	
	  return objInfo.sig
	}
	
	function getMerkleRoot (tree) {
	  return tree.roots[0].hash
	}
	
	function computeMerkleRoot (obj, opts) {
	  const tree = createMerkleTree(obj, getMerkleOpts(opts))
	  return getMerkleRoot(tree)
	}
	
	function toMerkleRoot (merkleRootOrObj, opts) {
	  return Buffer.isBuffer(merkleRootOrObj)
	    ? merkleRootOrObj
	    : computeMerkleRoot(getBody(merkleRootOrObj), opts)
	}
	
	// function getSigData (sigInput) {
	//   typeforce(types.sigInput, sigInput)
	
	//   return sha256(Buffer.concat([
	//     sigInput.merkleRoot,
	//     new Buffer(sigInput.recipient, 'hex')
	//   ]))
	// }
	
	function toPrivateKey (priv) {
	  if (priv.length !== 32) priv = sha256(priv)
	
	  while (!secp256k1.privateKeyVerify(priv)) {
	    priv = sha256(priv)
	  }
	
	  return priv
	}
	
	function getHeader (obj) {
	  if (!obj[SIG]) throw new Error('object must be signed')
	
	  const header = utils.pick(obj, HEADER_PROPS)
	  for (let p in header) {
	    const val = header[p]
	    if (Buffer.isBuffer(val)) {
	      header[p] = val.toString('base64')
	    }
	  }
	
	  return header
	}
	
	function getBody (obj) {
	  return utils.omit(obj, HEADER_PROPS)
	}
	
	function getStringLink (obj) {
	  return getLink(obj, 'hex')
	}
	
	function getLink (obj, enc) {
	  if (Buffer.isBuffer(obj)) {
	    if (obj.length === 32) {
	      return enc ? obj.toString(enc) : obj
	    } else {
	      try {
	        obj = JSON.parse(obj)
	      } catch (err) {
	        debugger
	      }
	    }
	  }
	
	  const header = getHeader(obj)
	  return sha256(stringify(header), enc)
	}
	
	function keyFromLink (link) {
	  return toPrivateKey(link)
	}
	
	function pubKeyFromLink (link) {
	  return {
	    curve: 'secp256k1',
	    pub: secp256k1.publicKeyCreate(keyFromLink(link))
	  }
	}
	
	function pubKeyFromObject (object) {
	  return pubKeyFromLink(getLink(object))
	}
	
	// function getPrevLink (objectOrLink) {
	//   const prev = Buffer.isBuffer(object) ? objectOrLink : object[PREV]
	//   return prev && sha256(prev)
	// }
	
	function getSealedPrevLink (object) {
	  const prevLink = isLinkAlike(object) ? object : object[PREV]
	  if (!prevLink) return
	
	  return sha256(new Buffer(prevLink, 'hex'))
	}
	
	function isLinkAlike (val) {
	  if (Buffer.isBuffer(val)) {
	    return val.length === 32
	  }
	
	  if (typeof val === 'string') {
	    try {
	      return isLinkAlike(new Buffer(val, 'hex'))
	    } catch (err) {
	    }
	  }
	}
	
	// function getPrevMessageLink (prevMsg) {
	//   typeforce(typeforce.Buffer, prevMsg[SIG])
	//   return sha256(prevMsg[SIG])
	// }
	
	// function getMsgSigData (opts) {
	//   return sha256(
	//     Buffer.concat([
	//       opts.object[SIG],
	//       opts.authorPubKey,
	//       opts.recipientPubKey
	//     ])
	//   )
	// }
	
	// function merkleSignMerkle (data, key, merkleOpts, cb) {
	//   const shareMerkleRoot = computeMerkleRoot(share, merkleOpts)
	//   share[SIG] = utils.sign(shareMerkleRoot, sigKey)
	// }
	
	// function normalize (obj) {
	//   // replace undefineds with nulls
	//   // so stringify/parse is consistent
	//   traverse(obj).forEach(function (val) {
	//     if (val === undefined) this.update(null)
	//   })
	
	//   return obj
	// }
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(820).Buffer))

/***/ },

/***/ 1173:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// a more low level interface to the merkle tree stream.
	// useful for certain applications the require non-streamy access to the algos.
	// versioned by the same semver as the stream interface.
	
	var flat = __webpack_require__(1171)
	
	module.exports = MerkleGenerator
	
	function MerkleGenerator (opts, roots) {
	  if (!(this instanceof MerkleGenerator)) return new MerkleGenerator(opts, roots)
	  if (!opts || !opts.leaf || !opts.parent) throw new Error('opts.leaf and opts.parent required')
	
	  this.roots = roots || opts.roots || []
	  this.blocks = this.roots.length ? 1 + flat.rightSpan(this.roots[this.roots.length - 1].index) / 2 : 0
	
	  for (var i = 0; i < this.roots.length; i++) {
	    var r = this.roots[i]
	    if (r && !r.parent) r.parent = flat.parent(r.index)
	  }
	
	  this._leaf = opts.leaf
	  this._parent = opts.parent
	}
	
	MerkleGenerator.prototype.next = function (data, nodes) {
	  if (!Buffer.isBuffer(data)) data = new Buffer(data)
	  if (!nodes) nodes = []
	
	  var index = 2 * this.blocks++
	
	  var leaf = {
	    index: index,
	    parent: flat.parent(index),
	    hash: null,
	    size: data.length,
	    data: data
	  }
	
	  leaf.hash = this._leaf(leaf, this.roots)
	  this.roots.push(leaf)
	  nodes.push(leaf)
	
	  return this._updateRoots(nodes)
	}
	
	MerkleGenerator.prototype._updateRoots = function (nodes, merge) {
	  if (!Array.isArray(nodes)) {
	    merge = nodes
	    nodes = []
	  }
	
	  var leaf
	  while (this.roots.length > 1) {
	    var left = this.roots[this.roots.length - 2]
	    var right = this.roots[this.roots.length - 1]
	
	    if (left.parent !== right.parent) {
	      if (!merge) break
	
	      // let a copy of the right root be its own partner
	      left = right
	      right = {
	        index: flat.sibling(right.index),
	        parent: right.parent,
	        hash: right.hash,
	        size: right.size,
	        data: right.data
	      }
	
	      this.roots.push(right)
	    }
	
	    this.roots.pop()
	    this.roots[this.roots.length - 1] = leaf = {
	      index: left.parent,
	      parent: flat.parent(left.parent),
	      hash: this._parent(left, right),
	      size: left.size + right.size,
	      data: null
	    }
	    nodes.push(leaf)
	  }
	
	  return nodes
	}
	
	MerkleGenerator.prototype.finalize = function () {
	  return this._updateRoots(true)
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(820).Buffer))

/***/ },

/***/ 1181:
/***/ function(module, exports) {

	module.exports = {
	  // backwards compatibility
	  ROOT_HASH: '_r',
	  CUR_HASH: '_c',
	  PREV_HASH: '_p',
	  // end backwards compatibility
	
	  NONCE: '_z',
	  PERMALINK: '_r',
	  LINK: '_c',
	  PREVLINK: '_p',
	  TYPE: '_t',
	  SIG: '_s'
	}


/***/ },

/***/ 1183:
/***/ function(module, exports, __webpack_require__) {

	exports.string = `
	  message ECSignature {
	    required ECPubKey pubKey = 1;
	    required bytes sig = 2;
	  }
	
	  message ECPubKey {
	    required string curve = 1;
	    required bytes pub = 2;
	  }
	`
	
	exports.schema = __webpack_require__(1184)(exports.string)


/***/ },

/***/ 1203:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, Buffer) {'use strict'
	
	const crypto = __webpack_require__(904)
	const secp256k1 = __webpack_require__(1174)
	const EC = __webpack_require__(962).ec
	const typeforce = __webpack_require__(1054)
	const stringify = __webpack_require__(1152)
	// const nkey = require('nkey-ec')
	const proto = __webpack_require__(1183).schema
	const types = __webpack_require__(1204)
	const noop = function () {}
	const slice = Array.prototype.slice
	const curves = {}
	const utils = exports
	
	exports.curve = function (name) {
	  if (typeof name !== 'string') return name
	
	  if (!curves[name]) {
	    curves[name] = new EC(name)
	  }
	
	  return curves[name]
	}
	
	exports.assert = function (statement, msg) {
	  if (!statement) throw new Error(msg || 'Assertion failed')
	}
	
	exports.asyncify = function asyncify (fn, allowMultipleCalls) {
	  if (!fn) return noop
	  if (fn._async) return fn
	
	  let ticked
	  let called
	  let once = !allowMultipleCalls
	  let ctx, args
	  process.nextTick(function () {
	    if (args) apply()
	    else ticked = true
	  })
	
	  const asyncFn = function () {
	    ctx = this
	    args = arguments
	    if (ticked) apply()
	  }
	
	  asyncFn._async = true
	  return asyncFn
	
	  function apply () {
	    if (called && once) return
	
	    called = true
	    fn.apply(ctx, args)
	  }
	}
	
	// TODO: use nkey
	exports.sign = function sign (msg, key) {
	  console.warn('utils.sign is deprecated, use nkey-{implementation} instead')
	  typeforce(types.ecPrivKey, key)
	
	  if (key.curve === 'secp256k1') {
	    let sig = secp256k1.sign(msg, key.priv)
	
	    // Ensure low S value
	    sig = secp256k1.signatureNormalize(sig.signature)
	
	    // Convert to DER array
	    return secp256k1.signatureExport(sig)
	  } else {
	    return new Buffer(utils.curve(key.curve).sign(msg, key.priv).toDER())
	  }
	}
	
	/**
	 * extract key from signature, verifying sig
	 */
	exports.getSigKey = function getSigKey (msg, sig, verify) {
	  console.warn('utils.getSigKey is deprecated')
	  const parsed = utils.parseSig(sig)
	  const key = parsed.pubKey
	  sig = parsed.sig
	  verify = verify || defaultVerify
	  if (verify(key, msg, sig)) return key
	}
	
	function defaultVerify (key, msg, sig) {
	  if (key.curve === 'secp256k1') {
	    sig = secp256k1.signatureImport(sig)
	    if (secp256k1.verify(msg, sig, key.pub)) {
	      return key
	    }
	  } else {
	    if (utils.curve(key.curve).verify(msg, sig, key.pub)) {
	      return key
	    }
	    // else {
	    //   console.log('nkey', nkey.fromJSON(key).verifySync(msg, sig))
	    // }
	  }
	}
	
	exports.publicKeyCombine = function (a, b) {
	  if (Array.isArray(a)) {
	    b = a[1]
	    a = a[0]
	  }
	
	  if (a.curve !== b.curve) {
	    throw new Error('curves do not match')
	  }
	
	  let val
	  if (a.curve === 'secp256k1') {
	    val = secp256k1.publicKeyCombine([a.pub, b.pub])
	  } else {
	    const curve = utils.curve(a.curve)
	    a = curve.keyFromPublic(a)
	    b = curve.keyFromPublic(b)
	    val = new Buffer(a.pub.add(b.pub).encode('buffer'))
	  }
	
	  return {
	    curve: a.curve,
	    pub: val
	  }
	}
	
	exports.ecPubKeysAreEqual = function (a, b) {
	  return a.curve === b.curve && a.pub.equals(b.pub)
	}
	
	exports.omit = function omit (obj) {
	  const props = Array.isArray(arguments[1]) ? arguments[1] : slice.call(arguments, 1)
	  let copy = {}
	  // let omitted = slice.call(arguments, 1)
	  for (let p in obj) {
	    if (props.indexOf(p) === -1) {
	      copy[p] = obj[p]
	    }
	  }
	
	  return copy
	}
	
	exports.pick = function pick (obj) {
	  const props = Array.isArray(arguments[1]) ? arguments[1] : slice.call(arguments, 1)
	  let copy = {}
	  let i = props.length
	  while (i--) {
	    let p = props[i]
	    if (p in obj) {
	      copy[p] = obj[p]
	    }
	  }
	
	  return copy
	}
	
	exports.sigToString = function (sig) {
	  return typeof sig === 'string' ? sig : sig.toString('base64')
	}
	
	exports.sigToBuf = function (sig) {
	  return Buffer.isBuffer(sig) ? sig : new Buffer(sig, 'base64')
	}
	
	exports.parseSig = function (sig) {
	  return utils.decodeSig(sig)
	}
	
	exports.decodeSig = function (sig) {
	  return proto.ECSignature.decode(utils.sigToBuf(sig))
	}
	
	exports.encodeSig = function (sig) {
	  if (typeof sig.sig === 'string') sig.sig = new Buffer(sig.sig, 'hex')
	
	  return proto.ECSignature.encode(sig)
	}
	
	/**
	 * return a value synchronously or asynchronously
	 * depending on if callback is passed
	 * @param  {anything}   val [description]
	 * @param  {?Function}  cb  [description]
	 * @return {anything}   val
	 */
	exports.maybeAsync = function maybeAsync (val, cb) {
	  if (cb) {
	    process.nextTick(function () {
	      cb(null, val)
	    })
	  }
	
	  return val
	}
	
	exports.genECKey = function (curve) {
	  curve = curve || 'secp256k1'
	  let priv, pub
	  if (curve === 'secp256k1') {
	    do {
	      priv = crypto.randomBytes(32)
	    } while (!secp256k1.privateKeyVerify(priv))
	
	    pub = secp256k1.publicKeyCreate(priv)
	  } else {
	    const pair = utils.curve(curve).genKeyPair()
	    priv = pair.getPrivate().toBuffer()
	    pub = new Buffer(pair.getPublic('buffer'))
	  }
	
	  return {
	    priv: priv,
	    pub: pub,
	    curve: curve
	  }
	}
	
	// exports.pubKeyToString = function (pubKey) {
	//   if (pubKey.type === 'ec') {
	//     return stringify({
	//       type: 'ec',
	//       pub: utils.hex(pubKey.pub),
	//       curve: pubKey.curve
	//     })
	//   }
	
	//   return stringify(utils.pick(pubKey, 'type', 'pub'))
	// }
	
	// exports.pubKeyFromString = function (str) {
	//   const pubKey = JSON.parse(str)
	//   if (pubKey.type === 'ec') {
	//     pubKey.pub = new Buffer(pubKey.pub, 'hex')
	//   }
	
	//   return pubKey
	// }
	
	// exports.pubKeyToString = function (pubKey) {
	//   return stringify(pubKey, alphabetical)
	// }
	
	// exports.pubKeyFromString = rebuf
	
	// function alphabetical (a, b) {
	//   return a < b ? -1 :
	//     a > b ? 1 : 0
	// }
	
	// function rebuf (json) {
	//   if (Object.prototype.toString.call(json) !== '[object Object]') return json
	
	//   if (json &&
	//     json.type === 'Buffer' &&
	//     json.data &&
	//     !Buffer.isBuffer(json) &&
	//     Object.keys(json).length === 2) {
	//     return new Buffer(json.data)
	//   } else {
	//     for (var p in json) {
	//       json[p] = rebuf(json[p])
	//     }
	
	//     return json
	//   }
	// }
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(294), __webpack_require__(820).Buffer))

/***/ },

/***/ 1204:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {
	const typeforce = __webpack_require__(1054)
	const traverse = __webpack_require__(1205)
	const constants = __webpack_require__(1181)
	const TYPE = constants.TYPE
	const MESSAGE_TYPE = constants.MESSAGE_TYPE
	const SIG = constants.SIG
	const SEQ = constants.SEQ
	const PREV_TO_SENDER = constants.PREV_TO_SENDER
	const PREVLINK = constants.PREVLINK
	const PERMALINK = constants.PERMALINK
	const types = exports
	
	exports.merkleNode = typeforce.compile({
	  hash: typeforce.Buffer,
	  index: typeforce.Number
	})
	
	exports.merkleLeaf = typeforce.compile({
	  data: typeforce.Buffer,
	  hash: typeforce.Buffer,
	  index: typeforce.Number
	})
	
	exports.merkleTree = typeforce.compile({
	  nodes: typeforce.arrayOf(exports.merkleNode),
	  roots: typeforce.arrayOf(exports.merkleNode)
	})
	
	// exports.key = typeforce.oneOf(typeforce.String, typeforce.Object)
	
	exports.keyObj = function keyObj (val) {
	  return pub && (Buffer.isBuffer(val.pub) || Buffer.isBuffer(val.priv))
	}
	
	exports.merkleRootOrObj = typeforce.oneOf(typeforce.Object, typeforce.Buffer)
	
	// const OBJECT_TYPE = typeforce.compile({
	//   header: typeforce.Object,
	//   body: typeforce.Object
	// })
	
	// exports.sigInput = typeforce.compile({
	//   merkleRoot: typeforce.Buffer,
	//   recipient: typeforce.Buffer
	// })
	
	// exports.header = typeforce.compile({
	//   sig: typeforce.Buffer,
	//   sigKey: typeforce.Buffer,
	//   sigInput: exports.sigInput,
	//   txId: typeforce.maybe(typeforce.String)
	// })
	
	exports.ecPubKey = typeforce.compile({
	  pub: typeforce.Buffer,
	  curve: typeforce.String
	})
	
	exports.ecPrivKey = typeforce.compile({
	  priv: typeforce.Buffer,
	  curve: typeforce.String
	})
	
	exports.chainPubKey = function chainPubKey (key) {
	  return Buffer.isBuffer(key.pub) && key.curve === 'secp256k1'
	}
	
	exports.author = typeforce.compile({
	  sigPubKey: exports.ecPubKey,
	  sign: typeforce.Function
	})
	
	exports.recipient = typeforce.compile({
	  pubKey: exports.ecPubKey,
	  link: typeforce.String
	})
	
	// exports.sig = typeforce.compile({
	//   pubKey: types.ecPubKey,
	//   sig: typeforce.Buffer
	// })
	
	exports.object = isValidObject
	
	exports.rawObject = function rawObject (val) {
	  return typeof val[SIG] === 'undefined' &&
	  isValidObject(val) &&
	  // typeof val[NONCE] === 'string' &&
	  isVersionedCorrectly(val)
	}
	
	exports.signedObject = function signedObject (val) {
	  return typeof val[SIG] === 'string' && isValidObject(val) && isVersionedCorrectly(val)
	}
	
	exports.linkOrObject = typeforce.oneOf(typeforce.String, types.signedObject)
	
	exports.messageBody = typeforce.compile({
	  recipientPubKey: types.ecPubKey,
	  object: types.signedObject,
	  [SEQ]: typeforce.maybe(typeforce.Number),
	  [PREV_TO_SENDER]: typeforce.maybe(types.linkOrObject)
	})
	
	function isVersionedCorrectly (obj) {
	  // both or neither must be present
	  if (PERMALINK in obj) {
	    return typeof obj[PERMALINK] === 'string' && typeof obj[PREVLINK] === 'string'
	  }
	
	  return typeof obj[PREVLINK] === 'undefined'
	
	  // return !!obj[PERMALINK] === !!obj[PREVLINK]
	}
	
	function noUndefinedValues (obj) {
	  var failed
	  traverse(obj).forEach(function (val) {
	    if (val === undefined) {
	      failed = true
	      this.update(undefined, true) // stop traversing
	    }
	  })
	
	  return !failed
	}
	
	function isValidObject (obj) {
	  return typeof obj[TYPE] === 'string' && noUndefinedValues(obj)
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(820).Buffer))

/***/ },

/***/ 1206:
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	/**
	 * @module sender
	 */
	
	const EventEmitter = __webpack_require__(786).EventEmitter
	const typeforce = __webpack_require__(1207)
	const pump = __webpack_require__(1208)
	const thunky = __webpack_require__(1212)
	const through = __webpack_require__(1213)
	const debug = __webpack_require__(787)('tradle:sender')
	const protocol = __webpack_require__(1150)
	const topics = __webpack_require__(1221)
	const statuses = __webpack_require__(1222)
	const types = __webpack_require__(1223)
	const utils = __webpack_require__(1225)
	const controls = __webpack_require__(1375)
	const Channel = __webpack_require__(1376)
	
	module.exports = createSender
	
	/**
	 * @typedef {Object} sender
	 */
	
	/**
	 * message send with retry
	 * @alias module:sender
	 * @param {Object}        opts
	 * @param {Function}      opts.send
	 * @param {objectsDB}     opts.objects
	 * @param {addressBook}   opts.addressBook
	 * @param {Actions}       opts.actions
	 * @param {Object}        opts.backoffOptions
	 * @param {string}        [opts.name] (for logging)
	 */
	function createSender (opts) {
	  typeforce({
	    send: typeforce.Function,
	    objects: typeforce.Object,
	    addressBook: typeforce.Object,
	    actions: typeforce.Object,
	    backoffOptions: typeforce.maybe(typeforce.Object),
	    name: typeforce.maybe(typeforce.String)
	  }, opts)
	
	  const myDebug = utils.subdebugger(debug, opts.name)
	  const actions = opts.actions
	  const objects = opts.objects
	  const addressBook = opts.addressBook
	  const send = opts.send
	  const sender = new EventEmitter()
	  sender.pause = function (recipient) {
	    if (!recipient) return sender.pauseAll()
	    if (!paused[recipient]) {
	      paused[recipient] = true
	      const channel = channels[recipient]
	      if (channel) channel.pause()
	    }
	
	    return sender.resume.bind(sender, recipient)
	  }
	
	  sender.pauseAll = function () {
	    forEachChannel(channel => channel.pause())
	
	    if (unsentStream) {
	      unsentStream.pause()
	      // unsentStream = null
	    }
	  }
	
	  sender.resume = function (recipient) {
	    if (destroyed) return
	    if (!recipient) return sender.resumeAll()
	    if (paused[recipient]) {
	      delete paused[recipient]
	      activateChannel(recipient)
	    }
	  }
	
	  let destroyed
	  let unsentStream
	  let paused = {}
	  const channels = {}
	
	  sender.start = start
	  sender.stop = destroy
	  sender.resumeAll = function () {
	    paused = {}
	    for (var recipient in channels) {
	      channels[recipient].resume()
	    }
	  }
	
	  sender.isRunning = () => !!unsentStream
	
	  return sender
	
	  function forEachChannel (fn) {
	    Object.keys(channels).forEach(recipient => fn(channels[recipient]))
	  }
	
	  function destroy () {
	    destroyed = true
	    forEachChannel(channel => channel.destroy())
	
	    if (unsentStream) {
	      unsentStream.end()
	      // unsentStream = null
	    }
	
	    return sender.resumeAll.bind(sender)
	  }
	
	  function normalizeRecipients (recipients) {
	    return recipients ? [].concat(recipients) : Object.keys(recipientStreams)
	  }
	
	  function getChannels (recipients) {
	    return recipients.map(rh => channels[rh])
	      // filter out nulls
	      .filter(stream => stream)
	  }
	
	  function activateChannel (permalink) {
	    if (paused[permalink]) return
	    // this resume() not needed anymore as channel drains itself
	    if (channels[permalink]) return channels[permalink].resume()
	
	    const channelOpts = utils.extend({ recipient: permalink }, opts)
	    const channel = channels[permalink] = new Channel(channelOpts)
	    channel.once('error', err => {
	      myDebug(`channel ${permalink} experienced error`, err.stack)
	      channel.destroy()
	    })
	
	    channel.once('destroy', () => delete channels[permalink])
	    addressBook.byPermalink(permalink, function (err, recipientInfo) {
	      if (err) return sender.emit('error', err)
	
	      channel.setRecipient(recipientInfo)
	      if (!paused[permalink]) channel.start()
	    })
	  }
	
	  function start () {
	    if (destroyed || unsentStream) return
	
	    paused = {}
	    unsentStream = pump(
	      objects.unsent({ live: true, keys: false, body: false }),
	      through.obj(function (data, enc, cb) {
	        activateChannel(data.recipient)
	        cb()
	      })
	    )
	
	    unsentStream.on('error', function (err) {
	      myDebug('error in unsent messages stream: ' + err.stack)
	      sender.emit('error', err)
	    })
	
	    return function stop () {
	      unsentStream.end()
	
	      for (let rh in channels) {
	        channels[rh].destroy()
	      }
	    }
	  }
	}


/***/ },

/***/ 1207:
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * typeforce wrapper, disabled in production mode
	 * @module typeforce
	 */
	
	const extend = __webpack_require__(1151)
	const typeforce = __webpack_require__(1054)
	const debug = __webpack_require__(787)('tradle:debug')
	
	module.exports = extend(function typeforceWithDebug () {
	  if (!debug.enabled) return typeforce.apply(typeforce, arguments)
	
	  try {
	    return typeforce.apply(typeforce, arguments)
	  } catch (err) {
	    debug('typecheck failed: ' + err.stack, arguments)
	    throw err
	  }
	}, typeforce)


/***/ },

/***/ 1221:
/***/ function(module, exports) {

	'use strict'
	
	/**
	 * log topics
	 * @module topics
	 */
	
	module.exports = exports = {
	  newobj: 'newobj',
	  archiveobj: 'archiveobj',
	  unarchiveobj: 'unarchiveobj',
	  // setidentity: 'setidentity',
	  addcontact: 'addcontact',
	  tx: 'tx',
	  newwatch: 'newwatch',
	  queueseal: 'queueseal',
	  wroteseal: 'wroteseal',
	  readseal: 'readseal',
	  sent: 'sent',
	  received: 'received',
	  forget: 'forget'
	}
	
	exports.reverse = {}
	for (let p in exports) {
	  exports.reverse[exports[p]] = p
	}


/***/ },

/***/ 1222:
/***/ function(module, exports) {

	
	/**
	 * statuses of various db objects
	 * @module status
	 */
	
	module.exports = {
	  seal: {
	    pending: '0',
	    sealed: '1'
	  },
	  send: {
	    pending: '0',
	    sent: '1'
	  },
	  // receive: {
	  //   notreceived: '0',
	  //   received: '1'
	  // },
	  watch: {
	    unseen: '0',
	    seen: '1',
	    confirmed: '2'
	  },
	  tx: {
	    unconfirmed: '0',
	    confirmed: '1'
	  }
	}


/***/ },

/***/ 1223:
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * complex types used in type checks throughout the library
	 * @module types
	 */
	
	const typeforce = __webpack_require__(1207)
	const extend = __webpack_require__(1151)
	const protocol = __webpack_require__(1150)
	const constants = __webpack_require__(1224)
	const SIG = constants.SIG
	const TYPE = constants.TYPE
	const PERMALINK = constants.PERMALINK
	const LINK = constants.LINK
	const types = exports
	
	extend(exports, protocol.types)
	
	exports.bufferOrString = typeforce.oneOf(typeforce.Buffer, typeforce.String)
	
	// exports.hasRootHash = function hasPermalink (value) {
	//   return !!value[PERMALINK]
	// }
	
	/**
	 * @typedef {Object} identifier
	 */
	exports.identifier = function identifier (value) {
	  if (!(value && typeof value === 'object')) return false
	
	  var stringy = value.fingerprint || value.permalink || value.link
	  if (stringy) return typeforce(typeforce.String, stringy)
	
	  var pubKey = value.pubKey
	  if (pubKey) {
	    return pubKey.type === 'ec'
	      ? typeforce(types.ecPubKey, pubKey)
	      : typeforce(types.pubKey, pubKey)
	  }
	
	  return false
	}
	
	/**
	 * @typedef {Object} pubKey
	 */
	exports.pubKey = typeforce.compile({
	  fingerprint: typeforce.String,
	  purpose: typeforce.String,
	  type: typeforce.String,
	  pub: typeforce.String,
	  networkName: typeforce.maybe(typeforce.String)
	})
	
	/**
	 * @typedef {Object} identity
	 */
	exports.identity = function identity (value) {
	  if (value[TYPE] !== constants.TYPES.IDENTITY) return false
	
	  try {
	    typeforce({
	      pubkeys: typeforce.arrayOf(types.pubKey)
	    }, value)
	  } catch (err) {
	    return false
	  }
	
	  return true
	}
	
	/**
	 * @typedef {Object} transactor
	 */
	exports.transactor = typeforce.compile({
	  send: typeforce.Function
	})
	
	/**
	 * @typedef {Object|Function} leveldown
	 */
	exports.leveldown = typeforce.oneOf(typeforce.Object, typeforce.Function)
	
	/**
	 * @typedef {Object} changes
	 */
	exports.changes = typeforce.compile({
	  append: typeforce.Function
	})
	
	/**
	 * @typedef {Object} levelup
	 */
	exports.db = typeforce.compile({
	  get: typeforce.Function,
	  put: typeforce.Function,
	  batch: typeforce.Function,
	  createReadStream: typeforce.Function,
	  close: typeforce.Function
	})
	
	// exports.logbase = typeforce.compile({
	//   get: typeforce.Function,
	//   put: typeforce.Function,
	//   batch: typeforce.Function,
	//   createReadStream: typeforce.Function,
	//   close: typeforce.Function,
	//   live: typeforce.compile({
	//     get: typeforce.Function,
	//     createReadStream: typeforce.Function
	//   })
	// })
	
	/**
	 * @typedef {Object} Keeper
	 */
	exports.keeper = types.db
	
	/**
	 * @typedef {Object} objectInfo
	 */
	exports.objectInfo = typeforce.compile({
	  object: types.object,
	  permalink: typeforce.String,
	  link: typeforce.String,
	  prevLink: typeforce.maybe(typeforce.String)
	})
	
	/**
	 * @typedef {Object} someObjectInfo
	 */
	exports.someObjectInfo = typeforce.compile({
	  object: typeforce.maybe(types.signedObject),
	  permalink: typeforce.maybe(typeforce.String),
	  link: typeforce.maybe(typeforce.String),
	  prevLink: typeforce.maybe(typeforce.String)
	})
	
	/**
	 * @typedef {Object} identityInfo
	 */
	exports.identityInfo = typeforce.compile({
	  object: types.identity,
	  permalink: typeforce.String,
	  link: typeforce.String,
	  prevLink: typeforce.maybe(typeforce.String)
	})
	
	/**
	 * @typedef {Object} Blockchain
	 */
	exports.blockchain = typeforce.compile({
	  transactions: typeforce.compile({
	    get: typeforce.Function
	  }),
	  addresses: typeforce.compile({
	    transactions: typeforce.Function
	  })
	})
	
	/**
	 * @typedef {Object} seal
	 */
	exports.seal = typeforce.compile({
	  basePubKey: types.chainPubKey,
	  link: typeforce.String
	})
	
	// exports.wrapper = typeforce.compile({
	//   object: types.signedObject,
	//   permalink: typeforce.String,
	//   link: typeforce.String,
	//   prevLink: typeforce.maybe(typeforce.String)
	// })


/***/ },

/***/ 1224:
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * @module constants
	 * @augments tradle/protocol/lib/constants
	 */
	
	const extend = __webpack_require__(1151)
	const protocol = __webpack_require__(1150)
	
	module.exports = extend({
	  /**
	   * @constant
	   * @type {string}
	   * @default
	   */
	  MESSAGE_TYPE: 'tradle.Message',
	  /**
	   * @constant
	   * @type {string}
	   * @default
	   */
	  PREV_TO_SENDER: '_q',
	  /**
	   * @constant
	   * @type {string}
	   * @default
	   */
	  SEQ: '_n',
	  /**
	   * @constant
	   * @type {Object}
	   * @default
	   */
	  IDENTITY_VERSIONING_KEY: {
	    purpose: 'update'
	  },
	  /**
	   * @constant
	   * @type {Object}
	   * @default
	   */
	  TYPES: {
	    MESSAGE: 'tradle.Message',
	    IDENTITY: 'tradle.Identity',
	    PARTIAL: 'tradle.Partial'
	  },
	  /**
	   * @constant
	   * @type {string}
	   * @default
	   */
	  INDEX_SEPARATOR: '!',
	  /**
	   * @constant
	   * @type {Object}
	   * @default
	   */
	  watchType: {
	    thisVersion: 't',
	    nextVersion: 'n'
	  },
	  /**
	   * @constant
	   * @type {Object}
	   * @default
	   */
	  DEFAULT_BACKOFF_OPTS: {
	    initialDelay: 1000,
	    maxDelay: 60000
	  },
	
	  ENTRY_PROP: '_'
	}, protocol.constants)


/***/ },

/***/ 1225:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict'
	
	/**
	 * utils
	 * @module utils
	 * @augments tradle/protocol/lib/utils
	 */
	
	const crypto = __webpack_require__(904) // maybe we only need createHash
	const extend = __webpack_require__(1151)
	const clone = __webpack_require__(859)
	const collect = __webpack_require__(1051)
	const once = __webpack_require__(1052)
	const Stream = __webpack_require__(829)
	const Readable = Stream.Readable
	const PassThrough = Stream.PassThrough
	const pump = __webpack_require__(1208)
	const combine = __webpack_require__(1226)
	const stringify = __webpack_require__(1152)
	const deepEqual = __webpack_require__(711)
	const bs58check = __webpack_require__(1237)
	const async = __webpack_require__(1239)
	const subdown = __webpack_require__(1240)
	const through = __webpack_require__(1213)
	const levelup = __webpack_require__(1268)
	const levelErrors = __webpack_require__(1259)
	const LiveStream = __webpack_require__(1275)
	const hydration = __webpack_require__(1293)
	const mutexify = __webpack_require__(1146)
	const bitcoin = __webpack_require__(1294)
	// const kiki = require('@tradle/kiki')
	// const nkeyEC = require('nkey-ec')
	// const nkeyBitcoin = require('nkey-bitcoin')
	const nkeyImpls = loadNKeyImplementations()
	const protocol = __webpack_require__(1150)
	const putils = __webpack_require__(1203)
	const schema = __webpack_require__(1323).schema
	const typeforce = __webpack_require__(1207)
	const constants = __webpack_require__(1224)
	const topics = __webpack_require__(1221)
	const types = __webpack_require__(1223)
	const networks = __webpack_require__(1324)
	const head = __webpack_require__(1325)
	const manifest = __webpack_require__(1326)
	const errors = __webpack_require__(1327)
	const hydra = hydration()
	const {
	  TYPE,
	  TYPES,
	  PERMALINK,
	  PREV_TO_SENDER,
	  LINK,
	  PREVLINK,
	  SIG,
	  SEQ
	} = constants
	
	const {
	  IDENTITY,
	  MESSAGE,
	  PARTIAL
	} = TYPES
	
	/**
	 * @constant
	 * @type {String}
	 * @default
	 */
	const DEFAULT_CURVE = 'p256'
	/**
	 * @constant
	 * @type {String}
	 * @default
	 */
	const DEFAULT_NETWORK = 'testnet'
	
	const utils = exports
	
	;['omit', 'pick', 'asyncify', 'ecPubKeysAreEqual', 'assert', 'sign', 'parseSig'].forEach(method => {
	  utils[method] = putils[method]
	})
	
	exports.stringify = stringify
	exports.deepEqual = deepEqual
	
	exports.find = function (arr /* filters */) {
	  let match
	  const filters = Array.prototype.slice.call(arguments, 1)
	  arr.some(function (item) {
	    if (filters.every(f => f(item))) {
	      match = item
	      return true
	    }
	  })
	
	  return match
	}
	
	exports.eqOpts = function (val) {
	  return {
	    lte: val,
	    gte: val
	  }
	}
	
	exports.hex = function hex (val) {
	  return val.toString('hex')
	}
	
	exports.noop = function noop () {}
	
	exports.mergeStreams = function mergeStreams (streams, compare) {
	  const arr = []
	  const out = new Readable({ objectMode: true })
	  out._read = utils.noop
	  let togo = streams.length
	  streams.forEach(stream => {
	    stream.on('end', done)
	    stream.on('data', data => arr.push(data))
	  })
	
	  return out
	
	  function done (cb) {
	    if (--togo) return
	
	    arr.sort(compare).forEach(out.push, out)
	    out.push(null)
	  }
	}
	
	exports.notFoundErr = function notFoundErr () {
	  return new levelErrors.NotFoundError()
	}
	
	// exports.watchUID = function watchUID (opts) {
	//   typeforce({
	//     address: typeforce.String,
	//     link: typeforce.String,
	//     watchType: typeforce.String
	//   }, opts)
	
	//   return `watch:${opts.watchType}:${opts.address}:${opts.link}`
	// }
	
	// exports.addBody = function addBody (keeper, wrapper, link, cb) {
	//   keeper.get(link, function (err, body) {
	//     if (err) return cb(err)
	
	//     wrapper.object = body
	//     cb()
	//   })
	// }
	
	// exports.getSealAddresses = function (seal) {
	//   typeforce({
	//     sealAddress: typeforce.String,
	//     sealPrevAddress: typeforce.maybe(typeforce.String)
	//   }, seal)
	
	//   const arr = [seal.sealAddress]
	//   if (seal.sealPrevAddress) arr.push(seal)
	
	//   return arr
	// }
	
	// utils.sealUID = function sealUID (opts) {
	//   typeforce({
	//     link: typeforce.String,
	//     networkName: typeforce.String,
	//     sealAddress: typeforce.maybe(typeforce.String),
	//     sealPrevAddress: typeforce.maybe(typeforce.String),
	//     sealPubKey: typeforce.maybe(types.chainPubKey),
	//     sealPrevPubKey: typeforce.maybe(types.chainPubKey)
	//   }, opts)
	
	//   const sealAddress = opts.sealAddress
	//     || (opts.sealPubKey && utils.pubKeyToAddress(opts.sealPubKey, opts.networkName))
	//     || ''
	
	//   const sealPrevAddress = opts.sealPrevAddress
	//     || (opts.sealPrevPubKey && utils.pubKeyToAddress(opts.sealPrevPubKey, opts.networkName))
	//     || ''
	
	//   if (!(sealAddress || sealPrevAddress)) throw Error('expeted "sealAddress" or "sealPrevAddress"')
	
	//   return `seal:${opts.networkName}:${sealAddress}:${sealPrevAddress}:${opts.link}`
	// }
	
	exports.uid = function (opts) {
	  const links = utils.getLinks(opts)
	  return links.permalink + ':' + links.link
	
	  // const object = opts.object
	  // const link = utils.hexLink(opts.link || object)
	  // const permalink = opts.permalink || object[PERMALINK] || link
	  // return link + ':' + permalink
	}
	
	// exports.prevUID = function (opts) {
	//   const links = utils.getLinks(opts)
	//   if (!links.prevLink) throw new Error('missing prevLink')
	
	//   return links.permalink + ':' + links.prevLink
	// }
	
	// exports.parseUID = function (uid) {
	//   const parts = uid.split(':')
	//   return {
	//     [PERMALINK]: parts[0],
	//     [LINK]: parts[1]
	//   }
	// }
	
	// exports.getMsgID = function getMsgID (opts) {
	//   typeforce({
	//     link: types.bufferOrString,
	//     sender: typeforce.bufferOrString,
	//     recipient: typeforce.bufferOrString
	//   }, opts)
	
	//   return [
	//     'msg',
	//     utils.hex(opts.sender),
	//     utils.hex(opts.recipient),
	//     utils.hex(opts.link)
	//   ].join(':')
	// }
	
	// exports.augment = function augment (wrapper, keeper, cb) {
	//   keeper.get(utils.hex(wrapper.link), function (err, obj) {
	//     if (err) return cb(err)
	
	//     wrapper.object = obj
	//     cb(null, wrapper)
	//   })
	// }
	
	exports.sigKey = keys => utils.find(keys, isSigningKey, isPrivateKey)
	
	// exports.sigKeys = keys => keys.filter(isSigningKey)
	
	exports.sigPubKey = function (identity) {
	  const key = utils.find(identity.pubkeys, isSigningKey)
	  return key && utils.toECKeyObj(key)
	}
	
	exports.identityVersioningKey = keys => utils.find(keys, isIdentityVersioningKey, isPrivateKey)
	
	exports.identityVersioningPubKey = function identityVersioningPubKey (identity) {
	  const key = utils.find(identity.pubkeys, isIdentityVersioningKey)
	  return key && utils.toECKeyObj(key)
	}
	
	// exports.sigPubKeys = identity => identity.pubkeys.filter(isSigningKey)
	
	exports.chainKey = keys => utils.find(keys, isChainKey, isPrivateKey)
	
	// exports.chainKeys = keys => keys.filter(isChainKey)
	
	exports.chainPubKey = function chainPubKey (identity) {
	  const key = utils.find(identity.pubkeys, isChainKey)
	  return key && utils.toECKeyObj(key)
	}
	
	// exports.chainPubKeys = identity => identity.pubkeys.filter(isChainKey)
	
	exports.toECKeyObj = function toECKeyObj (key) {
	  return {
	    curve: key.type === 'bitcoin' ? 'secp256k1' : key.curve,
	    pub: new Buffer(key.pub, 'hex')
	  }
	}
	
	exports.bindFunctions = function bindFunctions (obj) {
	  for (let p in obj) {
	    const val = obj[p]
	    if (typeof val === 'function') {
	      obj[p] = obj[p].bind(obj)
	    }
	  }
	
	  return obj
	}
	
	exports.findPubKey = function (identity, props) {
	  typeforce(types.identity, identity)
	  typeforce({
	    pub: types.bufferOrString
	  }, props)
	
	  return utils.find(identity.pubkeys, key => {
	    for (let p in props) {
	      let pVal = props[p]
	      if (Buffer.isBuffer(pVal)) {
	        // key encoding should really be recorded in each key in an identity
	        pVal = pVal.toString('hex')
	      }
	
	      if (pVal !== key[p]) {
	        return false
	      }
	    }
	
	    return true
	  })
	}
	
	exports.hasPubKey = function (identity, props) {
	  return !!utils.findPubKey(identity, props)
	}
	
	/**
	 * shallow extend an object
	 * @static
	 * @param {Object} obj
	 * @returns {Object} passed in object
	 */
	exports.extend = extend
	
	/**
	 * shallow clone an object
	 * @static
	 * @param {Object} obj
	 * @returns {Object} a new object with copied-over props
	 */
	exports.clone = clone
	
	/**
	 * calculate an object's link
	 * @static
	 * @param  {Object} object
	 * @return {String}
	 */
	exports.hexLink = function (object) {
	  return utils.hex(protocol.link(object))
	}
	
	exports.linkToBuf = function (link) {
	  return Buffer.isBuffer(link) ? link : new Buffer(link, 'hex')
	}
	
	// utils.toBuffer = function (obj, enc) {
	//   return Buffer.isBuffer(obj) ? obj :
	//     typeof obj === 'string' ? new Buffer(obj, enc) :
	//       new Buffer(JSON.stringify(obj), enc)
	// }
	
	exports.filterStream = function (test) {
	  return through.obj(function (data, enc, cb) {
	    cb(null, test(data) ? data : null)
	  })
	}
	
	// exports.flatten = function (arr) {
	//   // flatten array of arrays
	//   return arr.reduce((flat, nextArr) => {
	//     return flat.concat(nextArr)
	//   }, [])
	// }
	
	// exports.stringToObject = str => rebuf(JSON.parse(str))
	
	exports.opToBatch = function (op) {
	  return op.batch ? op.batch : [op.value]
	}
	
	/**
	 * sha256
	 * @static
	 * @param  {Buffer|String} data
	 * @return {Buffer}
	 */
	exports.sha256 = function (data) {
	  return crypto.createHash('sha256').update(data).digest()
	}
	
	exports.pubKeyString = function (key) {
	  if (typeof key === 'string') return key
	
	  typeforce(typeforce.Buffer, key.pub)
	
	  return key.pub.toString('hex')
	}
	
	exports.pubKeyToAddress = function pubKeyToAddress (pubKey, networkName) {
	  typeforce(typeforce.Buffer, pubKey.pub)
	
	  const network = networks[networkName]
	  if (!network) throw new Error('invalid "networkName": ' + networkName)
	
	  let hash = utils.sha256(pubKey.pub)
	  hash = crypto.createHash('ripemd160').update(hash).digest()
	
	  const version = network.pubKeyHash
	  let payload = new Buffer(21)
	  payload.writeUInt8(version, 0)
	  hash.copy(payload, 1)
	
	  return bs58check.encode(payload)
	}
	
	exports.privToWIF = function (priv, networkName, compressed) {
	  typeforce(typeforce.Buffer, priv)
	  typeforce(typeforce.String, networkName)
	
	  const network = networks[networkName]
	  if (!network) throw new Error('invalid "networkName": ' + networkName)
	
	  var bufferLen = compressed ? 34 : 33
	  var buffer = new Buffer(bufferLen)
	
	  buffer.writeUInt8(network.wif, 0)
	  priv.copy(buffer, 1)
	
	  if (compressed) {
	    buffer.writeUInt8(0x01, 33)
	  }
	
	  return bs58check.encode(buffer)
	}
	
	exports.objectInfo = function objectInfo (wrapper) {
	  const info = utils.getLinks(wrapper)
	  info.object = wrapper.object
	  return info
	}
	
	exports.getLinks = function getLinks (wrapper) {
	  typeforce({
	    object: typeforce.maybe(types.signedObject),
	    permalink: typeforce.maybe(typeforce.String),
	    link: typeforce.maybe(typeforce.String),
	    prevLink: typeforce.maybe(typeforce.String)
	  }, wrapper)
	
	  const object = wrapper.object
	  const link = wrapper.link || (object && utils.hexLink(object))
	  const links = {
	    link: link,
	    permalink: wrapper.permalink || (object ? object[PERMALINK] || link : null)
	  }
	
	  const prevLink = wrapper.prevLink || (object && object[PREVLINK])
	  if (prevLink) links.prevLink = prevLink
	
	  if (!links.permalink && links.prevLink) {
	    throw new Error('expected "permalink"')
	  }
	
	  return links
	}
	
	exports.addLinks = function addLinks (wrapper) {
	  return utils.extend(wrapper, utils.getLinks(wrapper))
	}
	
	exports.maybeAddPrev = function maybeAddPrev (node, wrapper, cb) {
	  if (wrapper.prev) return cb()
	
	  const prevLink = wrapper.object[PREVLINK]
	  if (!prevLink) return cb()
	
	  // const uid = utils.prevUID(wrapper)
	  node.objects.get({ link: prevLink }, function (err, prev) {
	    // if (err) return cb(err)
	
	    wrapper.prev = prev
	    cb()
	  })
	}
	
	// exports.xor = function (a, b) {
	//   if (typeof a !== 'number') a = a ? 1 : 0
	//   if (typeof b !== 'number') b = b ? 1 : 0
	
	//   return a ^ b
	// }
	
	// exports.addAuthors = function addAuthors (wrappers, addressBook, cb) {
	//   async.each(wrappers, function iterator (wrapper, done) {
	//     utils.addAuthor(wrapper, addressBook, done)
	//   }, cb)
	// }
	
	exports.addRecipient = function addRecipient (node, wrapper, cb) {
	  if (wrapper.object[TYPE] !== MESSAGE) return cb()
	
	  utils.lookupRecipient(node, wrapper, function (err, objectInfo) {
	    if (err) return cb(err)
	
	    wrapper.recipient = objectInfo
	    cb()
	  })
	}
	
	exports.lookupRecipient = function (node, wrapper, cb) {
	  if (wrapper.object[TYPE] !== MESSAGE) throw new Error('expected a message object')
	
	  node.addressBook.byPubKey(wrapper.object.recipientPubKey, cb)
	}
	
	exports.addAuthor = function addAuthor (node, wrapper, cb) {
	  utils.lookupAuthor(node, wrapper, function (err, objectInfo) {
	    if (err) return cb(err)
	
	    wrapper.author = objectInfo
	    cb()
	  })
	}
	
	exports.lookupAuthor = function lookupAuthor (node, wrapper, cb) {
	  const author = wrapper.author
	  if (author && typeof author === 'object') {
	    if (author.object) {
	      return cb(null, author)
	    }
	
	    if (author.link) {
	      return node.addressBook.byLink(author.link, cb)
	    }
	  }
	
	  getPubKey(function (err, pubKey) {
	    if (err) return cb(err)
	
	    node.addressBook.byPubKey(utils.pubKeyString(pubKey), cb)
	  })
	
	  function getPubKey (done) {
	    if (wrapper.verify) {
	      utils.extractSigPubKey(wrapper.object, done)
	    } else {
	      done(null, utils.claimedSigPubKey(wrapper.object))
	    }
	  }
	}
	
	exports.shortlink = function (link) {
	  return link.slice(0, 6)
	}
	
	exports.subdebugger = function (debug, name) {
	  // accept `node` or string
	  name = name && name.name || name
	  typeforce(typeforce.String, name)
	  return function () {
	    utils.subdebug(debug, name, arguments)
	  }
	}
	
	exports.subdebug = function (debug, name, args) {
	  args = [].slice.call(args)
	  args.unshift(name)
	  return debug.apply(null, args)
	}
	
	exports.loadBG = function loadBG (node, wrapper, cb) {
	  utils.addLinks(wrapper)
	
	  const tasks = [
	    taskCB => utils.addAuthor(node, wrapper, taskCB),
	    taskCB => utils.addRecipient(node, wrapper, taskCB),
	    taskCB => utils.maybeAddPrev(node, wrapper, taskCB),
	    taskCB => utils.addPartialInfo(node, wrapper, taskCB)
	  ]
	
	  async.parallel(tasks, cb)
	}
	
	exports.addPartialInfo = function addPartialInfo (node, wrapper, cb) {
	  utils.getPartialInfo(node, wrapper, function (err, partialinfo) {
	    if (err) return cb(err)
	
	    wrapper.partialinfo = partialinfo
	    cb()
	  })
	}
	
	exports.getPartialInfo =  function getPartialInfo (node, wrapper, cb) {
	  const { object, skipValidation } = wrapper
	  if (object[TYPE] !== PARTIAL) return cb()
	
	  const Partial = __webpack_require__(1330)
	  if (!Partial.verify(object)) {
	    return cb(new errors.InvalidPartial())
	  }
	
	  const sig = object.sig
	  async.waterfall([
	    verify,
	    getInfo
	  ], cb)
	
	  function verify (done) {
	    if (!skipValidation) {
	      return Partial.extractSigPubKey(object, done)
	    }
	
	    let pubKey
	    try {
	      pubKey = utils.claimedSigPubKey(sig)
	    } catch (err) {
	      return done(err)
	    }
	
	    done(null, pubKey)
	  }
	
	  function getInfo (pubKey, done) {
	    if (!pubKey) {
	      return done(new errors.InvalidSignature({
	        sig: sig
	      }))
	    }
	
	    node.addressBook.byPubKey(pubKey, function (err, identityInfo) {
	      // original author is unknown
	      if (err) return done(err)
	
	      const author = identityInfo.permalink
	      if (!utils.findPubKey(identityInfo.object, pubKey)) {
	        return done(new errors.Author({
	          author: author,
	          sig: sig
	        }))
	      }
	
	      const stub = { [SIG]: sig}
	      const link = utils.hexLink(stub)
	      done(null, {
	        link: link,
	        author: author
	      })
	    })
	  }
	}
	
	// exports.identityIndices = function identityIndices (identityInfo) {
	//   typeforce(types.identityInfo, identityInfo)
	//   const keys = identityInfo.object.pubkeys
	//   return keys.map(key => key.pub)
	//     .concat(keys.map(key => key.fingerprint))
	//     .concat(identityInfo.link)
	// }
	
	exports.claimedSigPubKey = function (object) {
	  // const sig = object[TYPE] === PARTIAL
	  //   // get signature of original object
	  //   ? utils.find(object.properties, p => p === SIG).value
	  //   : object[SIG] || object
	
	  const sig = object[SIG] || object
	  return protocol.utils.parseSig(sig).pubKey
	}
	
	exports.extractSigPubKey = function (object, cb) {
	  const parsed = protocol.parseObject({ object })
	  const keyJSON = utils.extend({ type: 'ec' }, parsed.pubKey)
	  const key = utils.importKey(keyJSON)
	  if (cb) {
	    key.verify(parsed.merkleRoot, parsed.sig, function (err, verified) {
	      if (!err && !verified) {
	        err = new errors.InvalidSignature({ sig: parsed.sig })
	      }
	
	      cb(err, verified && parsed.pubKey)
	    })
	
	    return
	  }
	
	  if (key.verifySync(parsed.merkleRoot, parsed.sig)) {
	    return parsed.pubKey
	  }
	}
	
	exports.sign = function (data, key) {
	  key = utils.extend({ type: key.type || 'ec' }, key)
	  return utils.importKey(key).signSync(data)
	}
	
	// exports.verifyAuthor = function verifyAuthor (wrapper) {
	//   const signingKey = utils.getSigPubKey(wrapper.object)
	//   if (!signingKey) throw new Error('bad signature')
	
	//   // key encoding should really be recorded in each key in an identity
	//   signingKey.pub = utils.hex(signingKey.pub)
	//   const hasKey = wrapper.author.object.pubkeys.some(function (key) {
	//     for (let p in signingKey) {
	//       if (signingKey[p] !== key[p]) {
	//         return false
	//       }
	//     }
	
	//     return true
	//   })
	
	//   if (!hasKey) throw new Error('wrong author')
	// }
	
	// exports.execAsync = function (fn, cb) {
	//   try {
	//     var result = fn()
	//   } catch (err) {
	//     return cb(err)
	//   }
	
	//   cb(null, result)
	// }
	
	exports.saveToKeeper = function saveToKeeper (keeper, wrappers, cb) {
	  const batch = wrappers.map(w => {
	    return {
	      type: 'put',
	      key: w.link || w.object[LINK],
	      value: w.object
	    }
	  })
	
	  keeper.batch(batch, cb)
	}
	
	exports.mapToBatch = function (map, op) {
	  op = op || 'put'
	  return Object.keys(map).map(key => {
	    return {
	      type: op,
	      key: key,
	      value: map[key]
	    }
	  })
	}
	
	exports.values = function (obj) {
	  return Object.keys(obj).map(key => obj[key])
	}
	
	exports.now = function () {
	  // later, we might want some high-res timestamp
	  return Date.now()
	}
	
	exports.sealAddress = function sealAddress (basePubKey, link, networkName) {
	  const pubKey = protocol.sealPubKey({
	    link: utils.linkToBuf(link),
	    basePubKey: basePubKey
	  })
	
	  return utils.pubKeyToAddress(pubKey, networkName)
	}
	
	exports.sealPrevAddress = function sealPrevAddress (basePubKey, link, networkName) {
	  const pubKey = protocol.sealPrevPubKey({
	    prevLink: utils.linkToBuf(link),
	    basePubKey: basePubKey
	  })
	
	  return utils.pubKeyToAddress(pubKey, networkName)
	}
	
	exports.defaultValueEncoding = {
	  encode: val => JSON.stringify(hydra.dehydrate(val)),
	  decode: str => hydra.hydrate(JSON.parse(str))
	}
	
	exports.levelup = function (path, opts) {
	  opts = opts || {}
	  if (!opts.valueEncoding) {
	    opts.valueEncoding = utils.defaultValueEncoding
	  }
	
	  return levelup(path, opts)
	}
	
	// exports.alphabetical = function alphabetical (a, b) {
	//   return a < b ? -1 :
	//     a > b ? 1 : 0
	// }
	
	exports.parseTx = function parseTx (txInfo, networkName) {
	  // typeforce('String', txInfo.txHex)
	  if (!(networkName in bitcoin.networks)) {
	    throw new Error('invalid networkName')
	  }
	
	  var tx = txInfo.toHex ? txInfo : bitcoin.Transaction.fromHex(txInfo.txHex)
	  return extend(txInfo, {
	    from: utils.parseTxSender(tx, networkName),
	    to: {
	      addresses: utils.getOutputAddresses(tx, networkName)
	    },
	    confirmations: txInfo.confirmations || 0,
	    txId: txInfo.txId || tx.getId(),
	    txHex: txInfo.txHex || tx.toHex()
	  })
	}
	
	exports.parseTxSender = function parseTxSender (tx, networkName) {
	  const pubkeys = []
	  const addrs = []
	  tx.ins.map(function (input) {
	    const pubKeyBuf = input.script.chunks[1]
	    try {
	      const pub = bitcoin.ECPubKey.fromBuffer(pubKeyBuf)
	      const addr = pub.getAddress(bitcoin.networks[networkName]).toString()
	      pubkeys.push(pubKeyBuf)
	      addrs.push(addr)
	    } catch (err) {}
	  })
	
	  return {
	    pubkeys: pubkeys,
	    addresses: addrs
	  }
	}
	
	// utils.getTxAddresses = function getTxAddresses (tx, networkName) {
	//   return utils.getInputAddresses(tx, networkName)
	//     .concat(utils.getOutputAddresses(tx, networkName))
	// }
	
	exports.getOutputAddresses = function getOutputAddresses (tx, networkName) {
	  return tx.outs.map(function (output) {
	    return utils.getAddressFromOutput(output, networkName)
	  })
	  .filter(truthy)
	}
	
	exports.getAddressFromOutput = function getAddressFromOutput (output, networkName) {
	  if (bitcoin.scripts.classifyOutput(output.script) === 'pubkeyhash') {
	    return bitcoin.Address
	      .fromOutputScript(output.script, bitcoin.networks[networkName])
	      .toString()
	  }
	}
	
	/**
	 * monkey-patch `obj` to ensure async `methods` of `obj` never overlap
	 * @static
	 * @returns obj
	 */
	exports.lockify = function lockify (obj, methods) {
	  const lock = mutexify()
	  methods.forEach(method => {
	    const orig = obj[method]
	    obj[method] = function () {
	      const args = [].slice.call(arguments)
	      const cb = args[args.length - 1]
	      let release
	      args[args.length - 1] = function (err, val) {
	        release(cb, err, val)
	      }
	
	      lock(function (_release) {
	        release = _release
	        orig.apply(obj, args)
	      })
	    }
	  })
	
	  return obj
	}
	
	/**
	 * monkey-patch `obj` to log invocations of `method`
	 * @param {Object}  obj
	 * @param {string}  method
	 * @param {boolean} [logArgs=false]
	 * @returns obj
	 */
	exports.logify = function logify (obj, method, logArgs) {
	  const orig = obj[method]
	  obj[method] = function logifyProxy () {
	    const result = orig.apply(obj, arguments)
	    if (logArgs) console.log(method, 'args:', arguments)
	    console.log(method, 'result:', result)
	    return result
	  }
	}
	
	/**
	 * print the current stack
	 * @static
	 */
	exports.printStack = function () {
	  try {
	    throw new Error('')
	  } catch (err) {
	    console.error(err.stack)
	  }
	}
	
	/**
	 * get the descriptors for the default set of keys
	 * @static
	 * @param {string} [networkName=DEFAULT_NETWORK]
	 * @returns {Array}
	 */
	exports.defaultKeySet = function defaultKeySet (networkName) {
	  networkName = networkName || DEFAULT_NETWORK
	  return [
	    { type: 'bitcoin', purpose: 'payment', networkName: networkName },
	    { type: 'bitcoin', purpose: 'messaging', networkName: networkName },
	    { type: 'ec', purpose: 'sign', curve: 'p256' },
	    { type: 'ec', purpose: 'update', curve: 'p256' },
	    { type: 'ec', purpose: 'tls',  curve: 'curve25519' }
	    // { type: 'dsa', purpose: 'sign' }
	  ]
	}
	
	/**
	 * Generate a default set of keys
	 * @static
	 * @param {string} [networkName=DEFAULT_NETWORK]
	 * @returns {Array}
	 */
	exports.generateDefaultKeySet = function generateDefaultKeySet (networkName) {
	  const descriptors = utils.defaultKeySet(networkName)
	  return utils.generateKeySet(descriptors)
	}
	
	/**
	 * Generate a set of keys
	 * @static
	 * @param {Array} spec for keys to generate
	 * @returns {Array}
	 */
	exports.generateKeySet = function generateKeySet (keys) {
	  keys.forEach(key => typeforce({
	    type: typeforce.String,
	    purpose: typeforce.String
	  }, key))
	
	  return keys.map(k => {
	    if (k.type === 'bitcoin' && !k.networkName) {
	      k = utils.clone(k)
	      k.networkName = DEFAULT_NETWORK
	    }
	
	    return utils.genKey(k).set('purpose', k.purpose)
	  })
	}
	
	/**
	 * Generate a key
	 * @static
	 * @param {Object}   spec   spec for key
	 * @param {Function} [cb]
	 */
	exports.genKey = function (spec, cb) {
	  const impl = utils.getKeyImplementation(spec)
	  return cb ? impl.gen(spec, cb) : impl.genSync(spec)
	}
	
	/**
	 * Get a key implementation by key a spec
	 * @static
	 * @param  {Object} spec
	 * @return {nkeyModule}
	 */
	exports.getKeyImplementation = function (spec) {
	  const impl = nkeyImpls[spec.curve] || nkeyImpls[spec.type]
	  if (!impl) {
	    throw new Error('unsupported key type: ' + JSON.stringify(spec))
	  }
	
	  return impl
	}
	
	/**
	 * import a key json to an nkey object
	 * @static
	 * @param  {Object} key
	 * @return {nkey}
	 */
	exports.importKey = function (key) {
	  if (typeof key.toJSON === 'function') return key
	
	  return utils.getKeyImplementation(key).fromJSON(key)
	}
	
	/**
	 * Generate a new set of keys and corresponding identity object
	 * @static
	 * @param  {Object}   opts
	 * @param  {string}   [opts.networkName]
	 * @param  {Array}    [opts.keys]  spec for which keys to generate
	 * @param  {Function} cb
	 */
	exports.newIdentity = function newIdentity (opts, cb) {
	  typeforce({
	    networkName: typeforce.maybe(typeforce.String),
	    keys: typeforce.maybe(typeforce.Array)
	  }, opts)
	
	  let keys
	  if (opts.keys) {
	    keys = utils.generateKeySet(opts.keys)
	  } else {
	    keys = utils.generateDefaultKeySet(opts.networkName)
	  }
	
	  utils.newIdentityForKeys(keys, cb)
	}
	
	exports.newIdentityForKeys = function newIdentityForKeys (keys, cb) {
	  let identity = {
	    [TYPE]: IDENTITY,
	    pubkeys: keys.map(k => k.toJSON())
	  }
	
	  const sigPubKeyJSON = utils.find(identity.pubkeys, isIdentityVersioningKey)
	  const sigKey = utils.find(keys, k => k.pubKeyString === sigPubKeyJSON.pub)
	  protocol.sign({
	    author: {
	      sigPubKey: utils.toECKeyObj(sigPubKeyJSON),
	      sign: sigKey.sign.bind(sigKey)
	    },
	    object: identity
	  }, function (err, result) {
	    if (err) return cb(err)
	
	    identity = result.object // signed
	    cb(null, {
	      identity,
	      keys,
	      link: protocol.linkString(identity)
	    })
	  })
	}
	
	exports.signee = function signee (opts) {
	  typeforce({
	    permalink: typeforce.String,
	    link: typeforce.String
	  }, opts)
	
	  return opts.permalink + ':' + opts.link
	}
	
	exports.firstInStream = function firstInStream (stream, cb) {
	  cb = once(cb)
	  combine.obj(
	    stream,
	    head(1)
	  )
	  .on('data', data => cb(null, data))
	  .on('error', cb)
	  .on('end', () => cb(utils.notFoundErr()))
	}
	
	/**
	 * promisify a node and its components, based on manifest.js
	 * @static
	 * @param  {node} node
	 * @param  {Promise} [promiseImpl=global.Promise] promise implementation
	 * @return {node}
	 */
	exports.promisifyNode = function promisifyNode (node, promiseImpl) {
	  if (node._promisified) return node
	
	  const nodeManifest = manifest.node
	  Object.keys(nodeManifest)
	    .filter(method => nodeManifest[method].type === 'async')
	    .forEach(method => {
	      node[method] = utils.promisifyMethod(node, method, promiseImpl)
	    })
	
	  ;['objects', 'seals', 'watches', 'addressBook'].forEach(db => {
	    const dbManifest = manifest[db]
	    Object.keys(dbManifest)
	      .filter(method => dbManifest[method].type === 'async')
	      .forEach(method => {
	        node[db][method] = utils.promisifyMethod(node[db], method, promiseImpl)
	      })
	  })
	
	  node._promisified = true
	  return node
	}
	
	/**
	 * promisify a method based on manifest.js
	 * @static
	 * @param  {Object}   obj
	 * @param  {string}   method
	 * @param  {Promise}  [promiseImpl=global.Promise] promise implementation
	 * @return {node}
	 */
	exports.promisifyMethod = function (obj, method, promiseImpl) {
	  const orig = obj[method]
	  if (orig._promisified) return orig
	
	  if (!promiseImpl) promiseImpl = Promise
	  const promisified = function promisified () {
	    if (typeof arguments[arguments.length - 1] === 'function') {
	      return orig.apply(obj, arguments)
	    }
	
	    const args = Array.prototype.slice.call(arguments)
	    return new promiseImpl((resolve, reject) => {
	      args.push(function (err, val) {
	        if (err) return reject(err)
	        else resolve(val)
	      })
	
	      orig.apply(this, args)
	    })
	  }
	
	  promisified._promisified = true
	  return promisified
	}
	
	exports.timeout = function timeout (fn, millis, unref) {
	  const t = setTimeout(fn, millis)
	  if (unref && t.unref) t.unref()
	  return t
	}
	
	exports.getMessageCustomProps = function (msg) {
	  return utils.omit(msg, [
	    SEQ,
	    TYPE,
	    'recipientPubKey',
	    'object',
	    SIG,
	    PREV_TO_SENDER,
	    'seal'
	  ])
	}
	
	/**
	 * serialize a message object to a Buffer
	 * @static
	 * @param  {Object} msg
	 * @return {Buffer}
	 */
	exports.serializeMessage = function (msg) {
	  var copy = {}
	  var other = utils.getMessageCustomProps(msg)
	  for (var p in msg) {
	    var val = msg[p]
	    switch (p) {
	    case TYPE:
	      break
	    case 'recipientPubKey':
	      copy[p] = val
	      break
	    case 'object':
	      copy[p] = new Buffer(stringify(val))
	      break
	    case SEQ:
	      copy[p] = val
	      break
	    case SIG:
	      copy[p] = protocol.utils.parseSig(val)
	      break
	    case PREV_TO_SENDER:
	      copy[p] = new Buffer(val, 'hex')
	      break
	    case 'seal':
	      copy.seal = {
	        network: val.network === 'testnet' ? schema.Network.btctest : schema.Network.btcmain,
	        basePubKey: val.basePubKey,
	        link: new Buffer(val.link, 'hex')
	      }
	      break
	    }
	  }
	
	  if (Object.keys(other).length) {
	    copy.other = new Buffer(JSON.stringify(other))
	  }
	
	  return schema.Message.encode(copy)
	}
	
	/**
	 * unserialize a message Buffer to a message object
	 * @static
	 * @param  {Buffer} msg
	 * @return {Object}
	 */
	exports.unserializeMessage = function (msg) {
	  msg = schema.Message.decode(msg)
	  utils.cleanupDecodedProtobuf(msg)
	
	  for (var p in msg) {
	    var val = msg[p]
	    if (val == null) {
	      delete msg[p]
	      continue
	    }
	
	    switch (p) {
	    case 'other':
	      break
	    case 'object':
	      msg[p] = JSON.parse(val)
	      maybeParseEmbeddedMessage(msg[p])
	      break
	    case SIG:
	      msg[p] = protocol.utils.sigToString(protocol.utils.encodeSig(val))
	      break
	    case PREV_TO_SENDER:
	      msg[p] = val.toString('hex')
	      break
	    case 'seal':
	      val.network = val.network === schema.Network.btctest ? 'testnet' : 'bitcoin'
	      val.link = val.link.toString('hex')
	      break
	    }
	  }
	
	  msg[TYPE] = MESSAGE
	  if (msg.other) {
	    utils.extend(msg, JSON.parse(msg.other))
	    delete msg.other
	  }
	
	  return msg
	}
	
	var SERIALIZABLE_IDENTITY_PROPS = [
	  TYPE, SIG, PERMALINK, PREVLINK, 'pubkeys'
	]
	
	/**
	 * compact serialization of an identity object
	 * @static
	 * @param  {identity} identity
	 * @return {Buffer}
	 */
	exports.serializeIdentity = function (identity) {
	  for (var p in identity) {
	    if (SERIALIZABLE_IDENTITY_PROPS.indexOf(p) === -1) {
	      throw new Error('identity not serializable')
	    }
	  }
	
	  const formatted = {
	    [SIG]: new Buffer(identity[SIG], 'base64'),
	    pubkeys: identity.pubkeys.map(utils.toCompactPubKey)
	  }
	
	  if (identity[PERMALINK]) formatted[PERMALINK] = new Buffer(identity[PERMALINK], 'hex')
	  if (identity[PREVLINK]) formatted[PREVLINK] = new Buffer(identity[PREVLINK], 'hex')
	
	  return schema.Identity.encode(formatted)
	}
	
	/**
	 * unserialize a serialized identity
	 * @static
	 * @param  {Buffer} encoded
	 * @return {identity}
	 */
	exports.deserializeIdentity =
	exports.unserializeIdentity = function (encoded) {
	  const identity = schema.Identity.decode(encoded)
	  utils.cleanupDecodedProtobuf(identity)
	  identity[SIG] = identity[SIG].toString('base64')
	  identity[TYPE] = IDENTITY
	  if (identity[PERMALINK]) identity[PERMALINK] = identity[PERMALINK].toString('hex')
	  if (identity[PREVLINK]) identity[PREVLINK] = identity[PREVLINK].toString('hex')
	
	  identity.pubkeys = identity.pubkeys.map(utils.deserializePubKey)
	  return identity
	}
	
	exports.toCompactPubKey = function (key) {
	  const compact = {
	    purpose: schema.KeyPurpose[key.purpose],
	    type: schema.KeyType[key.type],
	    pub: new Buffer(key.pub, key.type === 'dsa' ? 'base64' : 'hex')
	  }
	
	  if ('curve' in key) {
	    compact.curve = key.curve && schema.ECurve[key.curve]
	  }
	
	  if ('networkName' in key) {
	    compact.network = key.networkName === 'bitcoin' ? schema.Network.btcmain : schema.Network.btctest
	  }
	
	  if ('fingerprint' in key) {
	    compact.fingerprint = key.type === 'bitcoin'
	      ? bs58check.decode(key.fingerprint)
	      : new Buffer(key.fingerprint, 'hex')
	  }
	
	  return compact
	}
	
	exports.serializePubKey = function (key) {
	  return schema.PubKey.encode(utils.toCompactPubKey(key))
	}
	
	exports.deserializePubKey =
	exports.unserializePubKey = function (serialized) {
	  const compact = Buffer.isBuffer(serialized) ? schema.PubKey.decode(serialized) : serialized
	  utils.cleanupDecodedProtobuf(compact)
	
	  const key = {
	    type: utils.keyByValue(schema.KeyType, compact.type),
	    purpose: utils.keyByValue(schema.KeyPurpose, compact.purpose),
	    pub: compact.type === schema.KeyType.dsa
	      ? compact.pub.toString('base64')
	      : compact.pub.toString('hex')
	  }
	
	  let networkName
	  switch (compact.network) {
	  case schema.Network.btcmain:
	    key.networkName = 'bitcoin'
	    break
	  case schema.Network.btctest:
	    key.networkName = 'testnet'
	    break
	  }
	
	  if (compact.curve === schema.ECurve.none) {
	    if (compact.type === 'ec') throw new Error('key is missing curve')
	
	    delete compact.curve
	  } else {
	    key.curve = utils.keyByValue(schema.ECurve, compact.curve)
	  }
	
	  if ('fingerprint' in compact) {
	    key.fingerprint = key.type === 'bitcoin'
	      ? bs58check.encode(compact.fingerprint)
	      : compact.fingerprint.toString('hex')
	  } else {
	    key.fingerprint = utils.importKey(key).fingerprint
	  }
	
	  return key
	}
	
	exports.cleanupDecodedProtobuf = function (decoded) {
	  for (var p in decoded) {
	    const val = decoded[p]
	    if (val == null || (Buffer.isBuffer(val) && val.length === 0)) {
	      delete decoded[p]
	    }
	  }
	
	  return decoded
	}
	
	exports.keyByValue = function (obj, val) {
	  for (var p in obj) {
	    if (obj[p] === val) return p
	  }
	}
	
	exports.getSealPubKey = function (seal) {
	  // check Network to get curve
	  return {
	    curve: 'secp256k1',
	    pub: seal.basePubKey
	  }
	}
	
	// function toBuffer (object) {
	//   if (Buffer.isBuffer(object)) return object
	//   if (typeof object === 'object') object = protocol.stringify(object)
	//   if (typeof object === 'string') object = new Buffer(object)
	
	//   return object
	// }
	
	function truthy (obj) {
	  return !!obj
	}
	
	// function rebuf (json) {
	//   if (Object.prototype.toString.call(json) !== '[object Object]') return json
	
	//   if (json &&
	//     json.type === 'Buffer' &&
	//     json.data &&
	//     !Buffer.isBuffer(json) &&
	//     Object.keys(json).length === 2) {
	//     return new Buffer(json.data)
	//   } else {
	//     for (var p in json) {
	//       json[p] = rebuf(json[p])
	//     }
	
	//     return json
	//   }
	// }
	
	function getKeyProp (key, prop) {
	  if (prop === 'type') return key.type
	  if (typeof key.get === 'function') return key.get(prop)
	
	  return key[prop]
	}
	
	function isSigningKey (key) {
	  if (key.type !== 'ec') return
	
	  key = key.toJSON ? key.toJSON() : key
	  return key.type === 'ec' && /^secp256k1|ed25519|p\d+$/.test(key.curve)
	}
	
	function isChainKey (key) {
	  return getKeyProp(key, 'type') === 'bitcoin'
	}
	
	function isPrivateKey (key) {
	  return !!key.priv || typeof key.sign === 'function' && key.isPrivateKey
	}
	
	function isIdentityVersioningKey (key) {
	  for (var p in constants.IDENTITY_VERSIONING_KEY) {
	    const val = getKeyProp(key, p)
	    if (val !== constants.IDENTITY_VERSIONING_KEY[p]) return false
	  }
	
	  return true
	  // const purpose = key.purpose || key.get('purpose')
	  // return purpose === 'update'
	}
	
	function loadNKeyImplementations () {
	  const impls = {}
	  try {
	    impls.ec = __webpack_require__(1331)
	  } catch (err) {}
	
	  try {
	    impls.curve25519 = __webpack_require__(1371)
	  } catch (err) {}
	
	  try {
	    impls.bitcoin = __webpack_require__(1374)
	  } catch (err) {}
	
	  return impls
	}
	
	function maybeParseEmbeddedMessage (obj) {
	  if (obj[TYPE] !== MESSAGE) return
	
	  obj.recipientPubKey.pub = new Buffer(obj.recipientPubKey.pub)
	  maybeParseEmbeddedMessage(obj.object)
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(820).Buffer))

/***/ },

/***/ 1239:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, module, setImmediate, process) {(function (global, factory) {
	     true ? factory(exports) :
	    typeof define === 'function' && define.amd ? define(['exports'], factory) :
	    (factory((global.async = global.async || {})));
	}(this, (function (exports) { 'use strict';
	
	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;
	
	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest$1(func, start, transform) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);
	
	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return apply(func, this, otherArgs);
	  };
	}
	
	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}
	
	// Lodash rest function without function.toString()
	// remappings
	function rest(func, start) {
	    return overRest$1(func, start, identity);
	}
	
	var initialParams = function (fn) {
	    return rest(function (args /*..., callback*/) {
	        var callback = args.pop();
	        fn.call(this, args, callback);
	    });
	};
	
	function applyEach$1(eachfn) {
	    return rest(function (fns, args) {
	        var go = initialParams(function (args, callback) {
	            var that = this;
	            return eachfn(fns, function (fn, cb) {
	                fn.apply(that, args.concat(cb));
	            }, callback);
	        });
	        if (args.length) {
	            return go.apply(this, args);
	        } else {
	            return go;
	        }
	    });
	}
	
	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
	
	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
	
	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();
	
	/** Built-in value references. */
	var Symbol$1 = root.Symbol;
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;
	
	/** Built-in value references. */
	var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;
	
	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag$1),
	      tag = value[symToStringTag$1];
	
	  try {
	    value[symToStringTag$1] = undefined;
	    var unmasked = true;
	  } catch (e) {}
	
	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag$1] = tag;
	    } else {
	      delete value[symToStringTag$1];
	    }
	  }
	  return result;
	}
	
	/** Used for built-in method references. */
	var objectProto$1 = Object.prototype;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString$1 = objectProto$1.toString;
	
	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString$1.call(value);
	}
	
	/** `Object#toString` result references. */
	var nullTag = '[object Null]';
	var undefinedTag = '[object Undefined]';
	
	/** Built-in value references. */
	var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;
	
	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}
	
	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}
	
	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]';
	var funcTag = '[object Function]';
	var genTag = '[object GeneratorFunction]';
	var proxyTag = '[object Proxy]';
	
	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}
	
	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;
	
	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}
	
	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}
	
	// A temporary value used to identify if the loop should be broken.
	// See #1064, #1293
	var breakLoop = {};
	
	/**
	 * This method returns `undefined`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.3.0
	 * @category Util
	 * @example
	 *
	 * _.times(2, _.noop);
	 * // => [undefined, undefined]
	 */
	function noop() {
	  // No operation performed.
	}
	
	function once(fn) {
	    return function () {
	        if (fn === null) return;
	        var callFn = fn;
	        fn = null;
	        callFn.apply(this, arguments);
	    };
	}
	
	var iteratorSymbol = typeof Symbol === 'function' && Symbol.iterator;
	
	var getIterator = function (coll) {
	    return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();
	};
	
	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);
	
	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}
	
	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}
	
	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';
	
	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike(value) && baseGetTag(value) == argsTag;
	}
	
	/** Used for built-in method references. */
	var objectProto$3 = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
	
	/** Built-in value references. */
	var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
	
	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike(value) && hasOwnProperty$2.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};
	
	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;
	
	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}
	
	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
	
	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
	
	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;
	
	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined;
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
	
	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse;
	
	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER$1 = 9007199254740991;
	
	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;
	
	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER$1 : length;
	  return !!length &&
	    (typeof value == 'number' || reIsUint.test(value)) &&
	    (value > -1 && value % 1 == 0 && value < length);
	}
	
	/** `Object#toString` result references. */
	var argsTag$1 = '[object Arguments]';
	var arrayTag = '[object Array]';
	var boolTag = '[object Boolean]';
	var dateTag = '[object Date]';
	var errorTag = '[object Error]';
	var funcTag$1 = '[object Function]';
	var mapTag = '[object Map]';
	var numberTag = '[object Number]';
	var objectTag = '[object Object]';
	var regexpTag = '[object RegExp]';
	var setTag = '[object Set]';
	var stringTag = '[object String]';
	var weakMapTag = '[object WeakMap]';
	
	var arrayBufferTag = '[object ArrayBuffer]';
	var dataViewTag = '[object DataView]';
	var float32Tag = '[object Float32Array]';
	var float64Tag = '[object Float64Array]';
	var int8Tag = '[object Int8Array]';
	var int16Tag = '[object Int16Array]';
	var int32Tag = '[object Int32Array]';
	var uint8Tag = '[object Uint8Array]';
	var uint8ClampedTag = '[object Uint8ClampedArray]';
	var uint16Tag = '[object Uint16Array]';
	var uint32Tag = '[object Uint32Array]';
	
	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag$1] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;
	
	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	}
	
	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}
	
	/** Detect free variable `exports`. */
	var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;
	
	/** Detect free variable `module`. */
	var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;
	
	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
	
	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports$1 && freeGlobal.process;
	
	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
	  } catch (e) {}
	}());
	
	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
	
	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
	
	/** Used for built-in method references. */
	var objectProto$2 = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
	
	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray(value),
	      isArg = !isArr && isArguments(value),
	      isBuff = !isArr && !isArg && isBuffer(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;
	
	  for (var key in value) {
	    if ((inherited || hasOwnProperty$1.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	/** Used for built-in method references. */
	var objectProto$5 = Object.prototype;
	
	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$5;
	
	  return value === proto;
	}
	
	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = overArg(Object.keys, Object);
	
	/** Used for built-in method references. */
	var objectProto$4 = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
	
	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty$3.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}
	
	function createArrayIterator(coll) {
	    var i = -1;
	    var len = coll.length;
	    return function next() {
	        return ++i < len ? { value: coll[i], key: i } : null;
	    };
	}
	
	function createES2015Iterator(iterator) {
	    var i = -1;
	    return function next() {
	        var item = iterator.next();
	        if (item.done) return null;
	        i++;
	        return { value: item.value, key: i };
	    };
	}
	
	function createObjectIterator(obj) {
	    var okeys = keys(obj);
	    var i = -1;
	    var len = okeys.length;
	    return function next() {
	        var key = okeys[++i];
	        return i < len ? { value: obj[key], key: key } : null;
	    };
	}
	
	function iterator(coll) {
	    if (isArrayLike(coll)) {
	        return createArrayIterator(coll);
	    }
	
	    var iterator = getIterator(coll);
	    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
	}
	
	function onlyOnce(fn) {
	    return function () {
	        if (fn === null) throw new Error("Callback was already called.");
	        var callFn = fn;
	        fn = null;
	        callFn.apply(this, arguments);
	    };
	}
	
	function _eachOfLimit(limit) {
	    return function (obj, iteratee, callback) {
	        callback = once(callback || noop);
	        if (limit <= 0 || !obj) {
	            return callback(null);
	        }
	        var nextElem = iterator(obj);
	        var done = false;
	        var running = 0;
	
	        function iterateeCallback(err, value) {
	            running -= 1;
	            if (err) {
	                done = true;
	                callback(err);
	            } else if (value === breakLoop || done && running <= 0) {
	                done = true;
	                return callback(null);
	            } else {
	                replenish();
	            }
	        }
	
	        function replenish() {
	            while (running < limit && !done) {
	                var elem = nextElem();
	                if (elem === null) {
	                    done = true;
	                    if (running <= 0) {
	                        callback(null);
	                    }
	                    return;
	                }
	                running += 1;
	                iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
	            }
	        }
	
	        replenish();
	    };
	}
	
	/**
	 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a
	 * time.
	 *
	 * @name eachOfLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.eachOf]{@link module:Collections.eachOf}
	 * @alias forEachOfLimit
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {Function} iteratee - A function to apply to each
	 * item in `coll`. The `key` is the item's key, or index in the case of an
	 * array. The iteratee is passed a `callback(err)` which must be called once it
	 * has completed. If no error has occurred, the callback should be run without
	 * arguments or with an explicit `null` argument. Invoked with
	 * (item, key, callback).
	 * @param {Function} [callback] - A callback which is called when all
	 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
	 */
	function eachOfLimit(coll, limit, iteratee, callback) {
	  _eachOfLimit(limit)(coll, iteratee, callback);
	}
	
	function doLimit(fn, limit) {
	    return function (iterable, iteratee, callback) {
	        return fn(iterable, limit, iteratee, callback);
	    };
	}
	
	// eachOf implementation optimized for array-likes
	function eachOfArrayLike(coll, iteratee, callback) {
	    callback = once(callback || noop);
	    var index = 0,
	        completed = 0,
	        length = coll.length;
	    if (length === 0) {
	        callback(null);
	    }
	
	    function iteratorCallback(err, value) {
	        if (err) {
	            callback(err);
	        } else if (++completed === length || value === breakLoop) {
	            callback(null);
	        }
	    }
	
	    for (; index < length; index++) {
	        iteratee(coll[index], index, onlyOnce(iteratorCallback));
	    }
	}
	
	// a generic version of eachOf which can handle array, object, and iterator cases.
	var eachOfGeneric = doLimit(eachOfLimit, Infinity);
	
	/**
	 * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument
	 * to the iteratee.
	 *
	 * @name eachOf
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @alias forEachOf
	 * @category Collection
	 * @see [async.each]{@link module:Collections.each}
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each
	 * item in `coll`. The `key` is the item's key, or index in the case of an
	 * array. The iteratee is passed a `callback(err)` which must be called once it
	 * has completed. If no error has occurred, the callback should be run without
	 * arguments or with an explicit `null` argument. Invoked with
	 * (item, key, callback).
	 * @param {Function} [callback] - A callback which is called when all
	 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
	 * @example
	 *
	 * var obj = {dev: "/dev.json", test: "/test.json", prod: "/prod.json"};
	 * var configs = {};
	 *
	 * async.forEachOf(obj, function (value, key, callback) {
	 *     fs.readFile(__dirname + value, "utf8", function (err, data) {
	 *         if (err) return callback(err);
	 *         try {
	 *             configs[key] = JSON.parse(data);
	 *         } catch (e) {
	 *             return callback(e);
	 *         }
	 *         callback();
	 *     });
	 * }, function (err) {
	 *     if (err) console.error(err.message);
	 *     // configs is now a map of JSON data
	 *     doSomethingWith(configs);
	 * });
	 */
	var eachOf = function (coll, iteratee, callback) {
	    var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
	    eachOfImplementation(coll, iteratee, callback);
	};
	
	function doParallel(fn) {
	    return function (obj, iteratee, callback) {
	        return fn(eachOf, obj, iteratee, callback);
	    };
	}
	
	function _asyncMap(eachfn, arr, iteratee, callback) {
	    callback = callback || noop;
	    arr = arr || [];
	    var results = [];
	    var counter = 0;
	
	    eachfn(arr, function (value, _, callback) {
	        var index = counter++;
	        iteratee(value, function (err, v) {
	            results[index] = v;
	            callback(err);
	        });
	    }, function (err) {
	        callback(err, results);
	    });
	}
	
	/**
	 * Produces a new collection of values by mapping each value in `coll` through
	 * the `iteratee` function. The `iteratee` is called with an item from `coll`
	 * and a callback for when it has finished processing. Each of these callback
	 * takes 2 arguments: an `error`, and the transformed item from `coll`. If
	 * `iteratee` passes an error to its callback, the main `callback` (for the
	 * `map` function) is immediately called with the error.
	 *
	 * Note, that since this function applies the `iteratee` to each item in
	 * parallel, there is no guarantee that the `iteratee` functions will complete
	 * in order. However, the results array will be in the same order as the
	 * original `coll`.
	 *
	 * If `map` is passed an Object, the results will be an Array.  The results
	 * will roughly be in the order of the original Objects' keys (but this can
	 * vary across JavaScript engines)
	 *
	 * @name map
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each item in `coll`.
	 * The iteratee is passed a `callback(err, transformed)` which must be called
	 * once it has completed with an error (which can be `null`) and a
	 * transformed item. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called when all `iteratee`
	 * functions have finished, or an error occurs. Results is an Array of the
	 * transformed items from the `coll`. Invoked with (err, results).
	 * @example
	 *
	 * async.map(['file1','file2','file3'], fs.stat, function(err, results) {
	 *     // results is now an array of stats for each file
	 * });
	 */
	var map = doParallel(_asyncMap);
	
	/**
	 * Applies the provided arguments to each function in the array, calling
	 * `callback` after all functions have completed. If you only provide the first
	 * argument, `fns`, then it will return a function which lets you pass in the
	 * arguments as if it were a single function call. If more arguments are
	 * provided, `callback` is required while `args` is still optional.
	 *
	 * @name applyEach
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {Array|Iterable|Object} fns - A collection of asynchronous functions
	 * to all call with the same arguments
	 * @param {...*} [args] - any number of separate arguments to pass to the
	 * function.
	 * @param {Function} [callback] - the final argument should be the callback,
	 * called when all functions have completed processing.
	 * @returns {Function} - If only the first argument, `fns`, is provided, it will
	 * return a function which lets you pass in the arguments as if it were a single
	 * function call. The signature is `(..args, callback)`. If invoked with any
	 * arguments, `callback` is required.
	 * @example
	 *
	 * async.applyEach([enableSearch, updateSchema], 'bucket', callback);
	 *
	 * // partial application example:
	 * async.each(
	 *     buckets,
	 *     async.applyEach([enableSearch, updateSchema]),
	 *     callback
	 * );
	 */
	var applyEach = applyEach$1(map);
	
	function doParallelLimit(fn) {
	    return function (obj, limit, iteratee, callback) {
	        return fn(_eachOfLimit(limit), obj, iteratee, callback);
	    };
	}
	
	/**
	 * The same as [`map`]{@link module:Collections.map} but runs a maximum of `limit` async operations at a time.
	 *
	 * @name mapLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.map]{@link module:Collections.map}
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {Function} iteratee - A function to apply to each item in `coll`.
	 * The iteratee is passed a `callback(err, transformed)` which must be called
	 * once it has completed with an error (which can be `null`) and a transformed
	 * item. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called when all `iteratee`
	 * functions have finished, or an error occurs. Results is an array of the
	 * transformed items from the `coll`. Invoked with (err, results).
	 */
	var mapLimit = doParallelLimit(_asyncMap);
	
	/**
	 * The same as [`map`]{@link module:Collections.map} but runs only a single async operation at a time.
	 *
	 * @name mapSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.map]{@link module:Collections.map}
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each item in `coll`.
	 * The iteratee is passed a `callback(err, transformed)` which must be called
	 * once it has completed with an error (which can be `null`) and a
	 * transformed item. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called when all `iteratee`
	 * functions have finished, or an error occurs. Results is an array of the
	 * transformed items from the `coll`. Invoked with (err, results).
	 */
	var mapSeries = doLimit(mapLimit, 1);
	
	/**
	 * The same as [`applyEach`]{@link module:ControlFlow.applyEach} but runs only a single async operation at a time.
	 *
	 * @name applyEachSeries
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.applyEach]{@link module:ControlFlow.applyEach}
	 * @category Control Flow
	 * @param {Array|Iterable|Object} fns - A collection of asynchronous functions to all
	 * call with the same arguments
	 * @param {...*} [args] - any number of separate arguments to pass to the
	 * function.
	 * @param {Function} [callback] - the final argument should be the callback,
	 * called when all functions have completed processing.
	 * @returns {Function} - If only the first argument is provided, it will return
	 * a function which lets you pass in the arguments as if it were a single
	 * function call.
	 */
	var applyEachSeries = applyEach$1(mapSeries);
	
	/**
	 * Creates a continuation function with some arguments already applied.
	 *
	 * Useful as a shorthand when combined with other control flow functions. Any
	 * arguments passed to the returned function are added to the arguments
	 * originally passed to apply.
	 *
	 * @name apply
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @category Util
	 * @param {Function} function - The function you want to eventually apply all
	 * arguments to. Invokes with (arguments...).
	 * @param {...*} arguments... - Any number of arguments to automatically apply
	 * when the continuation is called.
	 * @example
	 *
	 * // using apply
	 * async.parallel([
	 *     async.apply(fs.writeFile, 'testfile1', 'test1'),
	 *     async.apply(fs.writeFile, 'testfile2', 'test2')
	 * ]);
	 *
	 *
	 * // the same process without using apply
	 * async.parallel([
	 *     function(callback) {
	 *         fs.writeFile('testfile1', 'test1', callback);
	 *     },
	 *     function(callback) {
	 *         fs.writeFile('testfile2', 'test2', callback);
	 *     }
	 * ]);
	 *
	 * // It's possible to pass any number of additional arguments when calling the
	 * // continuation:
	 *
	 * node> var fn = async.apply(sys.puts, 'one');
	 * node> fn('two', 'three');
	 * one
	 * two
	 * three
	 */
	var apply$2 = rest(function (fn, args) {
	    return rest(function (callArgs) {
	        return fn.apply(null, args.concat(callArgs));
	    });
	});
	
	/**
	 * Take a sync function and make it async, passing its return value to a
	 * callback. This is useful for plugging sync functions into a waterfall,
	 * series, or other async functions. Any arguments passed to the generated
	 * function will be passed to the wrapped function (except for the final
	 * callback argument). Errors thrown will be passed to the callback.
	 *
	 * If the function passed to `asyncify` returns a Promise, that promises's
	 * resolved/rejected state will be used to call the callback, rather than simply
	 * the synchronous return value.
	 *
	 * This also means you can asyncify ES2016 `async` functions.
	 *
	 * @name asyncify
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @alias wrapSync
	 * @category Util
	 * @param {Function} func - The synchronous function to convert to an
	 * asynchronous function.
	 * @returns {Function} An asynchronous wrapper of the `func`. To be invoked with
	 * (callback).
	 * @example
	 *
	 * // passing a regular synchronous function
	 * async.waterfall([
	 *     async.apply(fs.readFile, filename, "utf8"),
	 *     async.asyncify(JSON.parse),
	 *     function (data, next) {
	 *         // data is the result of parsing the text.
	 *         // If there was a parsing error, it would have been caught.
	 *     }
	 * ], callback);
	 *
	 * // passing a function returning a promise
	 * async.waterfall([
	 *     async.apply(fs.readFile, filename, "utf8"),
	 *     async.asyncify(function (contents) {
	 *         return db.model.create(contents);
	 *     }),
	 *     function (model, next) {
	 *         // `model` is the instantiated model object.
	 *         // If there was an error, this function would be skipped.
	 *     }
	 * ], callback);
	 *
	 * // es6 example
	 * var q = async.queue(async.asyncify(async function(file) {
	 *     var intermediateStep = await processFile(file);
	 *     return await somePromise(intermediateStep)
	 * }));
	 *
	 * q.push(files);
	 */
	function asyncify(func) {
	    return initialParams(function (args, callback) {
	        var result;
	        try {
	            result = func.apply(this, args);
	        } catch (e) {
	            return callback(e);
	        }
	        // if result is Promise object
	        if (isObject(result) && typeof result.then === 'function') {
	            result.then(function (value) {
	                callback(null, value);
	            }, function (err) {
	                callback(err.message ? err : new Error(err));
	            });
	        } else {
	            callback(null, result);
	        }
	    });
	}
	
	/**
	 * A specialized version of `_.forEach` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns `array`.
	 */
	function arrayEach(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length;
	
	  while (++index < length) {
	    if (iteratee(array[index], index, array) === false) {
	      break;
	    }
	  }
	  return array;
	}
	
	/**
	 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseFor(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var index = -1,
	        iterable = Object(object),
	        props = keysFunc(object),
	        length = props.length;
	
	    while (length--) {
	      var key = props[fromRight ? length : ++index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}
	
	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor = createBaseFor();
	
	/**
	 * The base implementation of `_.forOwn` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 */
	function baseForOwn(object, iteratee) {
	  return object && baseFor(object, iteratee, keys);
	}
	
	/**
	 * The base implementation of `_.findIndex` and `_.findLastIndex` without
	 * support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} predicate The function invoked per iteration.
	 * @param {number} fromIndex The index to search from.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseFindIndex(array, predicate, fromIndex, fromRight) {
	  var length = array.length,
	      index = fromIndex + (fromRight ? 1 : -1);
	
	  while ((fromRight ? index-- : ++index < length)) {
	    if (predicate(array[index], index, array)) {
	      return index;
	    }
	  }
	  return -1;
	}
	
	/**
	 * The base implementation of `_.isNaN` without support for number objects.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	 */
	function baseIsNaN(value) {
	  return value !== value;
	}
	
	/**
	 * A specialized version of `_.indexOf` which performs strict equality
	 * comparisons of values, i.e. `===`.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function strictIndexOf(array, value, fromIndex) {
	  var index = fromIndex - 1,
	      length = array.length;
	
	  while (++index < length) {
	    if (array[index] === value) {
	      return index;
	    }
	  }
	  return -1;
	}
	
	/**
	 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseIndexOf(array, value, fromIndex) {
	  return value === value
	    ? strictIndexOf(array, value, fromIndex)
	    : baseFindIndex(array, baseIsNaN, fromIndex);
	}
	
	/**
	 * Determines the best order for running the functions in `tasks`, based on
	 * their requirements. Each function can optionally depend on other functions
	 * being completed first, and each function is run as soon as its requirements
	 * are satisfied.
	 *
	 * If any of the functions pass an error to their callback, the `auto` sequence
	 * will stop. Further tasks will not execute (so any other functions depending
	 * on it will not run), and the main `callback` is immediately called with the
	 * error.
	 *
	 * Functions also receive an object containing the results of functions which
	 * have completed so far as the first argument, if they have dependencies. If a
	 * task function has no dependencies, it will only be passed a callback.
	 *
	 * @name auto
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {Object} tasks - An object. Each of its properties is either a
	 * function or an array of requirements, with the function itself the last item
	 * in the array. The object's key of a property serves as the name of the task
	 * defined by that property, i.e. can be used when specifying requirements for
	 * other tasks. The function receives one or two arguments:
	 * * a `results` object, containing the results of the previously executed
	 *   functions, only passed if the task has any dependencies,
	 * * a `callback(err, result)` function, which must be called when finished,
	 *   passing an `error` (which can be `null`) and the result of the function's
	 *   execution.
	 * @param {number} [concurrency=Infinity] - An optional `integer` for
	 * determining the maximum number of tasks that can be run in parallel. By
	 * default, as many as possible.
	 * @param {Function} [callback] - An optional callback which is called when all
	 * the tasks have been completed. It receives the `err` argument if any `tasks`
	 * pass an error to their callback. Results are always returned; however, if an
	 * error occurs, no further `tasks` will be performed, and the results object
	 * will only contain partial results. Invoked with (err, results).
	 * @returns undefined
	 * @example
	 *
	 * async.auto({
	 *     // this function will just be passed a callback
	 *     readData: async.apply(fs.readFile, 'data.txt', 'utf-8'),
	 *     showData: ['readData', function(results, cb) {
	 *         // results.readData is the file's contents
	 *         // ...
	 *     }]
	 * }, callback);
	 *
	 * async.auto({
	 *     get_data: function(callback) {
	 *         console.log('in get_data');
	 *         // async code to get some data
	 *         callback(null, 'data', 'converted to array');
	 *     },
	 *     make_folder: function(callback) {
	 *         console.log('in make_folder');
	 *         // async code to create a directory to store a file in
	 *         // this is run at the same time as getting the data
	 *         callback(null, 'folder');
	 *     },
	 *     write_file: ['get_data', 'make_folder', function(results, callback) {
	 *         console.log('in write_file', JSON.stringify(results));
	 *         // once there is some data and the directory exists,
	 *         // write the data to a file in the directory
	 *         callback(null, 'filename');
	 *     }],
	 *     email_link: ['write_file', function(results, callback) {
	 *         console.log('in email_link', JSON.stringify(results));
	 *         // once the file is written let's email a link to it...
	 *         // results.write_file contains the filename returned by write_file.
	 *         callback(null, {'file':results.write_file, 'email':'user@example.com'});
	 *     }]
	 * }, function(err, results) {
	 *     console.log('err = ', err);
	 *     console.log('results = ', results);
	 * });
	 */
	var auto = function (tasks, concurrency, callback) {
	    if (typeof concurrency === 'function') {
	        // concurrency is optional, shift the args.
	        callback = concurrency;
	        concurrency = null;
	    }
	    callback = once(callback || noop);
	    var keys$$1 = keys(tasks);
	    var numTasks = keys$$1.length;
	    if (!numTasks) {
	        return callback(null);
	    }
	    if (!concurrency) {
	        concurrency = numTasks;
	    }
	
	    var results = {};
	    var runningTasks = 0;
	    var hasError = false;
	
	    var listeners = Object.create(null);
	
	    var readyTasks = [];
	
	    // for cycle detection:
	    var readyToCheck = []; // tasks that have been identified as reachable
	    // without the possibility of returning to an ancestor task
	    var uncheckedDependencies = {};
	
	    baseForOwn(tasks, function (task, key) {
	        if (!isArray(task)) {
	            // no dependencies
	            enqueueTask(key, [task]);
	            readyToCheck.push(key);
	            return;
	        }
	
	        var dependencies = task.slice(0, task.length - 1);
	        var remainingDependencies = dependencies.length;
	        if (remainingDependencies === 0) {
	            enqueueTask(key, task);
	            readyToCheck.push(key);
	            return;
	        }
	        uncheckedDependencies[key] = remainingDependencies;
	
	        arrayEach(dependencies, function (dependencyName) {
	            if (!tasks[dependencyName]) {
	                throw new Error('async.auto task `' + key + '` has a non-existent dependency `' + dependencyName + '` in ' + dependencies.join(', '));
	            }
	            addListener(dependencyName, function () {
	                remainingDependencies--;
	                if (remainingDependencies === 0) {
	                    enqueueTask(key, task);
	                }
	            });
	        });
	    });
	
	    checkForDeadlocks();
	    processQueue();
	
	    function enqueueTask(key, task) {
	        readyTasks.push(function () {
	            runTask(key, task);
	        });
	    }
	
	    function processQueue() {
	        if (readyTasks.length === 0 && runningTasks === 0) {
	            return callback(null, results);
	        }
	        while (readyTasks.length && runningTasks < concurrency) {
	            var run = readyTasks.shift();
	            run();
	        }
	    }
	
	    function addListener(taskName, fn) {
	        var taskListeners = listeners[taskName];
	        if (!taskListeners) {
	            taskListeners = listeners[taskName] = [];
	        }
	
	        taskListeners.push(fn);
	    }
	
	    function taskComplete(taskName) {
	        var taskListeners = listeners[taskName] || [];
	        arrayEach(taskListeners, function (fn) {
	            fn();
	        });
	        processQueue();
	    }
	
	    function runTask(key, task) {
	        if (hasError) return;
	
	        var taskCallback = onlyOnce(rest(function (err, args) {
	            runningTasks--;
	            if (args.length <= 1) {
	                args = args[0];
	            }
	            if (err) {
	                var safeResults = {};
	                baseForOwn(results, function (val, rkey) {
	                    safeResults[rkey] = val;
	                });
	                safeResults[key] = args;
	                hasError = true;
	                listeners = Object.create(null);
	
	                callback(err, safeResults);
	            } else {
	                results[key] = args;
	                taskComplete(key);
	            }
	        }));
	
	        runningTasks++;
	        var taskFn = task[task.length - 1];
	        if (task.length > 1) {
	            taskFn(results, taskCallback);
	        } else {
	            taskFn(taskCallback);
	        }
	    }
	
	    function checkForDeadlocks() {
	        // Kahn's algorithm
	        // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm
	        // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html
	        var currentTask;
	        var counter = 0;
	        while (readyToCheck.length) {
	            currentTask = readyToCheck.pop();
	            counter++;
	            arrayEach(getDependents(currentTask), function (dependent) {
	                if (--uncheckedDependencies[dependent] === 0) {
	                    readyToCheck.push(dependent);
	                }
	            });
	        }
	
	        if (counter !== numTasks) {
	            throw new Error('async.auto cannot execute tasks due to a recursive dependency');
	        }
	    }
	
	    function getDependents(taskName) {
	        var result = [];
	        baseForOwn(tasks, function (task, key) {
	            if (isArray(task) && baseIndexOf(task, taskName, 0) >= 0) {
	                result.push(key);
	            }
	        });
	        return result;
	    }
	};
	
	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      result = Array(length);
	
	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}
	
	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';
	
	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && baseGetTag(value) == symbolTag);
	}
	
	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;
	
	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined;
	var symbolToString = symbolProto ? symbolProto.toString : undefined;
	
	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isArray(value)) {
	    // Recursively convert values (susceptible to call stack limits).
	    return arrayMap(value, baseToString) + '';
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}
	
	/**
	 * The base implementation of `_.slice` without an iteratee call guard.
	 *
	 * @private
	 * @param {Array} array The array to slice.
	 * @param {number} [start=0] The start position.
	 * @param {number} [end=array.length] The end position.
	 * @returns {Array} Returns the slice of `array`.
	 */
	function baseSlice(array, start, end) {
	  var index = -1,
	      length = array.length;
	
	  if (start < 0) {
	    start = -start > length ? 0 : (length + start);
	  }
	  end = end > length ? length : end;
	  if (end < 0) {
	    end += length;
	  }
	  length = start > end ? 0 : ((end - start) >>> 0);
	  start >>>= 0;
	
	  var result = Array(length);
	  while (++index < length) {
	    result[index] = array[index + start];
	  }
	  return result;
	}
	
	/**
	 * Casts `array` to a slice if it's needed.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {number} start The start position.
	 * @param {number} [end=array.length] The end position.
	 * @returns {Array} Returns the cast slice.
	 */
	function castSlice(array, start, end) {
	  var length = array.length;
	  end = end === undefined ? length : end;
	  return (!start && end >= length) ? array : baseSlice(array, start, end);
	}
	
	/**
	 * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
	 * that is not found in the character symbols.
	 *
	 * @private
	 * @param {Array} strSymbols The string symbols to inspect.
	 * @param {Array} chrSymbols The character symbols to find.
	 * @returns {number} Returns the index of the last unmatched string symbol.
	 */
	function charsEndIndex(strSymbols, chrSymbols) {
	  var index = strSymbols.length;
	
	  while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
	  return index;
	}
	
	/**
	 * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
	 * that is not found in the character symbols.
	 *
	 * @private
	 * @param {Array} strSymbols The string symbols to inspect.
	 * @param {Array} chrSymbols The character symbols to find.
	 * @returns {number} Returns the index of the first unmatched string symbol.
	 */
	function charsStartIndex(strSymbols, chrSymbols) {
	  var index = -1,
	      length = strSymbols.length;
	
	  while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
	  return index;
	}
	
	/**
	 * Converts an ASCII `string` to an array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the converted array.
	 */
	function asciiToArray(string) {
	  return string.split('');
	}
	
	/** Used to compose unicode character classes. */
	var rsAstralRange = '\\ud800-\\udfff';
	var rsComboMarksRange = '\\u0300-\\u036f';
	var reComboHalfMarksRange = '\\ufe20-\\ufe2f';
	var rsComboSymbolsRange = '\\u20d0-\\u20ff';
	var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
	var rsVarRange = '\\ufe0e\\ufe0f';
	
	/** Used to compose unicode capture groups. */
	var rsZWJ = '\\u200d';
	
	/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
	var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');
	
	/**
	 * Checks if `string` contains Unicode symbols.
	 *
	 * @private
	 * @param {string} string The string to inspect.
	 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
	 */
	function hasUnicode(string) {
	  return reHasUnicode.test(string);
	}
	
	/** Used to compose unicode character classes. */
	var rsAstralRange$1 = '\\ud800-\\udfff';
	var rsComboMarksRange$1 = '\\u0300-\\u036f';
	var reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f';
	var rsComboSymbolsRange$1 = '\\u20d0-\\u20ff';
	var rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
	var rsVarRange$1 = '\\ufe0e\\ufe0f';
	
	/** Used to compose unicode capture groups. */
	var rsAstral = '[' + rsAstralRange$1 + ']';
	var rsCombo = '[' + rsComboRange$1 + ']';
	var rsFitz = '\\ud83c[\\udffb-\\udfff]';
	var rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')';
	var rsNonAstral = '[^' + rsAstralRange$1 + ']';
	var rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}';
	var rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]';
	var rsZWJ$1 = '\\u200d';
	
	/** Used to compose unicode regexes. */
	var reOptMod = rsModifier + '?';
	var rsOptVar = '[' + rsVarRange$1 + ']?';
	var rsOptJoin = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*';
	var rsSeq = rsOptVar + reOptMod + rsOptJoin;
	var rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
	
	/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
	var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
	
	/**
	 * Converts a Unicode `string` to an array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the converted array.
	 */
	function unicodeToArray(string) {
	  return string.match(reUnicode) || [];
	}
	
	/**
	 * Converts `string` to an array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the converted array.
	 */
	function stringToArray(string) {
	  return hasUnicode(string)
	    ? unicodeToArray(string)
	    : asciiToArray(string);
	}
	
	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : baseToString(value);
	}
	
	/** Used to match leading and trailing whitespace. */
	var reTrim = /^\s+|\s+$/g;
	
	/**
	 * Removes leading and trailing whitespace or specified characters from `string`.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to trim.
	 * @param {string} [chars=whitespace] The characters to trim.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {string} Returns the trimmed string.
	 * @example
	 *
	 * _.trim('  abc  ');
	 * // => 'abc'
	 *
	 * _.trim('-_-abc-_-', '_-');
	 * // => 'abc'
	 *
	 * _.map(['  foo  ', '  bar  '], _.trim);
	 * // => ['foo', 'bar']
	 */
	function trim(string, chars, guard) {
	  string = toString(string);
	  if (string && (guard || chars === undefined)) {
	    return string.replace(reTrim, '');
	  }
	  if (!string || !(chars = baseToString(chars))) {
	    return string;
	  }
	  var strSymbols = stringToArray(string),
	      chrSymbols = stringToArray(chars),
	      start = charsStartIndex(strSymbols, chrSymbols),
	      end = charsEndIndex(strSymbols, chrSymbols) + 1;
	
	  return castSlice(strSymbols, start, end).join('');
	}
	
	var FN_ARGS = /^(function)?\s*[^\(]*\(\s*([^\)]*)\)/m;
	var FN_ARG_SPLIT = /,/;
	var FN_ARG = /(=.+)?(\s*)$/;
	var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
	
	function parseParams(func) {
	    func = func.toString().replace(STRIP_COMMENTS, '');
	    func = func.match(FN_ARGS)[2].replace(' ', '');
	    func = func ? func.split(FN_ARG_SPLIT) : [];
	    func = func.map(function (arg) {
	        return trim(arg.replace(FN_ARG, ''));
	    });
	    return func;
	}
	
	/**
	 * A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent
	 * tasks are specified as parameters to the function, after the usual callback
	 * parameter, with the parameter names matching the names of the tasks it
	 * depends on. This can provide even more readable task graphs which can be
	 * easier to maintain.
	 *
	 * If a final callback is specified, the task results are similarly injected,
	 * specified as named parameters after the initial error parameter.
	 *
	 * The autoInject function is purely syntactic sugar and its semantics are
	 * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.
	 *
	 * @name autoInject
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.auto]{@link module:ControlFlow.auto}
	 * @category Control Flow
	 * @param {Object} tasks - An object, each of whose properties is a function of
	 * the form 'func([dependencies...], callback). The object's key of a property
	 * serves as the name of the task defined by that property, i.e. can be used
	 * when specifying requirements for other tasks.
	 * * The `callback` parameter is a `callback(err, result)` which must be called
	 *   when finished, passing an `error` (which can be `null`) and the result of
	 *   the function's execution. The remaining parameters name other tasks on
	 *   which the task is dependent, and the results from those tasks are the
	 *   arguments of those parameters.
	 * @param {Function} [callback] - An optional callback which is called when all
	 * the tasks have been completed. It receives the `err` argument if any `tasks`
	 * pass an error to their callback, and a `results` object with any completed
	 * task results, similar to `auto`.
	 * @example
	 *
	 * //  The example from `auto` can be rewritten as follows:
	 * async.autoInject({
	 *     get_data: function(callback) {
	 *         // async code to get some data
	 *         callback(null, 'data', 'converted to array');
	 *     },
	 *     make_folder: function(callback) {
	 *         // async code to create a directory to store a file in
	 *         // this is run at the same time as getting the data
	 *         callback(null, 'folder');
	 *     },
	 *     write_file: function(get_data, make_folder, callback) {
	 *         // once there is some data and the directory exists,
	 *         // write the data to a file in the directory
	 *         callback(null, 'filename');
	 *     },
	 *     email_link: function(write_file, callback) {
	 *         // once the file is written let's email a link to it...
	 *         // write_file contains the filename returned by write_file.
	 *         callback(null, {'file':write_file, 'email':'user@example.com'});
	 *     }
	 * }, function(err, results) {
	 *     console.log('err = ', err);
	 *     console.log('email_link = ', results.email_link);
	 * });
	 *
	 * // If you are using a JS minifier that mangles parameter names, `autoInject`
	 * // will not work with plain functions, since the parameter names will be
	 * // collapsed to a single letter identifier.  To work around this, you can
	 * // explicitly specify the names of the parameters your task function needs
	 * // in an array, similar to Angular.js dependency injection.
	 *
	 * // This still has an advantage over plain `auto`, since the results a task
	 * // depends on are still spread into arguments.
	 * async.autoInject({
	 *     //...
	 *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {
	 *         callback(null, 'filename');
	 *     }],
	 *     email_link: ['write_file', function(write_file, callback) {
	 *         callback(null, {'file':write_file, 'email':'user@example.com'});
	 *     }]
	 *     //...
	 * }, function(err, results) {
	 *     console.log('err = ', err);
	 *     console.log('email_link = ', results.email_link);
	 * });
	 */
	function autoInject(tasks, callback) {
	    var newTasks = {};
	
	    baseForOwn(tasks, function (taskFn, key) {
	        var params;
	
	        if (isArray(taskFn)) {
	            params = taskFn.slice(0, -1);
	            taskFn = taskFn[taskFn.length - 1];
	
	            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
	        } else if (taskFn.length === 1) {
	            // no dependencies, use the function as-is
	            newTasks[key] = taskFn;
	        } else {
	            params = parseParams(taskFn);
	            if (taskFn.length === 0 && params.length === 0) {
	                throw new Error("autoInject task functions require explicit parameters.");
	            }
	
	            params.pop();
	
	            newTasks[key] = params.concat(newTask);
	        }
	
	        function newTask(results, taskCb) {
	            var newArgs = arrayMap(params, function (name) {
	                return results[name];
	            });
	            newArgs.push(taskCb);
	            taskFn.apply(null, newArgs);
	        }
	    });
	
	    auto(newTasks, callback);
	}
	
	var hasSetImmediate = typeof setImmediate === 'function' && setImmediate;
	var hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';
	
	function fallback(fn) {
	    setTimeout(fn, 0);
	}
	
	function wrap(defer) {
	    return rest(function (fn, args) {
	        defer(function () {
	            fn.apply(null, args);
	        });
	    });
	}
	
	var _defer;
	
	if (hasSetImmediate) {
	    _defer = setImmediate;
	} else if (hasNextTick) {
	    _defer = process.nextTick;
	} else {
	    _defer = fallback;
	}
	
	var setImmediate$1 = wrap(_defer);
	
	// Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation
	// used for queues. This implementation assumes that the node provided by the user can be modified
	// to adjust the next and last properties. We implement only the minimal functionality
	// for queue support.
	function DLL() {
	    this.head = this.tail = null;
	    this.length = 0;
	}
	
	function setInitial(dll, node) {
	    dll.length = 1;
	    dll.head = dll.tail = node;
	}
	
	DLL.prototype.removeLink = function (node) {
	    if (node.prev) node.prev.next = node.next;else this.head = node.next;
	    if (node.next) node.next.prev = node.prev;else this.tail = node.prev;
	
	    node.prev = node.next = null;
	    this.length -= 1;
	    return node;
	};
	
	DLL.prototype.empty = DLL;
	
	DLL.prototype.insertAfter = function (node, newNode) {
	    newNode.prev = node;
	    newNode.next = node.next;
	    if (node.next) node.next.prev = newNode;else this.tail = newNode;
	    node.next = newNode;
	    this.length += 1;
	};
	
	DLL.prototype.insertBefore = function (node, newNode) {
	    newNode.prev = node.prev;
	    newNode.next = node;
	    if (node.prev) node.prev.next = newNode;else this.head = newNode;
	    node.prev = newNode;
	    this.length += 1;
	};
	
	DLL.prototype.unshift = function (node) {
	    if (this.head) this.insertBefore(this.head, node);else setInitial(this, node);
	};
	
	DLL.prototype.push = function (node) {
	    if (this.tail) this.insertAfter(this.tail, node);else setInitial(this, node);
	};
	
	DLL.prototype.shift = function () {
	    return this.head && this.removeLink(this.head);
	};
	
	DLL.prototype.pop = function () {
	    return this.tail && this.removeLink(this.tail);
	};
	
	function queue(worker, concurrency, payload) {
	    if (concurrency == null) {
	        concurrency = 1;
	    } else if (concurrency === 0) {
	        throw new Error('Concurrency must not be zero');
	    }
	
	    function _insert(data, insertAtFront, callback) {
	        if (callback != null && typeof callback !== 'function') {
	            throw new Error('task callback must be a function');
	        }
	        q.started = true;
	        if (!isArray(data)) {
	            data = [data];
	        }
	        if (data.length === 0 && q.idle()) {
	            // call drain immediately if there are no tasks
	            return setImmediate$1(function () {
	                q.drain();
	            });
	        }
	
	        for (var i = 0, l = data.length; i < l; i++) {
	            var item = {
	                data: data[i],
	                callback: callback || noop
	            };
	
	            if (insertAtFront) {
	                q._tasks.unshift(item);
	            } else {
	                q._tasks.push(item);
	            }
	        }
	        setImmediate$1(q.process);
	    }
	
	    function _next(tasks) {
	        return rest(function (args) {
	            workers -= 1;
	
	            for (var i = 0, l = tasks.length; i < l; i++) {
	                var task = tasks[i];
	                var index = baseIndexOf(workersList, task, 0);
	                if (index >= 0) {
	                    workersList.splice(index);
	                }
	
	                task.callback.apply(task, args);
	
	                if (args[0] != null) {
	                    q.error(args[0], task.data);
	                }
	            }
	
	            if (workers <= q.concurrency - q.buffer) {
	                q.unsaturated();
	            }
	
	            if (q.idle()) {
	                q.drain();
	            }
	            q.process();
	        });
	    }
	
	    var workers = 0;
	    var workersList = [];
	    var isProcessing = false;
	    var q = {
	        _tasks: new DLL(),
	        concurrency: concurrency,
	        payload: payload,
	        saturated: noop,
	        unsaturated: noop,
	        buffer: concurrency / 4,
	        empty: noop,
	        drain: noop,
	        error: noop,
	        started: false,
	        paused: false,
	        push: function (data, callback) {
	            _insert(data, false, callback);
	        },
	        kill: function () {
	            q.drain = noop;
	            q._tasks.empty();
	        },
	        unshift: function (data, callback) {
	            _insert(data, true, callback);
	        },
	        process: function () {
	            // Avoid trying to start too many processing operations. This can occur
	            // when callbacks resolve synchronously (#1267).
	            if (isProcessing) {
	                return;
	            }
	            isProcessing = true;
	            while (!q.paused && workers < q.concurrency && q._tasks.length) {
	                var tasks = [],
	                    data = [];
	                var l = q._tasks.length;
	                if (q.payload) l = Math.min(l, q.payload);
	                for (var i = 0; i < l; i++) {
	                    var node = q._tasks.shift();
	                    tasks.push(node);
	                    data.push(node.data);
	                }
	
	                if (q._tasks.length === 0) {
	                    q.empty();
	                }
	                workers += 1;
	                workersList.push(tasks[0]);
	
	                if (workers === q.concurrency) {
	                    q.saturated();
	                }
	
	                var cb = onlyOnce(_next(tasks));
	                worker(data, cb);
	            }
	            isProcessing = false;
	        },
	        length: function () {
	            return q._tasks.length;
	        },
	        running: function () {
	            return workers;
	        },
	        workersList: function () {
	            return workersList;
	        },
	        idle: function () {
	            return q._tasks.length + workers === 0;
	        },
	        pause: function () {
	            q.paused = true;
	        },
	        resume: function () {
	            if (q.paused === false) {
	                return;
	            }
	            q.paused = false;
	            setImmediate$1(q.process);
	        }
	    };
	    return q;
	}
	
	/**
	 * A cargo of tasks for the worker function to complete. Cargo inherits all of
	 * the same methods and event callbacks as [`queue`]{@link module:ControlFlow.queue}.
	 * @typedef {Object} CargoObject
	 * @memberOf module:ControlFlow
	 * @property {Function} length - A function returning the number of items
	 * waiting to be processed. Invoke like `cargo.length()`.
	 * @property {number} payload - An `integer` for determining how many tasks
	 * should be process per round. This property can be changed after a `cargo` is
	 * created to alter the payload on-the-fly.
	 * @property {Function} push - Adds `task` to the `queue`. The callback is
	 * called once the `worker` has finished processing the task. Instead of a
	 * single task, an array of `tasks` can be submitted. The respective callback is
	 * used for every task in the list. Invoke like `cargo.push(task, [callback])`.
	 * @property {Function} saturated - A callback that is called when the
	 * `queue.length()` hits the concurrency and further tasks will be queued.
	 * @property {Function} empty - A callback that is called when the last item
	 * from the `queue` is given to a `worker`.
	 * @property {Function} drain - A callback that is called when the last item
	 * from the `queue` has returned from the `worker`.
	 * @property {Function} idle - a function returning false if there are items
	 * waiting or being processed, or true if not. Invoke like `cargo.idle()`.
	 * @property {Function} pause - a function that pauses the processing of tasks
	 * until `resume()` is called. Invoke like `cargo.pause()`.
	 * @property {Function} resume - a function that resumes the processing of
	 * queued tasks when the queue is paused. Invoke like `cargo.resume()`.
	 * @property {Function} kill - a function that removes the `drain` callback and
	 * empties remaining tasks from the queue forcing it to go idle. Invoke like `cargo.kill()`.
	 */
	
	/**
	 * Creates a `cargo` object with the specified payload. Tasks added to the
	 * cargo will be processed altogether (up to the `payload` limit). If the
	 * `worker` is in progress, the task is queued until it becomes available. Once
	 * the `worker` has completed some tasks, each callback of those tasks is
	 * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)
	 * for how `cargo` and `queue` work.
	 *
	 * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers
	 * at a time, cargo passes an array of tasks to a single worker, repeating
	 * when the worker is finished.
	 *
	 * @name cargo
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.queue]{@link module:ControlFlow.queue}
	 * @category Control Flow
	 * @param {Function} worker - An asynchronous function for processing an array
	 * of queued tasks, which must call its `callback(err)` argument when finished,
	 * with an optional `err` argument. Invoked with `(tasks, callback)`.
	 * @param {number} [payload=Infinity] - An optional `integer` for determining
	 * how many tasks should be processed per round; if omitted, the default is
	 * unlimited.
	 * @returns {module:ControlFlow.CargoObject} A cargo object to manage the tasks. Callbacks can
	 * attached as certain properties to listen for specific events during the
	 * lifecycle of the cargo and inner queue.
	 * @example
	 *
	 * // create a cargo object with payload 2
	 * var cargo = async.cargo(function(tasks, callback) {
	 *     for (var i=0; i<tasks.length; i++) {
	 *         console.log('hello ' + tasks[i].name);
	 *     }
	 *     callback();
	 * }, 2);
	 *
	 * // add some items
	 * cargo.push({name: 'foo'}, function(err) {
	 *     console.log('finished processing foo');
	 * });
	 * cargo.push({name: 'bar'}, function(err) {
	 *     console.log('finished processing bar');
	 * });
	 * cargo.push({name: 'baz'}, function(err) {
	 *     console.log('finished processing baz');
	 * });
	 */
	function cargo(worker, payload) {
	  return queue(worker, 1, payload);
	}
	
	/**
	 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.
	 *
	 * @name eachOfSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.eachOf]{@link module:Collections.eachOf}
	 * @alias forEachOfSeries
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each item in `coll`. The
	 * `key` is the item's key, or index in the case of an array. The iteratee is
	 * passed a `callback(err)` which must be called once it has completed. If no
	 * error has occurred, the callback should be run without arguments or with an
	 * explicit `null` argument. Invoked with (item, key, callback).
	 * @param {Function} [callback] - A callback which is called when all `iteratee`
	 * functions have finished, or an error occurs. Invoked with (err).
	 */
	var eachOfSeries = doLimit(eachOfLimit, 1);
	
	/**
	 * Reduces `coll` into a single value using an async `iteratee` to return each
	 * successive step. `memo` is the initial state of the reduction. This function
	 * only operates in series.
	 *
	 * For performance reasons, it may make sense to split a call to this function
	 * into a parallel map, and then use the normal `Array.prototype.reduce` on the
	 * results. This function is for situations where each step in the reduction
	 * needs to be async; if you can get the data before reducing it, then it's
	 * probably a good idea to do so.
	 *
	 * @name reduce
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @alias inject
	 * @alias foldl
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {*} memo - The initial state of the reduction.
	 * @param {Function} iteratee - A function applied to each item in the
	 * array to produce the next step in the reduction. The `iteratee` is passed a
	 * `callback(err, reduction)` which accepts an optional error as its first
	 * argument, and the state of the reduction as the second. If an error is
	 * passed to the callback, the reduction is stopped and the main `callback` is
	 * immediately called with the error. Invoked with (memo, item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Result is the reduced value. Invoked with
	 * (err, result).
	 * @example
	 *
	 * async.reduce([1,2,3], 0, function(memo, item, callback) {
	 *     // pointless async:
	 *     process.nextTick(function() {
	 *         callback(null, memo + item)
	 *     });
	 * }, function(err, result) {
	 *     // result is now equal to the last value of memo, which is 6
	 * });
	 */
	function reduce(coll, memo, iteratee, callback) {
	    callback = once(callback || noop);
	    eachOfSeries(coll, function (x, i, callback) {
	        iteratee(memo, x, function (err, v) {
	            memo = v;
	            callback(err);
	        });
	    }, function (err) {
	        callback(err, memo);
	    });
	}
	
	/**
	 * Version of the compose function that is more natural to read. Each function
	 * consumes the return value of the previous function. It is the equivalent of
	 * [compose]{@link module:ControlFlow.compose} with the arguments reversed.
	 *
	 * Each function is executed with the `this` binding of the composed function.
	 *
	 * @name seq
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.compose]{@link module:ControlFlow.compose}
	 * @category Control Flow
	 * @param {...Function} functions - the asynchronous functions to compose
	 * @returns {Function} a function that composes the `functions` in order
	 * @example
	 *
	 * // Requires lodash (or underscore), express3 and dresende's orm2.
	 * // Part of an app, that fetches cats of the logged user.
	 * // This example uses `seq` function to avoid overnesting and error
	 * // handling clutter.
	 * app.get('/cats', function(request, response) {
	 *     var User = request.models.User;
	 *     async.seq(
	 *         _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))
	 *         function(user, fn) {
	 *             user.getCats(fn);      // 'getCats' has signature (callback(err, data))
	 *         }
	 *     )(req.session.user_id, function (err, cats) {
	 *         if (err) {
	 *             console.error(err);
	 *             response.json({ status: 'error', message: err.message });
	 *         } else {
	 *             response.json({ status: 'ok', message: 'Cats found', data: cats });
	 *         }
	 *     });
	 * });
	 */
	var seq$1 = rest(function seq(functions) {
	    return rest(function (args) {
	        var that = this;
	
	        var cb = args[args.length - 1];
	        if (typeof cb == 'function') {
	            args.pop();
	        } else {
	            cb = noop;
	        }
	
	        reduce(functions, args, function (newargs, fn, cb) {
	            fn.apply(that, newargs.concat(rest(function (err, nextargs) {
	                cb(err, nextargs);
	            })));
	        }, function (err, results) {
	            cb.apply(that, [err].concat(results));
	        });
	    });
	});
	
	/**
	 * Creates a function which is a composition of the passed asynchronous
	 * functions. Each function consumes the return value of the function that
	 * follows. Composing functions `f()`, `g()`, and `h()` would produce the result
	 * of `f(g(h()))`, only this version uses callbacks to obtain the return values.
	 *
	 * Each function is executed with the `this` binding of the composed function.
	 *
	 * @name compose
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {...Function} functions - the asynchronous functions to compose
	 * @returns {Function} an asynchronous function that is the composed
	 * asynchronous `functions`
	 * @example
	 *
	 * function add1(n, callback) {
	 *     setTimeout(function () {
	 *         callback(null, n + 1);
	 *     }, 10);
	 * }
	 *
	 * function mul3(n, callback) {
	 *     setTimeout(function () {
	 *         callback(null, n * 3);
	 *     }, 10);
	 * }
	 *
	 * var add1mul3 = async.compose(mul3, add1);
	 * add1mul3(4, function (err, result) {
	 *     // result now equals 15
	 * });
	 */
	var compose = rest(function (args) {
	  return seq$1.apply(null, args.reverse());
	});
	
	function concat$1(eachfn, arr, fn, callback) {
	    var result = [];
	    eachfn(arr, function (x, index, cb) {
	        fn(x, function (err, y) {
	            result = result.concat(y || []);
	            cb(err);
	        });
	    }, function (err) {
	        callback(err, result);
	    });
	}
	
	/**
	 * Applies `iteratee` to each item in `coll`, concatenating the results. Returns
	 * the concatenated list. The `iteratee`s are called in parallel, and the
	 * results are concatenated as they return. There is no guarantee that the
	 * results array will be returned in the original order of `coll` passed to the
	 * `iteratee` function.
	 *
	 * @name concat
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each item in `coll`.
	 * The iteratee is passed a `callback(err, results)` which must be called once
	 * it has completed with an error (which can be `null`) and an array of results.
	 * Invoked with (item, callback).
	 * @param {Function} [callback(err)] - A callback which is called after all the
	 * `iteratee` functions have finished, or an error occurs. Results is an array
	 * containing the concatenated results of the `iteratee` function. Invoked with
	 * (err, results).
	 * @example
	 *
	 * async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files) {
	 *     // files is now a list of filenames that exist in the 3 directories
	 * });
	 */
	var concat = doParallel(concat$1);
	
	function doSeries(fn) {
	    return function (obj, iteratee, callback) {
	        return fn(eachOfSeries, obj, iteratee, callback);
	    };
	}
	
	/**
	 * The same as [`concat`]{@link module:Collections.concat} but runs only a single async operation at a time.
	 *
	 * @name concatSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.concat]{@link module:Collections.concat}
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each item in `coll`.
	 * The iteratee is passed a `callback(err, results)` which must be called once
	 * it has completed with an error (which can be `null`) and an array of results.
	 * Invoked with (item, callback).
	 * @param {Function} [callback(err)] - A callback which is called after all the
	 * `iteratee` functions have finished, or an error occurs. Results is an array
	 * containing the concatenated results of the `iteratee` function. Invoked with
	 * (err, results).
	 */
	var concatSeries = doSeries(concat$1);
	
	/**
	 * Returns a function that when called, calls-back with the values provided.
	 * Useful as the first function in a [`waterfall`]{@link module:ControlFlow.waterfall}, or for plugging values in to
	 * [`auto`]{@link module:ControlFlow.auto}.
	 *
	 * @name constant
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @category Util
	 * @param {...*} arguments... - Any number of arguments to automatically invoke
	 * callback with.
	 * @returns {Function} Returns a function that when invoked, automatically
	 * invokes the callback with the previous given arguments.
	 * @example
	 *
	 * async.waterfall([
	 *     async.constant(42),
	 *     function (value, next) {
	 *         // value === 42
	 *     },
	 *     //...
	 * ], callback);
	 *
	 * async.waterfall([
	 *     async.constant(filename, "utf8"),
	 *     fs.readFile,
	 *     function (fileData, next) {
	 *         //...
	 *     }
	 *     //...
	 * ], callback);
	 *
	 * async.auto({
	 *     hostname: async.constant("https://server.net/"),
	 *     port: findFreePort,
	 *     launchServer: ["hostname", "port", function (options, cb) {
	 *         startServer(options, cb);
	 *     }],
	 *     //...
	 * }, callback);
	 */
	var constant = rest(function (values) {
	    var args = [null].concat(values);
	    return initialParams(function (ignoredArgs, callback) {
	        return callback.apply(this, args);
	    });
	});
	
	function _createTester(check, getResult) {
	    return function (eachfn, arr, iteratee, cb) {
	        cb = cb || noop;
	        var testPassed = false;
	        var testResult;
	        eachfn(arr, function (value, _, callback) {
	            iteratee(value, function (err, result) {
	                if (err) {
	                    callback(err);
	                } else if (check(result) && !testResult) {
	                    testPassed = true;
	                    testResult = getResult(true, value);
	                    callback(null, breakLoop);
	                } else {
	                    callback();
	                }
	            });
	        }, function (err) {
	            if (err) {
	                cb(err);
	            } else {
	                cb(null, testPassed ? testResult : getResult(false));
	            }
	        });
	    };
	}
	
	function _findGetResult(v, x) {
	    return x;
	}
	
	/**
	 * Returns the first value in `coll` that passes an async truth test. The
	 * `iteratee` is applied in parallel, meaning the first iteratee to return
	 * `true` will fire the detect `callback` with that result. That means the
	 * result might not be the first item in the original `coll` (in terms of order)
	 * that passes the test.
	
	 * If order within the original `coll` is important, then look at
	 * [`detectSeries`]{@link module:Collections.detectSeries}.
	 *
	 * @name detect
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @alias find
	 * @category Collections
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
	 * The iteratee is passed a `callback(err, truthValue)` which must be called
	 * with a boolean argument once it has completed. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called as soon as any
	 * iteratee returns `true`, or after all the `iteratee` functions have finished.
	 * Result will be the first item in the array that passes the truth test
	 * (iteratee) or the value `undefined` if none passed. Invoked with
	 * (err, result).
	 * @example
	 *
	 * async.detect(['file1','file2','file3'], function(filePath, callback) {
	 *     fs.access(filePath, function(err) {
	 *         callback(null, !err)
	 *     });
	 * }, function(err, result) {
	 *     // result now equals the first file in the list that exists
	 * });
	 */
	var detect = doParallel(_createTester(identity, _findGetResult));
	
	/**
	 * The same as [`detect`]{@link module:Collections.detect} but runs a maximum of `limit` async operations at a
	 * time.
	 *
	 * @name detectLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.detect]{@link module:Collections.detect}
	 * @alias findLimit
	 * @category Collections
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
	 * The iteratee is passed a `callback(err, truthValue)` which must be called
	 * with a boolean argument once it has completed. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called as soon as any
	 * iteratee returns `true`, or after all the `iteratee` functions have finished.
	 * Result will be the first item in the array that passes the truth test
	 * (iteratee) or the value `undefined` if none passed. Invoked with
	 * (err, result).
	 */
	var detectLimit = doParallelLimit(_createTester(identity, _findGetResult));
	
	/**
	 * The same as [`detect`]{@link module:Collections.detect} but runs only a single async operation at a time.
	 *
	 * @name detectSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.detect]{@link module:Collections.detect}
	 * @alias findSeries
	 * @category Collections
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
	 * The iteratee is passed a `callback(err, truthValue)` which must be called
	 * with a boolean argument once it has completed. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called as soon as any
	 * iteratee returns `true`, or after all the `iteratee` functions have finished.
	 * Result will be the first item in the array that passes the truth test
	 * (iteratee) or the value `undefined` if none passed. Invoked with
	 * (err, result).
	 */
	var detectSeries = doLimit(detectLimit, 1);
	
	function consoleFunc(name) {
	    return rest(function (fn, args) {
	        fn.apply(null, args.concat(rest(function (err, args) {
	            if (typeof console === 'object') {
	                if (err) {
	                    if (console.error) {
	                        console.error(err);
	                    }
	                } else if (console[name]) {
	                    arrayEach(args, function (x) {
	                        console[name](x);
	                    });
	                }
	            }
	        })));
	    });
	}
	
	/**
	 * Logs the result of an `async` function to the `console` using `console.dir`
	 * to display the properties of the resulting object. Only works in Node.js or
	 * in browsers that support `console.dir` and `console.error` (such as FF and
	 * Chrome). If multiple arguments are returned from the async function,
	 * `console.dir` is called on each argument in order.
	 *
	 * @name dir
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @category Util
	 * @param {Function} function - The function you want to eventually apply all
	 * arguments to.
	 * @param {...*} arguments... - Any number of arguments to apply to the function.
	 * @example
	 *
	 * // in a module
	 * var hello = function(name, callback) {
	 *     setTimeout(function() {
	 *         callback(null, {hello: name});
	 *     }, 1000);
	 * };
	 *
	 * // in the node repl
	 * node> async.dir(hello, 'world');
	 * {hello: 'world'}
	 */
	var dir = consoleFunc('dir');
	
	/**
	 * The post-check version of [`during`]{@link module:ControlFlow.during}. To reflect the difference in
	 * the order of operations, the arguments `test` and `fn` are switched.
	 *
	 * Also a version of [`doWhilst`]{@link module:ControlFlow.doWhilst} with asynchronous `test` function.
	 * @name doDuring
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.during]{@link module:ControlFlow.during}
	 * @category Control Flow
	 * @param {Function} fn - A function which is called each time `test` passes.
	 * The function is passed a `callback(err)`, which must be called once it has
	 * completed with an optional `err` argument. Invoked with (callback).
	 * @param {Function} test - asynchronous truth test to perform before each
	 * execution of `fn`. Invoked with (...args, callback), where `...args` are the
	 * non-error args from the previous callback of `fn`.
	 * @param {Function} [callback] - A callback which is called after the test
	 * function has failed and repeated execution of `fn` has stopped. `callback`
	 * will be passed an error if one occured, otherwise `null`.
	 */
	function doDuring(fn, test, callback) {
	    callback = onlyOnce(callback || noop);
	
	    var next = rest(function (err, args) {
	        if (err) return callback(err);
	        args.push(check);
	        test.apply(this, args);
	    });
	
	    function check(err, truth) {
	        if (err) return callback(err);
	        if (!truth) return callback(null);
	        fn(next);
	    }
	
	    check(null, true);
	}
	
	/**
	 * The post-check version of [`whilst`]{@link module:ControlFlow.whilst}. To reflect the difference in
	 * the order of operations, the arguments `test` and `iteratee` are switched.
	 *
	 * `doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.
	 *
	 * @name doWhilst
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.whilst]{@link module:ControlFlow.whilst}
	 * @category Control Flow
	 * @param {Function} iteratee - A function which is called each time `test`
	 * passes. The function is passed a `callback(err)`, which must be called once
	 * it has completed with an optional `err` argument. Invoked with (callback).
	 * @param {Function} test - synchronous truth test to perform after each
	 * execution of `iteratee`. Invoked with the non-error callback results of 
	 * `iteratee`.
	 * @param {Function} [callback] - A callback which is called after the test
	 * function has failed and repeated execution of `iteratee` has stopped.
	 * `callback` will be passed an error and any arguments passed to the final
	 * `iteratee`'s callback. Invoked with (err, [results]);
	 */
	function doWhilst(iteratee, test, callback) {
	    callback = onlyOnce(callback || noop);
	    var next = rest(function (err, args) {
	        if (err) return callback(err);
	        if (test.apply(this, args)) return iteratee(next);
	        callback.apply(null, [null].concat(args));
	    });
	    iteratee(next);
	}
	
	/**
	 * Like ['doWhilst']{@link module:ControlFlow.doWhilst}, except the `test` is inverted. Note the
	 * argument ordering differs from `until`.
	 *
	 * @name doUntil
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.doWhilst]{@link module:ControlFlow.doWhilst}
	 * @category Control Flow
	 * @param {Function} fn - A function which is called each time `test` fails.
	 * The function is passed a `callback(err)`, which must be called once it has
	 * completed with an optional `err` argument. Invoked with (callback).
	 * @param {Function} test - synchronous truth test to perform after each
	 * execution of `fn`. Invoked with the non-error callback results of `fn`.
	 * @param {Function} [callback] - A callback which is called after the test
	 * function has passed and repeated execution of `fn` has stopped. `callback`
	 * will be passed an error and any arguments passed to the final `fn`'s
	 * callback. Invoked with (err, [results]);
	 */
	function doUntil(fn, test, callback) {
	    doWhilst(fn, function () {
	        return !test.apply(this, arguments);
	    }, callback);
	}
	
	/**
	 * Like [`whilst`]{@link module:ControlFlow.whilst}, except the `test` is an asynchronous function that
	 * is passed a callback in the form of `function (err, truth)`. If error is
	 * passed to `test` or `fn`, the main callback is immediately called with the
	 * value of the error.
	 *
	 * @name during
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.whilst]{@link module:ControlFlow.whilst}
	 * @category Control Flow
	 * @param {Function} test - asynchronous truth test to perform before each
	 * execution of `fn`. Invoked with (callback).
	 * @param {Function} fn - A function which is called each time `test` passes.
	 * The function is passed a `callback(err)`, which must be called once it has
	 * completed with an optional `err` argument. Invoked with (callback).
	 * @param {Function} [callback] - A callback which is called after the test
	 * function has failed and repeated execution of `fn` has stopped. `callback`
	 * will be passed an error, if one occured, otherwise `null`.
	 * @example
	 *
	 * var count = 0;
	 *
	 * async.during(
	 *     function (callback) {
	 *         return callback(null, count < 5);
	 *     },
	 *     function (callback) {
	 *         count++;
	 *         setTimeout(callback, 1000);
	 *     },
	 *     function (err) {
	 *         // 5 seconds have passed
	 *     }
	 * );
	 */
	function during(test, fn, callback) {
	    callback = onlyOnce(callback || noop);
	
	    function next(err) {
	        if (err) return callback(err);
	        test(check);
	    }
	
	    function check(err, truth) {
	        if (err) return callback(err);
	        if (!truth) return callback(null);
	        fn(next);
	    }
	
	    test(check);
	}
	
	function _withoutIndex(iteratee) {
	    return function (value, index, callback) {
	        return iteratee(value, callback);
	    };
	}
	
	/**
	 * Applies the function `iteratee` to each item in `coll`, in parallel.
	 * The `iteratee` is called with an item from the list, and a callback for when
	 * it has finished. If the `iteratee` passes an error to its `callback`, the
	 * main `callback` (for the `each` function) is immediately called with the
	 * error.
	 *
	 * Note, that since this function applies `iteratee` to each item in parallel,
	 * there is no guarantee that the iteratee functions will complete in order.
	 *
	 * @name each
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @alias forEach
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each item
	 * in `coll`. The iteratee is passed a `callback(err)` which must be called once
	 * it has completed. If no error has occurred, the `callback` should be run
	 * without arguments or with an explicit `null` argument. The array index is not
	 * passed to the iteratee. Invoked with (item, callback). If you need the index,
	 * use `eachOf`.
	 * @param {Function} [callback] - A callback which is called when all
	 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
	 * @example
	 *
	 * // assuming openFiles is an array of file names and saveFile is a function
	 * // to save the modified contents of that file:
	 *
	 * async.each(openFiles, saveFile, function(err){
	 *   // if any of the saves produced an error, err would equal that error
	 * });
	 *
	 * // assuming openFiles is an array of file names
	 * async.each(openFiles, function(file, callback) {
	 *
	 *     // Perform operation on file here.
	 *     console.log('Processing file ' + file);
	 *
	 *     if( file.length > 32 ) {
	 *       console.log('This file name is too long');
	 *       callback('File name too long');
	 *     } else {
	 *       // Do work to process file here
	 *       console.log('File processed');
	 *       callback();
	 *     }
	 * }, function(err) {
	 *     // if any of the file processing produced an error, err would equal that error
	 *     if( err ) {
	 *       // One of the iterations produced an error.
	 *       // All processing will now stop.
	 *       console.log('A file failed to process');
	 *     } else {
	 *       console.log('All files have been processed successfully');
	 *     }
	 * });
	 */
	function eachLimit(coll, iteratee, callback) {
	  eachOf(coll, _withoutIndex(iteratee), callback);
	}
	
	/**
	 * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.
	 *
	 * @name eachLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.each]{@link module:Collections.each}
	 * @alias forEachLimit
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {Function} iteratee - A function to apply to each item in `coll`. The
	 * iteratee is passed a `callback(err)` which must be called once it has
	 * completed. If no error has occurred, the `callback` should be run without
	 * arguments or with an explicit `null` argument. The array index is not passed
	 * to the iteratee. Invoked with (item, callback). If you need the index, use
	 * `eachOfLimit`.
	 * @param {Function} [callback] - A callback which is called when all
	 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
	 */
	function eachLimit$1(coll, limit, iteratee, callback) {
	  _eachOfLimit(limit)(coll, _withoutIndex(iteratee), callback);
	}
	
	/**
	 * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.
	 *
	 * @name eachSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.each]{@link module:Collections.each}
	 * @alias forEachSeries
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each
	 * item in `coll`. The iteratee is passed a `callback(err)` which must be called
	 * once it has completed. If no error has occurred, the `callback` should be run
	 * without arguments or with an explicit `null` argument. The array index is
	 * not passed to the iteratee. Invoked with (item, callback). If you need the
	 * index, use `eachOfSeries`.
	 * @param {Function} [callback] - A callback which is called when all
	 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
	 */
	var eachSeries = doLimit(eachLimit$1, 1);
	
	/**
	 * Wrap an async function and ensure it calls its callback on a later tick of
	 * the event loop.  If the function already calls its callback on a next tick,
	 * no extra deferral is added. This is useful for preventing stack overflows
	 * (`RangeError: Maximum call stack size exceeded`) and generally keeping
	 * [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)
	 * contained.
	 *
	 * @name ensureAsync
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @category Util
	 * @param {Function} fn - an async function, one that expects a node-style
	 * callback as its last argument.
	 * @returns {Function} Returns a wrapped function with the exact same call
	 * signature as the function passed in.
	 * @example
	 *
	 * function sometimesAsync(arg, callback) {
	 *     if (cache[arg]) {
	 *         return callback(null, cache[arg]); // this would be synchronous!!
	 *     } else {
	 *         doSomeIO(arg, callback); // this IO would be asynchronous
	 *     }
	 * }
	 *
	 * // this has a risk of stack overflows if many results are cached in a row
	 * async.mapSeries(args, sometimesAsync, done);
	 *
	 * // this will defer sometimesAsync's callback if necessary,
	 * // preventing stack overflows
	 * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);
	 */
	function ensureAsync(fn) {
	    return initialParams(function (args, callback) {
	        var sync = true;
	        args.push(function () {
	            var innerArgs = arguments;
	            if (sync) {
	                setImmediate$1(function () {
	                    callback.apply(null, innerArgs);
	                });
	            } else {
	                callback.apply(null, innerArgs);
	            }
	        });
	        fn.apply(this, args);
	        sync = false;
	    });
	}
	
	function notId(v) {
	    return !v;
	}
	
	/**
	 * Returns `true` if every element in `coll` satisfies an async test. If any
	 * iteratee call returns `false`, the main `callback` is immediately called.
	 *
	 * @name every
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @alias all
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A truth test to apply to each item in the
	 * collection in parallel. The iteratee is passed a `callback(err, truthValue)`
	 * which must be called with a  boolean argument once it has completed. Invoked
	 * with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Result will be either `true` or `false`
	 * depending on the values of the async tests. Invoked with (err, result).
	 * @example
	 *
	 * async.every(['file1','file2','file3'], function(filePath, callback) {
	 *     fs.access(filePath, function(err) {
	 *         callback(null, !err)
	 *     });
	 * }, function(err, result) {
	 *     // if result is true then every file exists
	 * });
	 */
	var every = doParallel(_createTester(notId, notId));
	
	/**
	 * The same as [`every`]{@link module:Collections.every} but runs a maximum of `limit` async operations at a time.
	 *
	 * @name everyLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.every]{@link module:Collections.every}
	 * @alias allLimit
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {Function} iteratee - A truth test to apply to each item in the
	 * collection in parallel. The iteratee is passed a `callback(err, truthValue)`
	 * which must be called with a  boolean argument once it has completed. Invoked
	 * with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Result will be either `true` or `false`
	 * depending on the values of the async tests. Invoked with (err, result).
	 */
	var everyLimit = doParallelLimit(_createTester(notId, notId));
	
	/**
	 * The same as [`every`]{@link module:Collections.every} but runs only a single async operation at a time.
	 *
	 * @name everySeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.every]{@link module:Collections.every}
	 * @alias allSeries
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A truth test to apply to each item in the
	 * collection in parallel. The iteratee is passed a `callback(err, truthValue)`
	 * which must be called with a  boolean argument once it has completed. Invoked
	 * with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Result will be either `true` or `false`
	 * depending on the values of the async tests. Invoked with (err, result).
	 */
	var everySeries = doLimit(everyLimit, 1);
	
	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}
	
	function filterArray(eachfn, arr, iteratee, callback) {
	    var truthValues = new Array(arr.length);
	    eachfn(arr, function (x, index, callback) {
	        iteratee(x, function (err, v) {
	            truthValues[index] = !!v;
	            callback(err);
	        });
	    }, function (err) {
	        if (err) return callback(err);
	        var results = [];
	        for (var i = 0; i < arr.length; i++) {
	            if (truthValues[i]) results.push(arr[i]);
	        }
	        callback(null, results);
	    });
	}
	
	function filterGeneric(eachfn, coll, iteratee, callback) {
	    var results = [];
	    eachfn(coll, function (x, index, callback) {
	        iteratee(x, function (err, v) {
	            if (err) {
	                callback(err);
	            } else {
	                if (v) {
	                    results.push({ index: index, value: x });
	                }
	                callback();
	            }
	        });
	    }, function (err) {
	        if (err) {
	            callback(err);
	        } else {
	            callback(null, arrayMap(results.sort(function (a, b) {
	                return a.index - b.index;
	            }), baseProperty('value')));
	        }
	    });
	}
	
	function _filter(eachfn, coll, iteratee, callback) {
	    var filter = isArrayLike(coll) ? filterArray : filterGeneric;
	    filter(eachfn, coll, iteratee, callback || noop);
	}
	
	/**
	 * Returns a new array of all the values in `coll` which pass an async truth
	 * test. This operation is performed in parallel, but the results array will be
	 * in the same order as the original.
	 *
	 * @name filter
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @alias select
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
	 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
	 * with a boolean argument once it has completed. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Invoked with (err, results).
	 * @example
	 *
	 * async.filter(['file1','file2','file3'], function(filePath, callback) {
	 *     fs.access(filePath, function(err) {
	 *         callback(null, !err)
	 *     });
	 * }, function(err, results) {
	 *     // results now equals an array of the existing files
	 * });
	 */
	var filter = doParallel(_filter);
	
	/**
	 * The same as [`filter`]{@link module:Collections.filter} but runs a maximum of `limit` async operations at a
	 * time.
	 *
	 * @name filterLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.filter]{@link module:Collections.filter}
	 * @alias selectLimit
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
	 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
	 * with a boolean argument once it has completed. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Invoked with (err, results).
	 */
	var filterLimit = doParallelLimit(_filter);
	
	/**
	 * The same as [`filter`]{@link module:Collections.filter} but runs only a single async operation at a time.
	 *
	 * @name filterSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.filter]{@link module:Collections.filter}
	 * @alias selectSeries
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
	 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
	 * with a boolean argument once it has completed. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Invoked with (err, results)
	 */
	var filterSeries = doLimit(filterLimit, 1);
	
	/**
	 * Calls the asynchronous function `fn` with a callback parameter that allows it
	 * to call itself again, in series, indefinitely.
	
	 * If an error is passed to the
	 * callback then `errback` is called with the error, and execution stops,
	 * otherwise it will never be called.
	 *
	 * @name forever
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {Function} fn - a function to call repeatedly. Invoked with (next).
	 * @param {Function} [errback] - when `fn` passes an error to it's callback,
	 * this function will be called, and execution stops. Invoked with (err).
	 * @example
	 *
	 * async.forever(
	 *     function(next) {
	 *         // next is suitable for passing to things that need a callback(err [, whatever]);
	 *         // it will result in this function being called again.
	 *     },
	 *     function(err) {
	 *         // if next is called with a value in its first parameter, it will appear
	 *         // in here as 'err', and execution will stop.
	 *     }
	 * );
	 */
	function forever(fn, errback) {
	    var done = onlyOnce(errback || noop);
	    var task = ensureAsync(fn);
	
	    function next(err) {
	        if (err) return done(err);
	        task(next);
	    }
	    next();
	}
	
	/**
	 * Logs the result of an `async` function to the `console`. Only works in
	 * Node.js or in browsers that support `console.log` and `console.error` (such
	 * as FF and Chrome). If multiple arguments are returned from the async
	 * function, `console.log` is called on each argument in order.
	 *
	 * @name log
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @category Util
	 * @param {Function} function - The function you want to eventually apply all
	 * arguments to.
	 * @param {...*} arguments... - Any number of arguments to apply to the function.
	 * @example
	 *
	 * // in a module
	 * var hello = function(name, callback) {
	 *     setTimeout(function() {
	 *         callback(null, 'hello ' + name);
	 *     }, 1000);
	 * };
	 *
	 * // in the node repl
	 * node> async.log(hello, 'world');
	 * 'hello world'
	 */
	var log = consoleFunc('log');
	
	/**
	 * The same as [`mapValues`]{@link module:Collections.mapValues} but runs a maximum of `limit` async operations at a
	 * time.
	 *
	 * @name mapValuesLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.mapValues]{@link module:Collections.mapValues}
	 * @category Collection
	 * @param {Object} obj - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {Function} iteratee - A function to apply to each value in `obj`.
	 * The iteratee is passed a `callback(err, transformed)` which must be called
	 * once it has completed with an error (which can be `null`) and a
	 * transformed value. Invoked with (value, key, callback).
	 * @param {Function} [callback] - A callback which is called when all `iteratee`
	 * functions have finished, or an error occurs. `result` is a new object consisting
	 * of each key from `obj`, with each transformed value on the right-hand side.
	 * Invoked with (err, result).
	 */
	function mapValuesLimit(obj, limit, iteratee, callback) {
	    callback = once(callback || noop);
	    var newObj = {};
	    eachOfLimit(obj, limit, function (val, key, next) {
	        iteratee(val, key, function (err, result) {
	            if (err) return next(err);
	            newObj[key] = result;
	            next();
	        });
	    }, function (err) {
	        callback(err, newObj);
	    });
	}
	
	/**
	 * A relative of [`map`]{@link module:Collections.map}, designed for use with objects.
	 *
	 * Produces a new Object by mapping each value of `obj` through the `iteratee`
	 * function. The `iteratee` is called each `value` and `key` from `obj` and a
	 * callback for when it has finished processing. Each of these callbacks takes
	 * two arguments: an `error`, and the transformed item from `obj`. If `iteratee`
	 * passes an error to its callback, the main `callback` (for the `mapValues`
	 * function) is immediately called with the error.
	 *
	 * Note, the order of the keys in the result is not guaranteed.  The keys will
	 * be roughly in the order they complete, (but this is very engine-specific)
	 *
	 * @name mapValues
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @category Collection
	 * @param {Object} obj - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each value and key in
	 * `coll`. The iteratee is passed a `callback(err, transformed)` which must be
	 * called once it has completed with an error (which can be `null`) and a
	 * transformed value. Invoked with (value, key, callback).
	 * @param {Function} [callback] - A callback which is called when all `iteratee`
	 * functions have finished, or an error occurs. `result` is a new object consisting
	 * of each key from `obj`, with each transformed value on the right-hand side.
	 * Invoked with (err, result).
	 * @example
	 *
	 * async.mapValues({
	 *     f1: 'file1',
	 *     f2: 'file2',
	 *     f3: 'file3'
	 * }, function (file, key, callback) {
	 *   fs.stat(file, callback);
	 * }, function(err, result) {
	 *     // result is now a map of stats for each file, e.g.
	 *     // {
	 *     //     f1: [stats for file1],
	 *     //     f2: [stats for file2],
	 *     //     f3: [stats for file3]
	 *     // }
	 * });
	 */
	
	var mapValues = doLimit(mapValuesLimit, Infinity);
	
	/**
	 * The same as [`mapValues`]{@link module:Collections.mapValues} but runs only a single async operation at a time.
	 *
	 * @name mapValuesSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.mapValues]{@link module:Collections.mapValues}
	 * @category Collection
	 * @param {Object} obj - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each value in `obj`.
	 * The iteratee is passed a `callback(err, transformed)` which must be called
	 * once it has completed with an error (which can be `null`) and a
	 * transformed value. Invoked with (value, key, callback).
	 * @param {Function} [callback] - A callback which is called when all `iteratee`
	 * functions have finished, or an error occurs. `result` is a new object consisting
	 * of each key from `obj`, with each transformed value on the right-hand side.
	 * Invoked with (err, result).
	 */
	var mapValuesSeries = doLimit(mapValuesLimit, 1);
	
	function has(obj, key) {
	    return key in obj;
	}
	
	/**
	 * Caches the results of an `async` function. When creating a hash to store
	 * function results against, the callback is omitted from the hash and an
	 * optional hash function can be used.
	 *
	 * If no hash function is specified, the first argument is used as a hash key,
	 * which may work reasonably if it is a string or a data type that converts to a
	 * distinct string. Note that objects and arrays will not behave reasonably.
	 * Neither will cases where the other arguments are significant. In such cases,
	 * specify your own hash function.
	 *
	 * The cache of results is exposed as the `memo` property of the function
	 * returned by `memoize`.
	 *
	 * @name memoize
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @category Util
	 * @param {Function} fn - The function to proxy and cache results from.
	 * @param {Function} hasher - An optional function for generating a custom hash
	 * for storing results. It has all the arguments applied to it apart from the
	 * callback, and must be synchronous.
	 * @returns {Function} a memoized version of `fn`
	 * @example
	 *
	 * var slow_fn = function(name, callback) {
	 *     // do something
	 *     callback(null, result);
	 * };
	 * var fn = async.memoize(slow_fn);
	 *
	 * // fn can now be used as if it were slow_fn
	 * fn('some name', function() {
	 *     // callback
	 * });
	 */
	function memoize(fn, hasher) {
	    var memo = Object.create(null);
	    var queues = Object.create(null);
	    hasher = hasher || identity;
	    var memoized = initialParams(function memoized(args, callback) {
	        var key = hasher.apply(null, args);
	        if (has(memo, key)) {
	            setImmediate$1(function () {
	                callback.apply(null, memo[key]);
	            });
	        } else if (has(queues, key)) {
	            queues[key].push(callback);
	        } else {
	            queues[key] = [callback];
	            fn.apply(null, args.concat(rest(function (args) {
	                memo[key] = args;
	                var q = queues[key];
	                delete queues[key];
	                for (var i = 0, l = q.length; i < l; i++) {
	                    q[i].apply(null, args);
	                }
	            })));
	        }
	    });
	    memoized.memo = memo;
	    memoized.unmemoized = fn;
	    return memoized;
	}
	
	/**
	 * Calls `callback` on a later loop around the event loop. In Node.js this just
	 * calls `setImmediate`.  In the browser it will use `setImmediate` if
	 * available, otherwise `setTimeout(callback, 0)`, which means other higher
	 * priority events may precede the execution of `callback`.
	 *
	 * This is used internally for browser-compatibility purposes.
	 *
	 * @name nextTick
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @alias setImmediate
	 * @category Util
	 * @param {Function} callback - The function to call on a later loop around
	 * the event loop. Invoked with (args...).
	 * @param {...*} args... - any number of additional arguments to pass to the
	 * callback on the next tick.
	 * @example
	 *
	 * var call_order = [];
	 * async.nextTick(function() {
	 *     call_order.push('two');
	 *     // call_order now equals ['one','two']
	 * });
	 * call_order.push('one');
	 *
	 * async.setImmediate(function (a, b, c) {
	 *     // a, b, and c equal 1, 2, and 3
	 * }, 1, 2, 3);
	 */
	var _defer$1;
	
	if (hasNextTick) {
	    _defer$1 = process.nextTick;
	} else if (hasSetImmediate) {
	    _defer$1 = setImmediate;
	} else {
	    _defer$1 = fallback;
	}
	
	var nextTick = wrap(_defer$1);
	
	function _parallel(eachfn, tasks, callback) {
	    callback = callback || noop;
	    var results = isArrayLike(tasks) ? [] : {};
	
	    eachfn(tasks, function (task, key, callback) {
	        task(rest(function (err, args) {
	            if (args.length <= 1) {
	                args = args[0];
	            }
	            results[key] = args;
	            callback(err);
	        }));
	    }, function (err) {
	        callback(err, results);
	    });
	}
	
	/**
	 * Run the `tasks` collection of functions in parallel, without waiting until
	 * the previous function has completed. If any of the functions pass an error to
	 * its callback, the main `callback` is immediately called with the value of the
	 * error. Once the `tasks` have completed, the results are passed to the final
	 * `callback` as an array.
	 *
	 * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about
	 * parallel execution of code.  If your tasks do not use any timers or perform
	 * any I/O, they will actually be executed in series.  Any synchronous setup
	 * sections for each task will happen one after the other.  JavaScript remains
	 * single-threaded.
	 *
	 * It is also possible to use an object instead of an array. Each property will
	 * be run as a function and the results will be passed to the final `callback`
	 * as an object instead of an array. This can be a more readable way of handling
	 * results from {@link async.parallel}.
	 *
	 * @name parallel
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {Array|Iterable|Object} tasks - A collection containing functions to run.
	 * Each function is passed a `callback(err, result)` which it must call on
	 * completion with an error `err` (which can be `null`) and an optional `result`
	 * value.
	 * @param {Function} [callback] - An optional callback to run once all the
	 * functions have completed successfully. This function gets a results array
	 * (or object) containing all the result arguments passed to the task callbacks.
	 * Invoked with (err, results).
	 * @example
	 * async.parallel([
	 *     function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 'one');
	 *         }, 200);
	 *     },
	 *     function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 'two');
	 *         }, 100);
	 *     }
	 * ],
	 * // optional callback
	 * function(err, results) {
	 *     // the results array will equal ['one','two'] even though
	 *     // the second function had a shorter timeout.
	 * });
	 *
	 * // an example using an object instead of an array
	 * async.parallel({
	 *     one: function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 1);
	 *         }, 200);
	 *     },
	 *     two: function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 2);
	 *         }, 100);
	 *     }
	 * }, function(err, results) {
	 *     // results is now equals to: {one: 1, two: 2}
	 * });
	 */
	function parallelLimit(tasks, callback) {
	  _parallel(eachOf, tasks, callback);
	}
	
	/**
	 * The same as [`parallel`]{@link module:ControlFlow.parallel} but runs a maximum of `limit` async operations at a
	 * time.
	 *
	 * @name parallelLimit
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.parallel]{@link module:ControlFlow.parallel}
	 * @category Control Flow
	 * @param {Array|Collection} tasks - A collection containing functions to run.
	 * Each function is passed a `callback(err, result)` which it must call on
	 * completion with an error `err` (which can be `null`) and an optional `result`
	 * value.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {Function} [callback] - An optional callback to run once all the
	 * functions have completed successfully. This function gets a results array
	 * (or object) containing all the result arguments passed to the task callbacks.
	 * Invoked with (err, results).
	 */
	function parallelLimit$1(tasks, limit, callback) {
	  _parallel(_eachOfLimit(limit), tasks, callback);
	}
	
	/**
	 * A queue of tasks for the worker function to complete.
	 * @typedef {Object} QueueObject
	 * @memberOf module:ControlFlow
	 * @property {Function} length - a function returning the number of items
	 * waiting to be processed. Invoke with `queue.length()`.
	 * @property {boolean} started - a boolean indicating whether or not any
	 * items have been pushed and processed by the queue.
	 * @property {Function} running - a function returning the number of items
	 * currently being processed. Invoke with `queue.running()`.
	 * @property {Function} workersList - a function returning the array of items
	 * currently being processed. Invoke with `queue.workersList()`.
	 * @property {Function} idle - a function returning false if there are items
	 * waiting or being processed, or true if not. Invoke with `queue.idle()`.
	 * @property {number} concurrency - an integer for determining how many `worker`
	 * functions should be run in parallel. This property can be changed after a
	 * `queue` is created to alter the concurrency on-the-fly.
	 * @property {Function} push - add a new task to the `queue`. Calls `callback`
	 * once the `worker` has finished processing the task. Instead of a single task,
	 * a `tasks` array can be submitted. The respective callback is used for every
	 * task in the list. Invoke with `queue.push(task, [callback])`,
	 * @property {Function} unshift - add a new task to the front of the `queue`.
	 * Invoke with `queue.unshift(task, [callback])`.
	 * @property {Function} saturated - a callback that is called when the number of
	 * running workers hits the `concurrency` limit, and further tasks will be
	 * queued.
	 * @property {Function} unsaturated - a callback that is called when the number
	 * of running workers is less than the `concurrency` & `buffer` limits, and
	 * further tasks will not be queued.
	 * @property {number} buffer - A minimum threshold buffer in order to say that
	 * the `queue` is `unsaturated`.
	 * @property {Function} empty - a callback that is called when the last item
	 * from the `queue` is given to a `worker`.
	 * @property {Function} drain - a callback that is called when the last item
	 * from the `queue` has returned from the `worker`.
	 * @property {Function} error - a callback that is called when a task errors.
	 * Has the signature `function(error, task)`.
	 * @property {boolean} paused - a boolean for determining whether the queue is
	 * in a paused state.
	 * @property {Function} pause - a function that pauses the processing of tasks
	 * until `resume()` is called. Invoke with `queue.pause()`.
	 * @property {Function} resume - a function that resumes the processing of
	 * queued tasks when the queue is paused. Invoke with `queue.resume()`.
	 * @property {Function} kill - a function that removes the `drain` callback and
	 * empties remaining tasks from the queue forcing it to go idle. Invoke with `queue.kill()`.
	 */
	
	/**
	 * Creates a `queue` object with the specified `concurrency`. Tasks added to the
	 * `queue` are processed in parallel (up to the `concurrency` limit). If all
	 * `worker`s are in progress, the task is queued until one becomes available.
	 * Once a `worker` completes a `task`, that `task`'s callback is called.
	 *
	 * @name queue
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {Function} worker - An asynchronous function for processing a queued
	 * task, which must call its `callback(err)` argument when finished, with an
	 * optional `error` as an argument.  If you want to handle errors from an
	 * individual task, pass a callback to `q.push()`. Invoked with
	 * (task, callback).
	 * @param {number} [concurrency=1] - An `integer` for determining how many
	 * `worker` functions should be run in parallel.  If omitted, the concurrency
	 * defaults to `1`.  If the concurrency is `0`, an error is thrown.
	 * @returns {module:ControlFlow.QueueObject} A queue object to manage the tasks. Callbacks can
	 * attached as certain properties to listen for specific events during the
	 * lifecycle of the queue.
	 * @example
	 *
	 * // create a queue object with concurrency 2
	 * var q = async.queue(function(task, callback) {
	 *     console.log('hello ' + task.name);
	 *     callback();
	 * }, 2);
	 *
	 * // assign a callback
	 * q.drain = function() {
	 *     console.log('all items have been processed');
	 * };
	 *
	 * // add some items to the queue
	 * q.push({name: 'foo'}, function(err) {
	 *     console.log('finished processing foo');
	 * });
	 * q.push({name: 'bar'}, function (err) {
	 *     console.log('finished processing bar');
	 * });
	 *
	 * // add some items to the queue (batch-wise)
	 * q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {
	 *     console.log('finished processing item');
	 * });
	 *
	 * // add some items to the front of the queue
	 * q.unshift({name: 'bar'}, function (err) {
	 *     console.log('finished processing bar');
	 * });
	 */
	var queue$1 = function (worker, concurrency) {
	  return queue(function (items, cb) {
	    worker(items[0], cb);
	  }, concurrency, 1);
	};
	
	/**
	 * The same as [async.queue]{@link module:ControlFlow.queue} only tasks are assigned a priority and
	 * completed in ascending priority order.
	 *
	 * @name priorityQueue
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.queue]{@link module:ControlFlow.queue}
	 * @category Control Flow
	 * @param {Function} worker - An asynchronous function for processing a queued
	 * task, which must call its `callback(err)` argument when finished, with an
	 * optional `error` as an argument.  If you want to handle errors from an
	 * individual task, pass a callback to `q.push()`. Invoked with
	 * (task, callback).
	 * @param {number} concurrency - An `integer` for determining how many `worker`
	 * functions should be run in parallel.  If omitted, the concurrency defaults to
	 * `1`.  If the concurrency is `0`, an error is thrown.
	 * @returns {module:ControlFlow.QueueObject} A priorityQueue object to manage the tasks. There are two
	 * differences between `queue` and `priorityQueue` objects:
	 * * `push(task, priority, [callback])` - `priority` should be a number. If an
	 *   array of `tasks` is given, all tasks will be assigned the same priority.
	 * * The `unshift` method was removed.
	 */
	var priorityQueue = function (worker, concurrency) {
	    // Start with a normal queue
	    var q = queue$1(worker, concurrency);
	
	    // Override push to accept second parameter representing priority
	    q.push = function (data, priority, callback) {
	        if (callback == null) callback = noop;
	        if (typeof callback !== 'function') {
	            throw new Error('task callback must be a function');
	        }
	        q.started = true;
	        if (!isArray(data)) {
	            data = [data];
	        }
	        if (data.length === 0) {
	            // call drain immediately if there are no tasks
	            return setImmediate$1(function () {
	                q.drain();
	            });
	        }
	
	        priority = priority || 0;
	        var nextNode = q._tasks.head;
	        while (nextNode && priority >= nextNode.priority) {
	            nextNode = nextNode.next;
	        }
	
	        for (var i = 0, l = data.length; i < l; i++) {
	            var item = {
	                data: data[i],
	                priority: priority,
	                callback: callback
	            };
	
	            if (nextNode) {
	                q._tasks.insertBefore(nextNode, item);
	            } else {
	                q._tasks.push(item);
	            }
	        }
	        setImmediate$1(q.process);
	    };
	
	    // Remove unshift function
	    delete q.unshift;
	
	    return q;
	};
	
	/**
	 * Runs the `tasks` array of functions in parallel, without waiting until the
	 * previous function has completed. Once any of the `tasks` complete or pass an
	 * error to its callback, the main `callback` is immediately called. It's
	 * equivalent to `Promise.race()`.
	 *
	 * @name race
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {Array} tasks - An array containing functions to run. Each function
	 * is passed a `callback(err, result)` which it must call on completion with an
	 * error `err` (which can be `null`) and an optional `result` value.
	 * @param {Function} callback - A callback to run once any of the functions have
	 * completed. This function gets an error or result from the first function that
	 * completed. Invoked with (err, result).
	 * @returns undefined
	 * @example
	 *
	 * async.race([
	 *     function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 'one');
	 *         }, 200);
	 *     },
	 *     function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 'two');
	 *         }, 100);
	 *     }
	 * ],
	 * // main callback
	 * function(err, result) {
	 *     // the result will be equal to 'two' as it finishes earlier
	 * });
	 */
	function race(tasks, callback) {
	    callback = once(callback || noop);
	    if (!isArray(tasks)) return callback(new TypeError('First argument to race must be an array of functions'));
	    if (!tasks.length) return callback();
	    for (var i = 0, l = tasks.length; i < l; i++) {
	        tasks[i](callback);
	    }
	}
	
	var slice = Array.prototype.slice;
	
	/**
	 * Same as [`reduce`]{@link module:Collections.reduce}, only operates on `array` in reverse order.
	 *
	 * @name reduceRight
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.reduce]{@link module:Collections.reduce}
	 * @alias foldr
	 * @category Collection
	 * @param {Array} array - A collection to iterate over.
	 * @param {*} memo - The initial state of the reduction.
	 * @param {Function} iteratee - A function applied to each item in the
	 * array to produce the next step in the reduction. The `iteratee` is passed a
	 * `callback(err, reduction)` which accepts an optional error as its first
	 * argument, and the state of the reduction as the second. If an error is
	 * passed to the callback, the reduction is stopped and the main `callback` is
	 * immediately called with the error. Invoked with (memo, item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Result is the reduced value. Invoked with
	 * (err, result).
	 */
	function reduceRight(array, memo, iteratee, callback) {
	  var reversed = slice.call(array).reverse();
	  reduce(reversed, memo, iteratee, callback);
	}
	
	/**
	 * Wraps the function in another function that always returns data even when it
	 * errors.
	 *
	 * The object returned has either the property `error` or `value`.
	 *
	 * @name reflect
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @category Util
	 * @param {Function} fn - The function you want to wrap
	 * @returns {Function} - A function that always passes null to it's callback as
	 * the error. The second argument to the callback will be an `object` with
	 * either an `error` or a `value` property.
	 * @example
	 *
	 * async.parallel([
	 *     async.reflect(function(callback) {
	 *         // do some stuff ...
	 *         callback(null, 'one');
	 *     }),
	 *     async.reflect(function(callback) {
	 *         // do some more stuff but error ...
	 *         callback('bad stuff happened');
	 *     }),
	 *     async.reflect(function(callback) {
	 *         // do some more stuff ...
	 *         callback(null, 'two');
	 *     })
	 * ],
	 * // optional callback
	 * function(err, results) {
	 *     // values
	 *     // results[0].value = 'one'
	 *     // results[1].error = 'bad stuff happened'
	 *     // results[2].value = 'two'
	 * });
	 */
	function reflect(fn) {
	    return initialParams(function reflectOn(args, reflectCallback) {
	        args.push(rest(function callback(err, cbArgs) {
	            if (err) {
	                reflectCallback(null, {
	                    error: err
	                });
	            } else {
	                var value = null;
	                if (cbArgs.length === 1) {
	                    value = cbArgs[0];
	                } else if (cbArgs.length > 1) {
	                    value = cbArgs;
	                }
	                reflectCallback(null, {
	                    value: value
	                });
	            }
	        }));
	
	        return fn.apply(this, args);
	    });
	}
	
	function reject$1(eachfn, arr, iteratee, callback) {
	    _filter(eachfn, arr, function (value, cb) {
	        iteratee(value, function (err, v) {
	            cb(err, !v);
	        });
	    }, callback);
	}
	
	/**
	 * The opposite of [`filter`]{@link module:Collections.filter}. Removes values that pass an `async` truth test.
	 *
	 * @name reject
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.filter]{@link module:Collections.filter}
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
	 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
	 * with a boolean argument once it has completed. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Invoked with (err, results).
	 * @example
	 *
	 * async.reject(['file1','file2','file3'], function(filePath, callback) {
	 *     fs.access(filePath, function(err) {
	 *         callback(null, !err)
	 *     });
	 * }, function(err, results) {
	 *     // results now equals an array of missing files
	 *     createFiles(results);
	 * });
	 */
	var reject = doParallel(reject$1);
	
	/**
	 * A helper function that wraps an array or an object of functions with reflect.
	 *
	 * @name reflectAll
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @see [async.reflect]{@link module:Utils.reflect}
	 * @category Util
	 * @param {Array} tasks - The array of functions to wrap in `async.reflect`.
	 * @returns {Array} Returns an array of functions, each function wrapped in
	 * `async.reflect`
	 * @example
	 *
	 * let tasks = [
	 *     function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 'one');
	 *         }, 200);
	 *     },
	 *     function(callback) {
	 *         // do some more stuff but error ...
	 *         callback(new Error('bad stuff happened'));
	 *     },
	 *     function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 'two');
	 *         }, 100);
	 *     }
	 * ];
	 *
	 * async.parallel(async.reflectAll(tasks),
	 * // optional callback
	 * function(err, results) {
	 *     // values
	 *     // results[0].value = 'one'
	 *     // results[1].error = Error('bad stuff happened')
	 *     // results[2].value = 'two'
	 * });
	 *
	 * // an example using an object instead of an array
	 * let tasks = {
	 *     one: function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 'one');
	 *         }, 200);
	 *     },
	 *     two: function(callback) {
	 *         callback('two');
	 *     },
	 *     three: function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 'three');
	 *         }, 100);
	 *     }
	 * };
	 *
	 * async.parallel(async.reflectAll(tasks),
	 * // optional callback
	 * function(err, results) {
	 *     // values
	 *     // results.one.value = 'one'
	 *     // results.two.error = 'two'
	 *     // results.three.value = 'three'
	 * });
	 */
	function reflectAll(tasks) {
	    var results;
	    if (isArray(tasks)) {
	        results = arrayMap(tasks, reflect);
	    } else {
	        results = {};
	        baseForOwn(tasks, function (task, key) {
	            results[key] = reflect.call(this, task);
	        });
	    }
	    return results;
	}
	
	/**
	 * The same as [`reject`]{@link module:Collections.reject} but runs a maximum of `limit` async operations at a
	 * time.
	 *
	 * @name rejectLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.reject]{@link module:Collections.reject}
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
	 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
	 * with a boolean argument once it has completed. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Invoked with (err, results).
	 */
	var rejectLimit = doParallelLimit(reject$1);
	
	/**
	 * The same as [`reject`]{@link module:Collections.reject} but runs only a single async operation at a time.
	 *
	 * @name rejectSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.reject]{@link module:Collections.reject}
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
	 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
	 * with a boolean argument once it has completed. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Invoked with (err, results).
	 */
	var rejectSeries = doLimit(rejectLimit, 1);
	
	/**
	 * Creates a function that returns `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {*} value The value to return from the new function.
	 * @returns {Function} Returns the new constant function.
	 * @example
	 *
	 * var objects = _.times(2, _.constant({ 'a': 1 }));
	 *
	 * console.log(objects);
	 * // => [{ 'a': 1 }, { 'a': 1 }]
	 *
	 * console.log(objects[0] === objects[1]);
	 * // => true
	 */
	function constant$1(value) {
	  return function() {
	    return value;
	  };
	}
	
	/**
	 * Attempts to get a successful response from `task` no more than `times` times
	 * before returning an error. If the task is successful, the `callback` will be
	 * passed the result of the successful task. If all attempts fail, the callback
	 * will be passed the error and result (if any) of the final attempt.
	 *
	 * @name retry
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an
	 * object with `times` and `interval` or a number.
	 * * `times` - The number of attempts to make before giving up.  The default
	 *   is `5`.
	 * * `interval` - The time to wait between retries, in milliseconds.  The
	 *   default is `0`. The interval may also be specified as a function of the
	 *   retry count (see example).
	 * * `errorFilter` - An optional synchronous function that is invoked on
	 *   erroneous result. If it returns `true` the retry attempts will continue;
	 *   if the function returns `false` the retry flow is aborted with the current
	 *   attempt's error and result being returned to the final callback.
	 *   Invoked with (err).
	 * * If `opts` is a number, the number specifies the number of times to retry,
	 *   with the default interval of `0`.
	 * @param {Function} task - A function which receives two arguments: (1) a
	 * `callback(err, result)` which must be called when finished, passing `err`
	 * (which can be `null`) and the `result` of the function's execution, and (2)
	 * a `results` object, containing the results of the previously executed
	 * functions (if nested inside another control flow). Invoked with
	 * (callback, results).
	 * @param {Function} [callback] - An optional callback which is called when the
	 * task has succeeded, or after the final failed attempt. It receives the `err`
	 * and `result` arguments of the last attempt at completing the `task`. Invoked
	 * with (err, results).
	 * @example
	 *
	 * // The `retry` function can be used as a stand-alone control flow by passing
	 * // a callback, as shown below:
	 *
	 * // try calling apiMethod 3 times
	 * async.retry(3, apiMethod, function(err, result) {
	 *     // do something with the result
	 * });
	 *
	 * // try calling apiMethod 3 times, waiting 200 ms between each retry
	 * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {
	 *     // do something with the result
	 * });
	 *
	 * // try calling apiMethod 10 times with exponential backoff
	 * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)
	 * async.retry({
	 *   times: 10,
	 *   interval: function(retryCount) {
	 *     return 50 * Math.pow(2, retryCount);
	 *   }
	 * }, apiMethod, function(err, result) {
	 *     // do something with the result
	 * });
	 *
	 * // try calling apiMethod the default 5 times no delay between each retry
	 * async.retry(apiMethod, function(err, result) {
	 *     // do something with the result
	 * });
	 *
	 * // try calling apiMethod only when error condition satisfies, all other
	 * // errors will abort the retry control flow and return to final callback
	 * async.retry({
	 *   errorFilter: function(err) {
	 *     return err.message === 'Temporary error'; // only retry on a specific error
	 *   }
	 * }, apiMethod, function(err, result) {
	 *     // do something with the result
	 * });
	 *
	 * // It can also be embedded within other control flow functions to retry
	 * // individual methods that are not as reliable, like this:
	 * async.auto({
	 *     users: api.getUsers.bind(api),
	 *     payments: async.retry(3, api.getPayments.bind(api))
	 * }, function(err, results) {
	 *     // do something with the results
	 * });
	 *
	 */
	function retry(opts, task, callback) {
	    var DEFAULT_TIMES = 5;
	    var DEFAULT_INTERVAL = 0;
	
	    var options = {
	        times: DEFAULT_TIMES,
	        intervalFunc: constant$1(DEFAULT_INTERVAL)
	    };
	
	    function parseTimes(acc, t) {
	        if (typeof t === 'object') {
	            acc.times = +t.times || DEFAULT_TIMES;
	
	            acc.intervalFunc = typeof t.interval === 'function' ? t.interval : constant$1(+t.interval || DEFAULT_INTERVAL);
	
	            acc.errorFilter = t.errorFilter;
	        } else if (typeof t === 'number' || typeof t === 'string') {
	            acc.times = +t || DEFAULT_TIMES;
	        } else {
	            throw new Error("Invalid arguments for async.retry");
	        }
	    }
	
	    if (arguments.length < 3 && typeof opts === 'function') {
	        callback = task || noop;
	        task = opts;
	    } else {
	        parseTimes(options, opts);
	        callback = callback || noop;
	    }
	
	    if (typeof task !== 'function') {
	        throw new Error("Invalid arguments for async.retry");
	    }
	
	    var attempt = 1;
	    function retryAttempt() {
	        task(function (err) {
	            if (err && attempt++ < options.times && (typeof options.errorFilter != 'function' || options.errorFilter(err))) {
	                setTimeout(retryAttempt, options.intervalFunc(attempt));
	            } else {
	                callback.apply(null, arguments);
	            }
	        });
	    }
	
	    retryAttempt();
	}
	
	/**
	 * A close relative of [`retry`]{@link module:ControlFlow.retry}.  This method wraps a task and makes it
	 * retryable, rather than immediately calling it with retries.
	 *
	 * @name retryable
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.retry]{@link module:ControlFlow.retry}
	 * @category Control Flow
	 * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - optional
	 * options, exactly the same as from `retry`
	 * @param {Function} task - the asynchronous function to wrap
	 * @returns {Functions} The wrapped function, which when invoked, will retry on
	 * an error, based on the parameters specified in `opts`.
	 * @example
	 *
	 * async.auto({
	 *     dep1: async.retryable(3, getFromFlakyService),
	 *     process: ["dep1", async.retryable(3, function (results, cb) {
	 *         maybeProcessData(results.dep1, cb);
	 *     })]
	 * }, callback);
	 */
	var retryable = function (opts, task) {
	    if (!task) {
	        task = opts;
	        opts = null;
	    }
	    return initialParams(function (args, callback) {
	        function taskFn(cb) {
	            task.apply(null, args.concat(cb));
	        }
	
	        if (opts) retry(opts, taskFn, callback);else retry(taskFn, callback);
	    });
	};
	
	/**
	 * Run the functions in the `tasks` collection in series, each one running once
	 * the previous function has completed. If any functions in the series pass an
	 * error to its callback, no more functions are run, and `callback` is
	 * immediately called with the value of the error. Otherwise, `callback`
	 * receives an array of results when `tasks` have completed.
	 *
	 * It is also possible to use an object instead of an array. Each property will
	 * be run as a function, and the results will be passed to the final `callback`
	 * as an object instead of an array. This can be a more readable way of handling
	 *  results from {@link async.series}.
	 *
	 * **Note** that while many implementations preserve the order of object
	 * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)
	 * explicitly states that
	 *
	 * > The mechanics and order of enumerating the properties is not specified.
	 *
	 * So if you rely on the order in which your series of functions are executed,
	 * and want this to work on all platforms, consider using an array.
	 *
	 * @name series
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {Array|Iterable|Object} tasks - A collection containing functions to run, each
	 * function is passed a `callback(err, result)` it must call on completion with
	 * an error `err` (which can be `null`) and an optional `result` value.
	 * @param {Function} [callback] - An optional callback to run once all the
	 * functions have completed. This function gets a results array (or object)
	 * containing all the result arguments passed to the `task` callbacks. Invoked
	 * with (err, result).
	 * @example
	 * async.series([
	 *     function(callback) {
	 *         // do some stuff ...
	 *         callback(null, 'one');
	 *     },
	 *     function(callback) {
	 *         // do some more stuff ...
	 *         callback(null, 'two');
	 *     }
	 * ],
	 * // optional callback
	 * function(err, results) {
	 *     // results is now equal to ['one', 'two']
	 * });
	 *
	 * async.series({
	 *     one: function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 1);
	 *         }, 200);
	 *     },
	 *     two: function(callback){
	 *         setTimeout(function() {
	 *             callback(null, 2);
	 *         }, 100);
	 *     }
	 * }, function(err, results) {
	 *     // results is now equal to: {one: 1, two: 2}
	 * });
	 */
	function series(tasks, callback) {
	  _parallel(eachOfSeries, tasks, callback);
	}
	
	/**
	 * Returns `true` if at least one element in the `coll` satisfies an async test.
	 * If any iteratee call returns `true`, the main `callback` is immediately
	 * called.
	 *
	 * @name some
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @alias any
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A truth test to apply to each item in the array
	 * in parallel. The iteratee is passed a `callback(err, truthValue)` which must
	 * be called with a boolean argument once it has completed. Invoked with
	 * (item, callback).
	 * @param {Function} [callback] - A callback which is called as soon as any
	 * iteratee returns `true`, or after all the iteratee functions have finished.
	 * Result will be either `true` or `false` depending on the values of the async
	 * tests. Invoked with (err, result).
	 * @example
	 *
	 * async.some(['file1','file2','file3'], function(filePath, callback) {
	 *     fs.access(filePath, function(err) {
	 *         callback(null, !err)
	 *     });
	 * }, function(err, result) {
	 *     // if result is true then at least one of the files exists
	 * });
	 */
	var some = doParallel(_createTester(Boolean, identity));
	
	/**
	 * The same as [`some`]{@link module:Collections.some} but runs a maximum of `limit` async operations at a time.
	 *
	 * @name someLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.some]{@link module:Collections.some}
	 * @alias anyLimit
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {Function} iteratee - A truth test to apply to each item in the array
	 * in parallel. The iteratee is passed a `callback(err, truthValue)` which must
	 * be called with a boolean argument once it has completed. Invoked with
	 * (item, callback).
	 * @param {Function} [callback] - A callback which is called as soon as any
	 * iteratee returns `true`, or after all the iteratee functions have finished.
	 * Result will be either `true` or `false` depending on the values of the async
	 * tests. Invoked with (err, result).
	 */
	var someLimit = doParallelLimit(_createTester(Boolean, identity));
	
	/**
	 * The same as [`some`]{@link module:Collections.some} but runs only a single async operation at a time.
	 *
	 * @name someSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.some]{@link module:Collections.some}
	 * @alias anySeries
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A truth test to apply to each item in the array
	 * in parallel. The iteratee is passed a `callback(err, truthValue)` which must
	 * be called with a boolean argument once it has completed. Invoked with
	 * (item, callback).
	 * @param {Function} [callback] - A callback which is called as soon as any
	 * iteratee returns `true`, or after all the iteratee functions have finished.
	 * Result will be either `true` or `false` depending on the values of the async
	 * tests. Invoked with (err, result).
	 */
	var someSeries = doLimit(someLimit, 1);
	
	/**
	 * Sorts a list by the results of running each `coll` value through an async
	 * `iteratee`.
	 *
	 * @name sortBy
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each item in `coll`.
	 * The iteratee is passed a `callback(err, sortValue)` which must be called once
	 * it has completed with an error (which can be `null`) and a value to use as
	 * the sort criteria. Invoked with (item, callback).
	 * @param {Function} callback - A callback which is called after all the
	 * `iteratee` functions have finished, or an error occurs. Results is the items
	 * from the original `coll` sorted by the values returned by the `iteratee`
	 * calls. Invoked with (err, results).
	 * @example
	 *
	 * async.sortBy(['file1','file2','file3'], function(file, callback) {
	 *     fs.stat(file, function(err, stats) {
	 *         callback(err, stats.mtime);
	 *     });
	 * }, function(err, results) {
	 *     // results is now the original array of files sorted by
	 *     // modified date
	 * });
	 *
	 * // By modifying the callback parameter the
	 * // sorting order can be influenced:
	 *
	 * // ascending order
	 * async.sortBy([1,9,3,5], function(x, callback) {
	 *     callback(null, x);
	 * }, function(err,result) {
	 *     // result callback
	 * });
	 *
	 * // descending order
	 * async.sortBy([1,9,3,5], function(x, callback) {
	 *     callback(null, x*-1);    //<- x*-1 instead of x, turns the order around
	 * }, function(err,result) {
	 *     // result callback
	 * });
	 */
	function sortBy(coll, iteratee, callback) {
	    map(coll, function (x, callback) {
	        iteratee(x, function (err, criteria) {
	            if (err) return callback(err);
	            callback(null, { value: x, criteria: criteria });
	        });
	    }, function (err, results) {
	        if (err) return callback(err);
	        callback(null, arrayMap(results.sort(comparator), baseProperty('value')));
	    });
	
	    function comparator(left, right) {
	        var a = left.criteria,
	            b = right.criteria;
	        return a < b ? -1 : a > b ? 1 : 0;
	    }
	}
	
	/**
	 * Sets a time limit on an asynchronous function. If the function does not call
	 * its callback within the specified milliseconds, it will be called with a
	 * timeout error. The code property for the error object will be `'ETIMEDOUT'`.
	 *
	 * @name timeout
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @category Util
	 * @param {Function} asyncFn - The asynchronous function you want to set the
	 * time limit.
	 * @param {number} milliseconds - The specified time limit.
	 * @param {*} [info] - Any variable you want attached (`string`, `object`, etc)
	 * to timeout Error for more information..
	 * @returns {Function} Returns a wrapped function that can be used with any of
	 * the control flow functions. Invoke this function with the same
	 * parameters as you would `asyncFunc`.
	 * @example
	 *
	 * function myFunction(foo, callback) {
	 *     doAsyncTask(foo, function(err, data) {
	 *         // handle errors
	 *         if (err) return callback(err);
	 *
	 *         // do some stuff ...
	 *
	 *         // return processed data
	 *         return callback(null, data);
	 *     });
	 * }
	 *
	 * var wrapped = async.timeout(myFunction, 1000);
	 *
	 * // call `wrapped` as you would `myFunction`
	 * wrapped({ bar: 'bar' }, function(err, data) {
	 *     // if `myFunction` takes < 1000 ms to execute, `err`
	 *     // and `data` will have their expected values
	 *
	 *     // else `err` will be an Error with the code 'ETIMEDOUT'
	 * });
	 */
	function timeout(asyncFn, milliseconds, info) {
	    var originalCallback, timer;
	    var timedOut = false;
	
	    function injectedCallback() {
	        if (!timedOut) {
	            originalCallback.apply(null, arguments);
	            clearTimeout(timer);
	        }
	    }
	
	    function timeoutCallback() {
	        var name = asyncFn.name || 'anonymous';
	        var error = new Error('Callback function "' + name + '" timed out.');
	        error.code = 'ETIMEDOUT';
	        if (info) {
	            error.info = info;
	        }
	        timedOut = true;
	        originalCallback(error);
	    }
	
	    return initialParams(function (args, origCallback) {
	        originalCallback = origCallback;
	        // setup timer and call original function
	        timer = setTimeout(timeoutCallback, milliseconds);
	        asyncFn.apply(null, args.concat(injectedCallback));
	    });
	}
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeCeil = Math.ceil;
	var nativeMax$1 = Math.max;
	
	/**
	 * The base implementation of `_.range` and `_.rangeRight` which doesn't
	 * coerce arguments.
	 *
	 * @private
	 * @param {number} start The start of the range.
	 * @param {number} end The end of the range.
	 * @param {number} step The value to increment or decrement by.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Array} Returns the range of numbers.
	 */
	function baseRange(start, end, step, fromRight) {
	  var index = -1,
	      length = nativeMax$1(nativeCeil((end - start) / (step || 1)), 0),
	      result = Array(length);
	
	  while (length--) {
	    result[fromRight ? length : ++index] = start;
	    start += step;
	  }
	  return result;
	}
	
	/**
	 * The same as [times]{@link module:ControlFlow.times} but runs a maximum of `limit` async operations at a
	 * time.
	 *
	 * @name timesLimit
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.times]{@link module:ControlFlow.times}
	 * @category Control Flow
	 * @param {number} count - The number of times to run the function.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {Function} iteratee - The function to call `n` times. Invoked with the
	 * iteration index and a callback (n, next).
	 * @param {Function} callback - see [async.map]{@link module:Collections.map}.
	 */
	function timeLimit(count, limit, iteratee, callback) {
	  mapLimit(baseRange(0, count, 1), limit, iteratee, callback);
	}
	
	/**
	 * Calls the `iteratee` function `n` times, and accumulates results in the same
	 * manner you would use with [map]{@link module:Collections.map}.
	 *
	 * @name times
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.map]{@link module:Collections.map}
	 * @category Control Flow
	 * @param {number} n - The number of times to run the function.
	 * @param {Function} iteratee - The function to call `n` times. Invoked with the
	 * iteration index and a callback (n, next).
	 * @param {Function} callback - see {@link module:Collections.map}.
	 * @example
	 *
	 * // Pretend this is some complicated async factory
	 * var createUser = function(id, callback) {
	 *     callback(null, {
	 *         id: 'user' + id
	 *     });
	 * };
	 *
	 * // generate 5 users
	 * async.times(5, function(n, next) {
	 *     createUser(n, function(err, user) {
	 *         next(err, user);
	 *     });
	 * }, function(err, users) {
	 *     // we should now have 5 users
	 * });
	 */
	var times = doLimit(timeLimit, Infinity);
	
	/**
	 * The same as [times]{@link module:ControlFlow.times} but runs only a single async operation at a time.
	 *
	 * @name timesSeries
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.times]{@link module:ControlFlow.times}
	 * @category Control Flow
	 * @param {number} n - The number of times to run the function.
	 * @param {Function} iteratee - The function to call `n` times. Invoked with the
	 * iteration index and a callback (n, next).
	 * @param {Function} callback - see {@link module:Collections.map}.
	 */
	var timesSeries = doLimit(timeLimit, 1);
	
	/**
	 * A relative of `reduce`.  Takes an Object or Array, and iterates over each
	 * element in series, each step potentially mutating an `accumulator` value.
	 * The type of the accumulator defaults to the type of collection passed in.
	 *
	 * @name transform
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {*} [accumulator] - The initial state of the transform.  If omitted,
	 * it will default to an empty Object or Array, depending on the type of `coll`
	 * @param {Function} iteratee - A function applied to each item in the
	 * collection that potentially modifies the accumulator. The `iteratee` is
	 * passed a `callback(err)` which accepts an optional error as its first
	 * argument. If an error is passed to the callback, the transform is stopped
	 * and the main `callback` is immediately called with the error.
	 * Invoked with (accumulator, item, key, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Result is the transformed accumulator.
	 * Invoked with (err, result).
	 * @example
	 *
	 * async.transform([1,2,3], function(acc, item, index, callback) {
	 *     // pointless async:
	 *     process.nextTick(function() {
	 *         acc.push(item * 2)
	 *         callback(null)
	 *     });
	 * }, function(err, result) {
	 *     // result is now equal to [2, 4, 6]
	 * });
	 *
	 * @example
	 *
	 * async.transform({a: 1, b: 2, c: 3}, function (obj, val, key, callback) {
	 *     setImmediate(function () {
	 *         obj[key] = val * 2;
	 *         callback();
	 *     })
	 * }, function (err, result) {
	 *     // result is equal to {a: 2, b: 4, c: 6}
	 * })
	 */
	function transform(coll, accumulator, iteratee, callback) {
	    if (arguments.length === 3) {
	        callback = iteratee;
	        iteratee = accumulator;
	        accumulator = isArray(coll) ? [] : {};
	    }
	    callback = once(callback || noop);
	
	    eachOf(coll, function (v, k, cb) {
	        iteratee(accumulator, v, k, cb);
	    }, function (err) {
	        callback(err, accumulator);
	    });
	}
	
	/**
	 * Undoes a [memoize]{@link module:Utils.memoize}d function, reverting it to the original,
	 * unmemoized form. Handy for testing.
	 *
	 * @name unmemoize
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @see [async.memoize]{@link module:Utils.memoize}
	 * @category Util
	 * @param {Function} fn - the memoized function
	 * @returns {Function} a function that calls the original unmemoized function
	 */
	function unmemoize(fn) {
	    return function () {
	        return (fn.unmemoized || fn).apply(null, arguments);
	    };
	}
	
	/**
	 * Repeatedly call `iteratee`, while `test` returns `true`. Calls `callback` when
	 * stopped, or an error occurs.
	 *
	 * @name whilst
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {Function} test - synchronous truth test to perform before each
	 * execution of `iteratee`. Invoked with ().
	 * @param {Function} iteratee - A function which is called each time `test` passes.
	 * The function is passed a `callback(err)`, which must be called once it has
	 * completed with an optional `err` argument. Invoked with (callback).
	 * @param {Function} [callback] - A callback which is called after the test
	 * function has failed and repeated execution of `iteratee` has stopped. `callback`
	 * will be passed an error and any arguments passed to the final `iteratee`'s
	 * callback. Invoked with (err, [results]);
	 * @returns undefined
	 * @example
	 *
	 * var count = 0;
	 * async.whilst(
	 *     function() { return count < 5; },
	 *     function(callback) {
	 *         count++;
	 *         setTimeout(function() {
	 *             callback(null, count);
	 *         }, 1000);
	 *     },
	 *     function (err, n) {
	 *         // 5 seconds have passed, n = 5
	 *     }
	 * );
	 */
	function whilst(test, iteratee, callback) {
	    callback = onlyOnce(callback || noop);
	    if (!test()) return callback(null);
	    var next = rest(function (err, args) {
	        if (err) return callback(err);
	        if (test()) return iteratee(next);
	        callback.apply(null, [null].concat(args));
	    });
	    iteratee(next);
	}
	
	/**
	 * Repeatedly call `fn` until `test` returns `true`. Calls `callback` when
	 * stopped, or an error occurs. `callback` will be passed an error and any
	 * arguments passed to the final `fn`'s callback.
	 *
	 * The inverse of [whilst]{@link module:ControlFlow.whilst}.
	 *
	 * @name until
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.whilst]{@link module:ControlFlow.whilst}
	 * @category Control Flow
	 * @param {Function} test - synchronous truth test to perform before each
	 * execution of `fn`. Invoked with ().
	 * @param {Function} fn - A function which is called each time `test` fails.
	 * The function is passed a `callback(err)`, which must be called once it has
	 * completed with an optional `err` argument. Invoked with (callback).
	 * @param {Function} [callback] - A callback which is called after the test
	 * function has passed and repeated execution of `fn` has stopped. `callback`
	 * will be passed an error and any arguments passed to the final `fn`'s
	 * callback. Invoked with (err, [results]);
	 */
	function until(test, fn, callback) {
	    whilst(function () {
	        return !test.apply(this, arguments);
	    }, fn, callback);
	}
	
	/**
	 * Runs the `tasks` array of functions in series, each passing their results to
	 * the next in the array. However, if any of the `tasks` pass an error to their
	 * own callback, the next function is not executed, and the main `callback` is
	 * immediately called with the error.
	 *
	 * @name waterfall
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {Array} tasks - An array of functions to run, each function is passed
	 * a `callback(err, result1, result2, ...)` it must call on completion. The
	 * first argument is an error (which can be `null`) and any further arguments
	 * will be passed as arguments in order to the next task.
	 * @param {Function} [callback] - An optional callback to run once all the
	 * functions have completed. This will be passed the results of the last task's
	 * callback. Invoked with (err, [results]).
	 * @returns undefined
	 * @example
	 *
	 * async.waterfall([
	 *     function(callback) {
	 *         callback(null, 'one', 'two');
	 *     },
	 *     function(arg1, arg2, callback) {
	 *         // arg1 now equals 'one' and arg2 now equals 'two'
	 *         callback(null, 'three');
	 *     },
	 *     function(arg1, callback) {
	 *         // arg1 now equals 'three'
	 *         callback(null, 'done');
	 *     }
	 * ], function (err, result) {
	 *     // result now equals 'done'
	 * });
	 *
	 * // Or, with named functions:
	 * async.waterfall([
	 *     myFirstFunction,
	 *     mySecondFunction,
	 *     myLastFunction,
	 * ], function (err, result) {
	 *     // result now equals 'done'
	 * });
	 * function myFirstFunction(callback) {
	 *     callback(null, 'one', 'two');
	 * }
	 * function mySecondFunction(arg1, arg2, callback) {
	 *     // arg1 now equals 'one' and arg2 now equals 'two'
	 *     callback(null, 'three');
	 * }
	 * function myLastFunction(arg1, callback) {
	 *     // arg1 now equals 'three'
	 *     callback(null, 'done');
	 * }
	 */
	var waterfall = function (tasks, callback) {
	    callback = once(callback || noop);
	    if (!isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));
	    if (!tasks.length) return callback();
	    var taskIndex = 0;
	
	    function nextTask(args) {
	        if (taskIndex === tasks.length) {
	            return callback.apply(null, [null].concat(args));
	        }
	
	        var taskCallback = onlyOnce(rest(function (err, args) {
	            if (err) {
	                return callback.apply(null, [err].concat(args));
	            }
	            nextTask(args);
	        }));
	
	        args.push(taskCallback);
	
	        var task = tasks[taskIndex++];
	        task.apply(null, args);
	    }
	
	    nextTask([]);
	};
	
	/**
	 * Async is a utility module which provides straight-forward, powerful functions
	 * for working with asynchronous JavaScript. Although originally designed for
	 * use with [Node.js](http://nodejs.org) and installable via
	 * `npm install --save async`, it can also be used directly in the browser.
	 * @module async
	 */
	
	/**
	 * A collection of `async` functions for manipulating collections, such as
	 * arrays and objects.
	 * @module Collections
	 */
	
	/**
	 * A collection of `async` functions for controlling the flow through a script.
	 * @module ControlFlow
	 */
	
	/**
	 * A collection of `async` utility functions.
	 * @module Utils
	 */
	var index = {
	  applyEach: applyEach,
	  applyEachSeries: applyEachSeries,
	  apply: apply$2,
	  asyncify: asyncify,
	  auto: auto,
	  autoInject: autoInject,
	  cargo: cargo,
	  compose: compose,
	  concat: concat,
	  concatSeries: concatSeries,
	  constant: constant,
	  detect: detect,
	  detectLimit: detectLimit,
	  detectSeries: detectSeries,
	  dir: dir,
	  doDuring: doDuring,
	  doUntil: doUntil,
	  doWhilst: doWhilst,
	  during: during,
	  each: eachLimit,
	  eachLimit: eachLimit$1,
	  eachOf: eachOf,
	  eachOfLimit: eachOfLimit,
	  eachOfSeries: eachOfSeries,
	  eachSeries: eachSeries,
	  ensureAsync: ensureAsync,
	  every: every,
	  everyLimit: everyLimit,
	  everySeries: everySeries,
	  filter: filter,
	  filterLimit: filterLimit,
	  filterSeries: filterSeries,
	  forever: forever,
	  log: log,
	  map: map,
	  mapLimit: mapLimit,
	  mapSeries: mapSeries,
	  mapValues: mapValues,
	  mapValuesLimit: mapValuesLimit,
	  mapValuesSeries: mapValuesSeries,
	  memoize: memoize,
	  nextTick: nextTick,
	  parallel: parallelLimit,
	  parallelLimit: parallelLimit$1,
	  priorityQueue: priorityQueue,
	  queue: queue$1,
	  race: race,
	  reduce: reduce,
	  reduceRight: reduceRight,
	  reflect: reflect,
	  reflectAll: reflectAll,
	  reject: reject,
	  rejectLimit: rejectLimit,
	  rejectSeries: rejectSeries,
	  retry: retry,
	  retryable: retryable,
	  seq: seq$1,
	  series: series,
	  setImmediate: setImmediate$1,
	  some: some,
	  someLimit: someLimit,
	  someSeries: someSeries,
	  sortBy: sortBy,
	  timeout: timeout,
	  times: times,
	  timesLimit: timeLimit,
	  timesSeries: timesSeries,
	  transform: transform,
	  unmemoize: unmemoize,
	  until: until,
	  waterfall: waterfall,
	  whilst: whilst,
	
	  // aliases
	  all: every,
	  any: some,
	  forEach: eachLimit,
	  forEachSeries: eachSeries,
	  forEachLimit: eachLimit$1,
	  forEachOf: eachOf,
	  forEachOfSeries: eachOfSeries,
	  forEachOfLimit: eachOfLimit,
	  inject: reduce,
	  foldl: reduce,
	  foldr: reduceRight,
	  select: filter,
	  selectLimit: filterLimit,
	  selectSeries: filterSeries,
	  wrapSync: asyncify
	};
	
	exports['default'] = index;
	exports.applyEach = applyEach;
	exports.applyEachSeries = applyEachSeries;
	exports.apply = apply$2;
	exports.asyncify = asyncify;
	exports.auto = auto;
	exports.autoInject = autoInject;
	exports.cargo = cargo;
	exports.compose = compose;
	exports.concat = concat;
	exports.concatSeries = concatSeries;
	exports.constant = constant;
	exports.detect = detect;
	exports.detectLimit = detectLimit;
	exports.detectSeries = detectSeries;
	exports.dir = dir;
	exports.doDuring = doDuring;
	exports.doUntil = doUntil;
	exports.doWhilst = doWhilst;
	exports.during = during;
	exports.each = eachLimit;
	exports.eachLimit = eachLimit$1;
	exports.eachOf = eachOf;
	exports.eachOfLimit = eachOfLimit;
	exports.eachOfSeries = eachOfSeries;
	exports.eachSeries = eachSeries;
	exports.ensureAsync = ensureAsync;
	exports.every = every;
	exports.everyLimit = everyLimit;
	exports.everySeries = everySeries;
	exports.filter = filter;
	exports.filterLimit = filterLimit;
	exports.filterSeries = filterSeries;
	exports.forever = forever;
	exports.log = log;
	exports.map = map;
	exports.mapLimit = mapLimit;
	exports.mapSeries = mapSeries;
	exports.mapValues = mapValues;
	exports.mapValuesLimit = mapValuesLimit;
	exports.mapValuesSeries = mapValuesSeries;
	exports.memoize = memoize;
	exports.nextTick = nextTick;
	exports.parallel = parallelLimit;
	exports.parallelLimit = parallelLimit$1;
	exports.priorityQueue = priorityQueue;
	exports.queue = queue$1;
	exports.race = race;
	exports.reduce = reduce;
	exports.reduceRight = reduceRight;
	exports.reflect = reflect;
	exports.reflectAll = reflectAll;
	exports.reject = reject;
	exports.rejectLimit = rejectLimit;
	exports.rejectSeries = rejectSeries;
	exports.retry = retry;
	exports.retryable = retryable;
	exports.seq = seq$1;
	exports.series = series;
	exports.setImmediate = setImmediate$1;
	exports.some = some;
	exports.someLimit = someLimit;
	exports.someSeries = someSeries;
	exports.sortBy = sortBy;
	exports.timeout = timeout;
	exports.times = times;
	exports.timesLimit = timeLimit;
	exports.timesSeries = timesSeries;
	exports.transform = transform;
	exports.unmemoize = unmemoize;
	exports.until = until;
	exports.waterfall = waterfall;
	exports.whilst = whilst;
	exports.all = every;
	exports.allLimit = everyLimit;
	exports.allSeries = everySeries;
	exports.any = some;
	exports.anyLimit = someLimit;
	exports.anySeries = someSeries;
	exports.find = detect;
	exports.findLimit = detectLimit;
	exports.findSeries = detectSeries;
	exports.forEach = eachLimit;
	exports.forEachSeries = eachSeries;
	exports.forEachLimit = eachLimit$1;
	exports.forEachOf = eachOf;
	exports.forEachOfSeries = eachOfSeries;
	exports.forEachOfLimit = eachOfLimit;
	exports.inject = reduce;
	exports.foldl = reduce;
	exports.foldr = reduceRight;
	exports.select = filter;
	exports.selectLimit = filterLimit;
	exports.selectSeries = filterSeries;
	exports.wrapSync = asyncify;
	
	Object.defineProperty(exports, '__esModule', { value: true });
	
	})));
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(952)(module), __webpack_require__(702).setImmediate, __webpack_require__(294)))

/***/ },

/***/ 1268:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/* Copyright (c) 2012-2016 LevelUP contributors
	 * See list at <https://github.com/level/levelup#contributing>
	 * MIT License
	 * <https://github.com/level/levelup/blob/master/LICENSE.md>
	 */
	
	var EventEmitter        = __webpack_require__(786).EventEmitter
	  , inherits            = __webpack_require__(1130).inherits
	  , deprecate           = __webpack_require__(1130).deprecate
	  , extend              = __webpack_require__(859)
	  , prr                 = __webpack_require__(1250)
	  , DeferredLevelDOWN   = __webpack_require__(1251)
	  , IteratorStream      = __webpack_require__(1258)
	
	  , errors              = __webpack_require__(1259)
	  , WriteError          = errors.WriteError
	  , ReadError           = errors.ReadError
	  , NotFoundError       = errors.NotFoundError
	  , OpenError           = errors.OpenError
	  , EncodingError       = errors.EncodingError
	  , InitializationError = errors.InitializationError
	
	  , util                = __webpack_require__(1269)
	  , Batch               = __webpack_require__(1274)
	  , Codec               = __webpack_require__(1266)
	
	  , getOptions          = util.getOptions
	  , defaultOptions      = util.defaultOptions
	  , getLevelDOWN        = util.getLevelDOWN
	  , dispatchError       = util.dispatchError
	  , isDefined           = util.isDefined
	
	function getCallback (options, callback) {
	  return typeof options == 'function' ? options : callback
	}
	
	// Possible LevelUP#_status values:
	//  - 'new'     - newly created, not opened or closed
	//  - 'opening' - waiting for the database to be opened, post open()
	//  - 'open'    - successfully opened the database, available for use
	//  - 'closing' - waiting for the database to be closed, post close()
	//  - 'closed'  - database has been successfully closed, should not be
	//                 used except for another open() operation
	
	function LevelUP (location, options, callback) {
	  if (!(this instanceof LevelUP))
	    return new LevelUP(location, options, callback)
	
	  var error
	
	  EventEmitter.call(this)
	  this.setMaxListeners(Infinity)
	
	  if (typeof location == 'function') {
	    options = typeof options == 'object' ? options : {}
	    options.db = location
	    location = null
	  } else if (typeof location == 'object' && typeof location.db == 'function') {
	    options = location
	    location = null
	  }
	
	
	  if (typeof options == 'function') {
	    callback = options
	    options  = {}
	  }
	
	  if ((!options || typeof options.db != 'function') && typeof location != 'string') {
	    error = new InitializationError(
	        'Must provide a location for the database')
	    if (callback) {
	      return process.nextTick(function () {
	        callback(error)
	      })
	    }
	    throw error
	  }
	
	  options      = getOptions(options)
	  this.options = extend(defaultOptions, options)
	  this._codec = new Codec(this.options)
	  this._status = 'new'
	  // set this.location as enumerable but not configurable or writable
	  prr(this, 'location', location, 'e')
	
	  this.open(callback)
	}
	
	inherits(LevelUP, EventEmitter)
	
	LevelUP.prototype.open = function (callback) {
	  var self = this
	    , dbFactory
	    , db
	
	  if (this.isOpen()) {
	    if (callback)
	      process.nextTick(function () { callback(null, self) })
	    return this
	  }
	
	  if (this._isOpening()) {
	    return callback && this.once(
	        'open'
	      , function () { callback(null, self) }
	    )
	  }
	
	  this.emit('opening')
	
	  this._status = 'opening'
	  this.db      = new DeferredLevelDOWN(this.location)
	  dbFactory    = this.options.db || getLevelDOWN()
	  db           = dbFactory(this.location)
	
	  db.open(this.options, function (err) {
	    if (err) {
	      return dispatchError(self, new OpenError(err), callback)
	    } else {
	      self.db.setDb(db)
	      self.db = db
	      self._status = 'open'
	      if (callback)
	        callback(null, self)
	      self.emit('open')
	      self.emit('ready')
	    }
	  })
	}
	
	LevelUP.prototype.close = function (callback) {
	  var self = this
	
	  if (this.isOpen()) {
	    this._status = 'closing'
	    this.db.close(function () {
	      self._status = 'closed'
	      self.emit('closed')
	      if (callback)
	        callback.apply(null, arguments)
	    })
	    this.emit('closing')
	    this.db = new DeferredLevelDOWN(this.location)
	  } else if (this._status == 'closed' && callback) {
	    return process.nextTick(callback)
	  } else if (this._status == 'closing' && callback) {
	    this.once('closed', callback)
	  } else if (this._isOpening()) {
	    this.once('open', function () {
	      self.close(callback)
	    })
	  }
	}
	
	LevelUP.prototype.isOpen = function () {
	  return this._status == 'open'
	}
	
	LevelUP.prototype._isOpening = function () {
	  return this._status == 'opening'
	}
	
	LevelUP.prototype.isClosed = function () {
	  return (/^clos/).test(this._status)
	}
	
	function maybeError(db, options, callback) {
	  if (!db._isOpening() && !db.isOpen()) {
	    dispatchError(
	        db
	      , new ReadError('Database is not open')
	      , callback
	    )
	    return true
	  }
	}
	
	function writeError (db, message, callback) {
	  dispatchError(
	      db
	     , new WriteError(message)
	     , callback
	  )
	}
	
	function readError (db, message, callback) {
	  dispatchError(
	      db
	     , new ReadError(message)
	     , callback
	  )
	}
	
	
	LevelUP.prototype.get = function (key_, options, callback) {
	  var self = this
	    , key
	
	  callback = getCallback(options, callback)
	
	  if (maybeError(this, options, callback))
	    return
	
	  if (key_ === null || key_ === undefined || 'function' !== typeof callback)
	    return readError(this
	      , 'get() requires key and callback arguments', callback)
	
	  options = util.getOptions(options)
	  key = this._codec.encodeKey(key_, options)
	
	  options.asBuffer = this._codec.valueAsBuffer(options)
	
	  this.db.get(key, options, function (err, value) {
	    if (err) {
	      if ((/notfound/i).test(err) || err.notFound) {
	        err = new NotFoundError(
	            'Key not found in database [' + key_ + ']', err)
	      } else {
	        err = new ReadError(err)
	      }
	      return dispatchError(self, err, callback)
	    }
	    if (callback) {
	      try {
	        value = self._codec.decodeValue(value, options)
	      } catch (e) {
	        return callback(new EncodingError(e))
	      }
	      callback(null, value)
	    }
	  })
	}
	
	LevelUP.prototype.put = function (key_, value_, options, callback) {
	  var self = this
	    , key
	    , value
	
	  callback = getCallback(options, callback)
	
	  if (key_ === null || key_ === undefined)
	    return writeError(this, 'put() requires a key argument', callback)
	
	  if (maybeError(this, options, callback))
	    return
	
	  options = getOptions(options)
	  key     = this._codec.encodeKey(key_, options)
	  value   = this._codec.encodeValue(value_, options)
	
	  this.db.put(key, value, options, function (err) {
	    if (err) {
	      return dispatchError(self, new WriteError(err), callback)
	    } else {
	      self.emit('put', key_, value_)
	      if (callback)
	        callback()
	    }
	  })
	}
	
	LevelUP.prototype.del = function (key_, options, callback) {
	  var self = this
	    , key
	
	  callback = getCallback(options, callback)
	
	  if (key_ === null || key_ === undefined)
	    return writeError(this, 'del() requires a key argument', callback)
	
	  if (maybeError(this, options, callback))
	    return
	
	  options = getOptions(options)
	  key     = this._codec.encodeKey(key_, options)
	
	  this.db.del(key, options, function (err) {
	    if (err) {
	      return dispatchError(self, new WriteError(err), callback)
	    } else {
	      self.emit('del', key_)
	      if (callback)
	        callback()
	    }
	  })
	}
	
	LevelUP.prototype.batch = function (arr_, options, callback) {
	  var self = this
	    , keyEnc
	    , valueEnc
	    , arr
	
	  if (!arguments.length)
	    return new Batch(this, this._codec)
	
	  callback = getCallback(options, callback)
	
	  if (!Array.isArray(arr_))
	    return writeError(this, 'batch() requires an array argument', callback)
	
	  if (maybeError(this, options, callback))
	    return
	
	  options  = getOptions(options)
	  arr      = self._codec.encodeBatch(arr_, options)
	  arr      = arr.map(function (op) {
	    if (!op.type && op.key !== undefined && op.value !== undefined)
	      op.type = 'put'
	    return op
	  })
	
	  this.db.batch(arr, options, function (err) {
	    if (err) {
	      return dispatchError(self, new WriteError(err), callback)
	    } else {
	      self.emit('batch', arr_)
	      if (callback)
	        callback()
	    }
	  })
	}
	
	LevelUP.prototype.approximateSize = deprecate(function (start_, end_, options, callback) {   
	  var self = this    
	    , start    
	    , end    
	   
	  callback = getCallback(options, callback)    
	   
	  options = getOptions(options)    
	   
	  if (start_ === null || start_ === undefined    
	        || end_ === null || end_ === undefined || 'function' !== typeof callback)    
	    return readError(this, 'approximateSize() requires start, end and callback arguments', callback)   
	   
	  start = this._codec.encodeKey(start_, options)   
	  end   = this._codec.encodeKey(end_, options)   
	   
	  this.db.approximateSize(start, end, function (err, size) {   
	    if (err) {   
	      return dispatchError(self, new OpenError(err), callback)   
	    } else if (callback) {   
	      callback(null, size)   
	    }    
	  })   
	}, 'db.approximateSize() is deprecated. Use db.db.approximateSize() instead')
	
	LevelUP.prototype.readStream =
	LevelUP.prototype.createReadStream = function (options) {
	  options = extend( {keys: true, values: true}, this.options, options)
	
	  options.keyEncoding   = options.keyEncoding
	  options.valueEncoding = options.valueEncoding
	
	  options = this._codec.encodeLtgt(options);
	  options.keyAsBuffer   = this._codec.keyAsBuffer(options)
	  options.valueAsBuffer = this._codec.valueAsBuffer(options)
	
	  if ('number' !== typeof options.limit)
	    options.limit = -1
	
	  return new IteratorStream(this.db.iterator(options), extend(options, {
	    decoder: this._codec.createStreamDecoder(options)
	  }))
	}
	
	LevelUP.prototype.keyStream =
	LevelUP.prototype.createKeyStream = function (options) {
	  return this.createReadStream(extend(options, { keys: true, values: false }))
	}
	
	LevelUP.prototype.valueStream =
	LevelUP.prototype.createValueStream = function (options) {
	  return this.createReadStream(extend(options, { keys: false, values: true }))
	}
	
	LevelUP.prototype.toString = function () {
	  return 'LevelUP'
	}
	
	function utilStatic (name) {
	  return function (location, callback) {
	    getLevelDOWN()[name](location, callback || function () {})
	  }
	}
	
	module.exports         = LevelUP
	module.exports.errors  = __webpack_require__(1259)
	module.exports.destroy = deprecate(
	    utilStatic('destroy')
	  , 'levelup.destroy() is deprecated. Use leveldown.destroy() instead'
	)
	module.exports.repair  = deprecate(
	    utilStatic('repair')
	  , 'levelup.repair() is deprecated. Use leveldown.repair() instead'
	)
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(294)))

/***/ },

/***/ 1269:
/***/ function(module, exports, __webpack_require__) {

	/* Copyright (c) 2012-2016 LevelUP contributors
	 * See list at <https://github.com/level/levelup#contributing>
	 * MIT License
	 * <https://github.com/level/levelup/blob/master/LICENSE.md>
	 */
	
	var extend         = __webpack_require__(859)
	  , LevelUPError   = __webpack_require__(1259).LevelUPError
	  , format         = __webpack_require__(1130).format
	  , defaultOptions = {
	        createIfMissing : true
	      , errorIfExists   : false
	      , keyEncoding     : 'utf8'
	      , valueEncoding   : 'utf8'
	      , compression     : true
	    }
	
	  , leveldown
	
	function getOptions (options) {
	  if (typeof options == 'string')
	    options = { valueEncoding: options }
	  if (typeof options != 'object')
	    options = {}
	  return options
	}
	
	function getLevelDOWN () {
	  if (leveldown)
	    return leveldown
	
	  var requiredVersion  = __webpack_require__(1270).devDependencies.leveldown
	    , leveldownVersion
	
	  try {
	    leveldownVersion = __webpack_require__(1271).version
	  } catch (e) {
	    throw requireError(e)
	  }
	
	  if (!__webpack_require__(1272).satisfies(leveldownVersion, requiredVersion)) {
	    throw new LevelUPError(
	        'Installed version of LevelDOWN ('
	      + leveldownVersion
	      + ') does not match required version ('
	      + requiredVersion
	      + ')'
	    )
	  }
	
	  try {
	    return leveldown = __webpack_require__(1273)
	  } catch (e) {
	    throw requireError(e)
	  }
	}
	
	function requireError (e) {
	  var template = 'Failed to require LevelDOWN (%s). Try `npm install leveldown` if it\'s missing'
	  return new LevelUPError(format(template, e.message))
	}
	
	function dispatchError (db, error, callback) {
	  typeof callback == 'function' ? callback(error) : db.emit('error', error)
	}
	
	function isDefined (v) {
	  return typeof v !== 'undefined'
	}
	
	module.exports = {
	    defaultOptions  : defaultOptions
	  , getOptions      : getOptions
	  , getLevelDOWN    : getLevelDOWN
	  , dispatchError   : dispatchError
	  , isDefined       : isDefined
	}


/***/ },

/***/ 1270:
/***/ function(module, exports) {

	module.exports = {
		"_args": [
			[
				{
					"raw": "levelup@https://registry.npmjs.org/levelup/-/levelup-1.3.3.tgz",
					"scope": null,
					"escapedName": "levelup",
					"name": "levelup",
					"rawSpec": "https://registry.npmjs.org/levelup/-/levelup-1.3.3.tgz",
					"spec": "https://registry.npmjs.org/levelup/-/levelup-1.3.3.tgz",
					"type": "remote"
				},
				"/Users/tenaciousmv/Code/tradle-app-web/node_modules/@tradle/engine"
			]
		],
		"_from": "levelup@>=1.3.1 <2.0.0",
		"_id": "levelup@1.3.3",
		"_inCache": true,
		"_location": "/@tradle/engine/levelup",
		"_phantomChildren": {},
		"_requested": {
			"raw": "levelup@https://registry.npmjs.org/levelup/-/levelup-1.3.3.tgz",
			"scope": null,
			"escapedName": "levelup",
			"name": "levelup",
			"rawSpec": "https://registry.npmjs.org/levelup/-/levelup-1.3.3.tgz",
			"spec": "https://registry.npmjs.org/levelup/-/levelup-1.3.3.tgz",
			"type": "remote"
		},
		"_requiredBy": [
			"/@tradle/engine"
		],
		"_resolved": "https://registry.npmjs.org/levelup/-/levelup-1.3.3.tgz",
		"_shasum": "bf9db62bdb6188d08eaaa2efcf6cc311916f41fd",
		"_shrinkwrap": null,
		"_spec": "levelup@https://registry.npmjs.org/levelup/-/levelup-1.3.3.tgz",
		"_where": "/Users/tenaciousmv/Code/tradle-app-web/node_modules/@tradle/engine",
		"browser": {
			"leveldown": false,
			"leveldown/package": false,
			"semver": false
		},
		"bugs": {
			"url": "https://github.com/level/levelup/issues"
		},
		"contributors": [
			{
				"name": "Rod Vagg",
				"email": "r@va.gg",
				"url": "https://github.com/rvagg"
			},
			{
				"name": "John Chesley",
				"email": "john@chesl.es",
				"url": "https://github.com/chesles/"
			},
			{
				"name": "Jake Verbaten",
				"email": "raynos2@gmail.com",
				"url": "https://github.com/raynos"
			},
			{
				"name": "Dominic Tarr",
				"email": "dominic.tarr@gmail.com",
				"url": "https://github.com/dominictarr"
			},
			{
				"name": "Max Ogden",
				"email": "max@maxogden.com",
				"url": "https://github.com/maxogden"
			},
			{
				"name": "Lars-Magnus Skog",
				"email": "ralphtheninja@riseup.net",
				"url": "https://github.com/ralphtheninja"
			},
			{
				"name": "David Björklund",
				"email": "david.bjorklund@gmail.com",
				"url": "https://github.com/kesla"
			},
			{
				"name": "Julian Gruber",
				"email": "julian@juliangruber.com",
				"url": "https://github.com/juliangruber"
			},
			{
				"name": "Paolo Fragomeni",
				"email": "paolo@async.ly",
				"url": "https://github.com/0x00a"
			},
			{
				"name": "Anton Whalley",
				"email": "anton.whalley@nearform.com",
				"url": "https://github.com/No9"
			},
			{
				"name": "Matteo Collina",
				"email": "matteo.collina@gmail.com",
				"url": "https://github.com/mcollina"
			},
			{
				"name": "Pedro Teixeira",
				"email": "pedro.teixeira@gmail.com",
				"url": "https://github.com/pgte"
			},
			{
				"name": "James Halliday",
				"email": "mail@substack.net",
				"url": "https://github.com/substack"
			},
			{
				"name": "Jarrett Cruger",
				"email": "jcrugzz@gmail.com",
				"url": "https://github.com/jcrugzz"
			}
		],
		"dependencies": {
			"deferred-leveldown": "~1.2.1",
			"level-codec": "~6.1.0",
			"level-errors": "~1.0.3",
			"level-iterator-stream": "~1.3.0",
			"prr": "~1.0.1",
			"semver": "~5.1.0",
			"xtend": "~4.0.0"
		},
		"description": "Fast & simple storage - a Node.js-style LevelDB wrapper",
		"devDependencies": {
			"async": "~1.5.0",
			"bustermove": "~1.0.0",
			"delayed": "~1.0.1",
			"faucet": "~0.0.1",
			"leveldown": "^1.1.0",
			"memdown": "~1.1.0",
			"msgpack-js": "~0.3.0",
			"referee": "~1.2.0",
			"rimraf": "~2.4.3",
			"slow-stream": "0.0.4",
			"tap": "~2.3.1",
			"tape": "~4.2.1"
		},
		"homepage": "https://github.com/level/levelup",
		"keywords": [
			"leveldb",
			"stream",
			"database",
			"db",
			"store",
			"storage",
			"json"
		],
		"license": "MIT",
		"main": "lib/levelup.js",
		"name": "levelup",
		"optionalDependencies": {},
		"readme": "LevelUP\n=======\n\n<img alt=\"LevelDB Logo\" height=\"100\" src=\"http://leveldb.org/img/logo.svg\">\n\n**Fast & simple storage - a Node.js-style LevelDB wrapper**\n\n[![Build Status](https://secure.travis-ci.org/Level/levelup.svg?branch=master)](http://travis-ci.org/Level/levelup)\n[![dependencies](https://david-dm.org/Level/levelup.svg)](https://david-dm.org/level/levelup)\n\n[![NPM](https://nodei.co/npm/levelup.png?stars&downloads&downloadRank)](https://nodei.co/npm/levelup/) [![NPM](https://nodei.co/npm-dl/levelup.png?months=6&height=3)](https://nodei.co/npm/levelup/)\n\n\n  * <a href=\"#intro\">Introduction</a>\n  * <a href=\"#leveldown\">Relationship to LevelDOWN</a>\n  * <a href=\"#platforms\">Tested &amp; supported platforms</a>\n  * <a href=\"#basic\">Basic usage</a>\n  * <a href=\"#api\">API</a>\n  * <a href=\"#events\">Events</a>\n  * <a href=\"#json\">JSON data</a>\n  * <a href=\"#custom_encodings\">Custom encodings</a>\n  * <a href=\"#extending\">Extending LevelUP</a>\n  * <a href=\"#multiproc\">Multi-process access</a>\n  * <a href=\"#support\">Getting support</a>\n  * <a href=\"#contributing\">Contributing</a>\n  * <a href=\"#license\">Licence &amp; copyright</a>\n\n<a name=\"intro\"></a>\nIntroduction\n------------\n\n**[LevelDB](https://github.com/google/leveldb)** is a simple key/value data store built by Google, inspired by BigTable. It's used in Google Chrome and many other products. LevelDB supports arbitrary byte arrays as both keys and values, singular *get*, *put* and *delete* operations, *batched put and delete*, bi-directional iterators and simple compression using the very fast [Snappy](http://google.github.io/snappy/) algorithm.\n\n**LevelUP** aims to expose the features of LevelDB in a **Node.js-friendly way**. All standard `Buffer` encoding types are supported, as is a special JSON encoding. LevelDB's iterators are exposed as a Node.js-style **readable stream**.\n\nLevelDB stores entries **sorted lexicographically by keys**. This makes LevelUP's <a href=\"#createReadStream\"><code>ReadStream</code></a> interface a very powerful query mechanism.\n\n**LevelUP** is an **OPEN Open Source Project**, see the <a href=\"#contributing\">Contributing</a> section to find out what this means.\n\n<a name=\"leveldown\"></a>\nRelationship to LevelDOWN\n-------------------------\n\nLevelUP is designed to be backed by **[LevelDOWN](https://github.com/level/leveldown/)** which provides a pure C++ binding to LevelDB and can be used as a stand-alone package if required.\n\n**As of version 0.9, LevelUP no longer requires LevelDOWN as a dependency so you must `npm install leveldown` when you install LevelUP.**\n\nLevelDOWN is now optional because LevelUP can be used with alternative backends, such as **[level.js](https://github.com/maxogden/level.js)** in the browser or [MemDOWN](https://github.com/level/memdown) for a pure in-memory store.\n\nLevelUP will look for LevelDOWN and throw an error if it can't find it in its Node `require()` path. It will also tell you if the installed version of LevelDOWN is incompatible.\n\n**The [level](https://github.com/level/level) package is available as an alternative installation mechanism.** Install it instead to automatically get both LevelUP & LevelDOWN. It exposes LevelUP on its export (i.e. you can `var leveldb = require('level')`).\n\n\n<a name=\"platforms\"></a>\nTested & supported platforms\n----------------------------\n\n  * **Linux**: including ARM platforms such as Raspberry Pi *and Kindle!*\n  * **Mac OS**\n  * **Solaris**: including Joyent's SmartOS & Nodejitsu\n  * **Windows**: Node 0.10 and above only. See installation instructions for *node-gyp's* dependencies [here](https://github.com/TooTallNate/node-gyp#installation), you'll need these (free) components from Microsoft to compile and run any native Node add-on in Windows.\n\n<a name=\"basic\"></a>\nBasic usage\n-----------\n\nFirst you need to install LevelUP!\n\n```sh\n$ npm install levelup leveldown\n```\n\nOr\n\n```sh\n$ npm install level\n```\n\n*(this second option requires you to use LevelUP by calling `var levelup = require('level')`)*\n\n\nAll operations are asynchronous although they don't necessarily require a callback if you don't need to know when the operation was performed.\n\n```js\nvar levelup = require('levelup')\n\n// 1) Create our database, supply location and options.\n//    This will create or open the underlying LevelDB store.\nvar db = levelup('./mydb')\n\n// 2) put a key & value\ndb.put('name', 'LevelUP', function (err) {\n  if (err) return console.log('Ooops!', err) // some kind of I/O error\n\n  // 3) fetch by key\n  db.get('name', function (err, value) {\n    if (err) return console.log('Ooops!', err) // likely the key was not found\n\n    // ta da!\n    console.log('name=' + value)\n  })\n})\n```\n\n<a name=\"api\"></a>\n## API\n\n  * <a href=\"#ctor\"><code><b>levelup()</b></code></a>\n  * <a href=\"#open\"><code>db.<b>open()</b></code></a>\n  * <a href=\"#close\"><code>db.<b>close()</b></code></a>\n  * <a href=\"#put\"><code>db.<b>put()</b></code></a>\n  * <a href=\"#get\"><code>db.<b>get()</b></code></a>\n  * <a href=\"#del\"><code>db.<b>del()</b></code></a>\n  * <a href=\"#batch\"><code>db.<b>batch()</b></code> *(array form)*</a>\n  * <a href=\"#batch_chained\"><code>db.<b>batch()</b></code> *(chained form)*</a>\n  * <a href=\"#isOpen\"><code>db.<b>isOpen()</b></code></a>\n  * <a href=\"#isClosed\"><code>db.<b>isClosed()</b></code></a>\n  * <a href=\"#createReadStream\"><code>db.<b>createReadStream()</b></code></a>\n  * <a href=\"#createKeyStream\"><code>db.<b>createKeyStream()</b></code></a>\n  * <a href=\"#createValueStream\"><code>db.<b>createValueStream()</b></code></a>\n\n### Special operations exposed by LevelDOWN\n\n  * <a href=\"#approximateSize\"><code>db.db.<b>approximateSize()</b></code></a>\n  * <a href=\"#getProperty\"><code>db.db.<b>getProperty()</b></code></a>\n  * <a href=\"#destroy\"><code><b>leveldown.destroy()</b></code></a>\n  * <a href=\"#repair\"><code><b>leveldown.repair()</b></code></a>\n\n### Special Notes\n  * <a href=\"#writeStreams\">What happened to <code><b>db.createWriteStream()</b></code></a>\n\n\n--------------------------------------------------------\n<a name=\"ctor\"></a>\n### levelup(location[, options[, callback]])\n### levelup(options[, callback ])\n### levelup(db[, callback ])\n<code>levelup()</code> is the main entry point for creating a new LevelUP instance and opening the underlying store with LevelDB.\n\nThis function returns a new instance of LevelUP and will also initiate an <a href=\"#open\"><code>open()</code></a> operation. Opening the database is an asynchronous operation which will trigger your callback if you provide one. The callback should take the form: `function (err, db) {}` where the `db` is the LevelUP instance. If you don't provide a callback, any read & write operations are simply queued internally until the database is fully opened.\n\nThis leads to two alternative ways of managing a new LevelUP instance:\n\n```js\nlevelup(location, options, function (err, db) {\n  if (err) throw err\n  db.get('foo', function (err, value) {\n    if (err) return console.log('foo does not exist')\n    console.log('got foo =', value)\n  })\n})\n\n// vs the equivalent:\n\nvar db = levelup(location, options) // will throw if an error occurs\ndb.get('foo', function (err, value) {\n  if (err) return console.log('foo does not exist')\n  console.log('got foo =', value)\n})\n```\n\nThe `location` argument is available as a read-only property on the returned LevelUP instance.\n\nThe `levelup(options, callback)` form (with optional `callback`) is only available where you provide a valid `'db'` property on the options object (see below). Only for back-ends that don't require a `location` argument, such as [MemDOWN](https://github.com/level/memdown).\n\nFor example:\n\n```js\nvar levelup = require('levelup')\nvar memdown = require('memdown')\nvar db = levelup({ db: memdown })\n```\n\nThe `levelup(db, callback)` form (with optional `callback`) is only available where `db` is a factory function, as would be provided as a `'db'` property on an `options` object (see below). Only for back-ends that don't require a `location` argument, such as [MemDOWN](https://github.com/level/memdown).\n\nFor example:\n\n```js\nvar levelup = require('levelup')\nvar memdown = require('memdown')\nvar db = levelup(memdown)\n```\n\n#### `options`\n\n`levelup()` takes an optional options object as its second argument; the following properties are accepted:\n\n* `'createIfMissing'` *(boolean, default: `true`)*: If `true`, will initialise an empty database at the specified location if one doesn't already exist. If `false` and a database doesn't exist you will receive an error in your `open()` callback and your database won't open.\n\n* `'errorIfExists'` *(boolean, default: `false`)*: If `true`, you will receive an error in your `open()` callback if the database exists at the specified location.\n\n* `'compression'` *(boolean, default: `true`)*: If `true`, all *compressible* data will be run through the Snappy compression algorithm before being stored. Snappy is very fast and shouldn't gain much speed by disabling so leave this on unless you have good reason to turn it off.\n\n* `'cacheSize'` *(number, default: `8 * 1024 * 1024`)*: The size (in bytes) of the in-memory [LRU](http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used) cache with frequently used uncompressed block contents.\n\n* `'keyEncoding'` and `'valueEncoding'` *(string, default: `'utf8'`)*: The encoding of the keys and values passed through Node.js' `Buffer` implementation (see [Buffer#toString()](http://nodejs.org/docs/latest/api/buffer.html#buffer_buf_tostring_encoding_start_end)).\n  <p><code>'utf8'</code> is the default encoding for both keys and values so you can simply pass in strings and expect strings from your <code>get()</code> operations. You can also pass <code>Buffer</code> objects as keys and/or values and conversion will be performed.</p>\n  <p>Supported encodings are: hex, utf8, ascii, binary, base64, ucs2, utf16le.</p>\n  <p><code>'json'</code> encoding is also supported, see below.</p>\n\n* `'db'` *(object, default: LevelDOWN)*: LevelUP is backed by [LevelDOWN](https://github.com/level/leveldown/) to provide an interface to LevelDB. You can completely replace the use of LevelDOWN by providing a \"factory\" function that will return a LevelDOWN API compatible object given a `location` argument. For further information, see [MemDOWN](https://github.com/level/memdown), a fully LevelDOWN API compatible replacement that uses a memory store rather than LevelDB. Also see [Abstract LevelDOWN](http://github.com/level/abstract-leveldown), a partial implementation of the LevelDOWN API that can be used as a base prototype for a LevelDOWN substitute.\n\nAdditionally, each of the main interface methods accept an optional options object that can be used to override `'keyEncoding'` and `'valueEncoding'`.\n\n--------------------------------------------------------\n<a name=\"open\"></a>\n### db.open([callback])\n<code>open()</code> opens the underlying LevelDB store. In general **you should never need to call this method directly** as it's automatically called by <a href=\"#ctor\"><code>levelup()</code></a>.\n\nHowever, it is possible to *reopen* a database after it has been closed with <a href=\"#close\"><code>close()</code></a>, although this is not generally advised.\n\n--------------------------------------------------------\n<a name=\"close\"></a>\n### db.close([callback])\n<code>close()</code> closes the underlying LevelDB store. The callback will receive any error encountered during closing as the first argument.\n\nYou should always clean up your LevelUP instance by calling `close()` when you no longer need it to free up resources. A LevelDB store cannot be opened by multiple instances of LevelDB/LevelUP simultaneously.\n\n--------------------------------------------------------\n<a name=\"put\"></a>\n### db.put(key, value[, options][, callback])\n<code>put()</code> is the primary method for inserting data into the store. Both the `key` and `value` can be arbitrary data objects.\n\nThe callback argument is optional but if you don't provide one and an error occurs then expect the error to be thrown.\n\n#### `options`\n\nEncoding of the `key` and `value` objects will adhere to `'keyEncoding'` and `'valueEncoding'` options provided to <a href=\"#ctor\"><code>levelup()</code></a>, although you can provide alternative encoding settings in the options for `put()` (it's recommended that you stay consistent in your encoding of keys and values in a single store).\n\nIf you provide a `'sync'` value of `true` in your `options` object, LevelDB will perform a synchronous write of the data; although the operation will be asynchronous as far as Node is concerned. Normally, LevelDB passes the data to the operating system for writing and returns immediately, however a synchronous write will use `fsync()` or equivalent so your callback won't be triggered until the data is actually on disk. Synchronous filesystem writes are **significantly** slower than asynchronous writes but if you want to be absolutely sure that the data is flushed then you can use `'sync': true`.\n\n--------------------------------------------------------\n<a name=\"get\"></a>\n### db.get(key[, options][, callback])\n<code>get()</code> is the primary method for fetching data from the store. The `key` can be an arbitrary data object. If it doesn't exist in the store then the callback will receive an error as its first argument. A not-found err object will be of type `'NotFoundError'` so you can `err.type == 'NotFoundError'` or you can perform a truthy test on the property `err.notFound`.\n\n```js\ndb.get('foo', function (err, value) {\n  if (err) {\n    if (err.notFound) {\n      // handle a 'NotFoundError' here\n      return\n    }\n    // I/O or other error, pass it up the callback chain\n    return callback(err)\n  }\n\n  // .. handle `value` here\n})\n```\n\n#### `options`\n\nEncoding of the `key` and `value` objects is the same as in <a href=\"#put\"><code>put</code></a>. \n\nLevelDB will by default fill the in-memory LRU Cache with data from a call to get. Disabling this is done by setting `fillCache` to `false`.\n\n--------------------------------------------------------\n<a name=\"del\"></a>\n### db.del(key[, options][, callback])\n<code>del()</code> is the primary method for removing data from the store.\n```js\ndb.del('foo', function (err) {\n  if (err)\n    // handle I/O or other error\n});\n```\n\n#### `options`\n\nEncoding of the `key` object will adhere to the `'keyEncoding'` option provided to <a href=\"#ctor\"><code>levelup()</code></a>, although you can provide alternative encoding settings in the options for `del()` (it's recommended that you stay consistent in your encoding of keys and values in a single store).\n\nA `'sync'` option can also be passed, see <a href=\"#put\"><code>put()</code></a> for details on how this works.\n\n--------------------------------------------------------\n<a name=\"batch\"></a>\n### db.batch(array[, options][, callback]) *(array form)*\n<code>batch()</code> can be used for very fast bulk-write operations (both *put* and *delete*). The `array` argument should contain a list of operations to be executed sequentially, although as a whole they are performed as an atomic operation inside LevelDB.\n\nEach operation is contained in an object having the following properties: `type`, `key`, `value`, where the *type* is either `'put'` or `'del'`. In the case of `'del'` the `'value'` property is ignored. Any entries with a `'key'` of `null` or `undefined` will cause an error to be returned on the `callback` and any `'type': 'put'` entry with a `'value'` of `null` or `undefined` will return an error.\n\nIf `key` and `value` are defined but `type` is not, it will default to `'put'`.\n\n```js\nvar ops = [\n    { type: 'del', key: 'father' }\n  , { type: 'put', key: 'name', value: 'Yuri Irsenovich Kim' }\n  , { type: 'put', key: 'dob', value: '16 February 1941' }\n  , { type: 'put', key: 'spouse', value: 'Kim Young-sook' }\n  , { type: 'put', key: 'occupation', value: 'Clown' }\n]\n\ndb.batch(ops, function (err) {\n  if (err) return console.log('Ooops!', err)\n  console.log('Great success dear leader!')\n})\n```\n\n#### `options`\n\nSee <a href=\"#put\"><code>put()</code></a> for a discussion on the `options` object. You can overwrite default `'keyEncoding'` and `'valueEncoding'` and also specify the use of `sync` filesystem operations.\n\nIn addition to encoding options for the whole batch you can also overwrite the encoding per operation, like:\n\n```js\nvar ops = [{\n    type          : 'put'\n  , key           : new Buffer([1, 2, 3])\n  , value         : { some: 'json' }\n  , keyEncoding   : 'binary'\n  , valueEncoding : 'json'\n}]\n```\n\n--------------------------------------------------------\n<a name=\"batch_chained\"></a>\n### db.batch() *(chained form)*\n<code>batch()</code>, when called with no arguments will return a `Batch` object which can be used to build, and eventually commit, an atomic LevelDB batch operation. Depending on how it's used, it is possible to obtain greater performance when using the chained form of `batch()` over the array form.\n\n```js\ndb.batch()\n  .del('father')\n  .put('name', 'Yuri Irsenovich Kim')\n  .put('dob', '16 February 1941')\n  .put('spouse', 'Kim Young-sook')\n  .put('occupation', 'Clown')\n  .write(function () { console.log('Done!') })\n```\n\n<b><code>batch.put(key, value[, options])</code></b>\n\nQueue a *put* operation on the current batch, not committed until a `write()` is called on the batch.\n\nThe optional `options` argument can be used to override the default `'keyEncoding'` and/or `'valueEncoding'`.\n\nThis method may `throw` a `WriteError` if there is a problem with your put (such as the `value` being `null` or `undefined`).\n\n<b><code>batch.del(key[, options])</code></b>\n\nQueue a *del* operation on the current batch, not committed until a `write()` is called on the batch.\n\nThe optional `options` argument can be used to override the default `'keyEncoding'`.\n\nThis method may `throw` a `WriteError` if there is a problem with your delete.\n\n<b><code>batch.clear()</code></b>\n\nClear all queued operations on the current batch, any previous operations will be discarded.\n\n<b><code>batch.length</code></b>\n\nThe number of queued operations on the current batch.\n\n<b><code>batch.write([callback])</code></b>\n\nCommit the queued operations for this batch. All operations not *cleared* will be written to the database atomically, that is, they will either all succeed or fail with no partial commits. The optional `callback` will be called when the operation has completed with an *error* argument if an error has occurred; if no `callback` is supplied and an error occurs then this method will `throw` a `WriteError`.\n\n\n--------------------------------------------------------\n<a name=\"isOpen\"></a>\n### db.isOpen()\n\nA LevelUP object can be in one of the following states:\n\n  * *\"new\"*     - newly created, not opened or closed\n  * *\"opening\"* - waiting for the database to be opened\n  * *\"open\"*    - successfully opened the database, available for use\n  * *\"closing\"* - waiting for the database to be closed\n  * *\"closed\"*  - database has been successfully closed, should not be used\n\n`isOpen()` will return `true` only when the state is \"open\".\n\n--------------------------------------------------------\n<a name=\"isClosed\"></a>\n### db.isClosed()\n\n*See <a href=\"#put\"><code>isOpen()</code></a>*\n\n`isClosed()` will return `true` only when the state is \"closing\" *or* \"closed\", it can be useful for determining if read and write operations are permissible.\n\n--------------------------------------------------------\n<a name=\"createReadStream\"></a>\n### db.createReadStream([options])\n\nYou can obtain a **ReadStream** of the full database by calling the `createReadStream()` method. The resulting stream is a complete Node.js-style [Readable Stream](http://nodejs.org/docs/latest/api/stream.html#stream_readable_stream) where `'data'` events emit objects with `'key'` and `'value'` pairs. You can also use the `gt`, `lt` and `limit` options to control the range of keys that are streamed.\n\n```js\ndb.createReadStream()\n  .on('data', function (data) {\n    console.log(data.key, '=', data.value)\n  })\n  .on('error', function (err) {\n    console.log('Oh my!', err)\n  })\n  .on('close', function () {\n    console.log('Stream closed')\n  })\n  .on('end', function () {\n    console.log('Stream ended')\n  })\n```\n\nThe standard `pause()`, `resume()` and `destroy()` methods are implemented on the ReadStream, as is `pipe()` (see below). `'data'`, '`error'`, `'end'` and `'close'` events are emitted.\n\nAdditionally, you can supply an options object as the first parameter to `createReadStream()` with the following options:\n\n* `'gt'` (greater than), `'gte'` (greater than or equal) define the lower bound of the range to be streamed. Only records where the key is greater than (or equal to) this option will be included in the range. When `reverse=true` the order will be reversed, but the records streamed will be the same.\n\n* `'lt'` (less than), `'lte'` (less than or equal) define the higher bound of the range to be streamed. Only key/value pairs where the key is less than (or equal to) this option will be included in the range. When `reverse=true` the order will be reversed, but the records streamed will be the same.\n\n* `'start', 'end'` legacy ranges - instead use `'gte', 'lte'`\n\n* `'reverse'` *(boolean, default: `false`)*: a boolean, set true and the stream output will be reversed. Beware that due to the way LevelDB works, a reverse seek will be slower than a forward seek.\n\n* `'keys'` *(boolean, default: `true`)*: whether the `'data'` event should contain keys. If set to `true` and `'values'` set to `false` then `'data'` events will simply be keys, rather than objects with a `'key'` property. Used internally by the `createKeyStream()` method.\n\n* `'values'` *(boolean, default: `true`)*: whether the `'data'` event should contain values. If set to `true` and `'keys'` set to `false` then `'data'` events will simply be values, rather than objects with a `'value'` property. Used internally by the `createValueStream()` method.\n\n* `'limit'` *(number, default: `-1`)*: limit the number of results collected by this stream. This number represents a *maximum* number of results and may not be reached if you get to the end of the data first. A value of `-1` means there is no limit. When `reverse=true` the highest keys will be returned instead of the lowest keys.\n\n* `'fillCache'` *(boolean, default: `false`)*: whether LevelDB's LRU-cache should be filled with data read.\n\n* `'keyEncoding'` / `'valueEncoding'` *(string)*: the encoding applied to each read piece of data.\n\n--------------------------------------------------------\n<a name=\"createKeyStream\"></a>\n### db.createKeyStream([options])\n\nA **KeyStream** is a **ReadStream** where the `'data'` events are simply the keys from the database so it can be used like a traditional stream rather than an object stream.\n\nYou can obtain a KeyStream either by calling the `createKeyStream()` method on a LevelUP object or by passing an options object to `createReadStream()` with `keys` set to `true` and `values` set to `false`.\n\n```js\ndb.createKeyStream()\n  .on('data', function (data) {\n    console.log('key=', data)\n  })\n\n// same as:\ndb.createReadStream({ keys: true, values: false })\n  .on('data', function (data) {\n    console.log('key=', data)\n  })\n```\n\n--------------------------------------------------------\n<a name=\"createValueStream\"></a>\n### db.createValueStream([options])\n\nA **ValueStream** is a **ReadStream** where the `'data'` events are simply the values from the database so it can be used like a traditional stream rather than an object stream.\n\nYou can obtain a ValueStream either by calling the `createValueStream()` method on a LevelUP object or by passing an options object to `createReadStream()` with `values` set to `true` and `keys` set to `false`.\n\n```js\ndb.createValueStream()\n  .on('data', function (data) {\n    console.log('value=', data)\n  })\n\n// same as:\ndb.createReadStream({ keys: false, values: true })\n  .on('data', function (data) {\n    console.log('value=', data)\n  })\n```\n\n--------------------------------------------------------\n<a name=\"writeStreams\"></a>\n#### What happened to `db.createWriteStream`?\n\n`db.createWriteStream()` has been removed in order to provide a smaller and more maintainable core. It primarily existed to create symmetry with `db.createReadStream()` but through much [discussion](https://github.com/level/levelup/issues/199), removing it was the best course of action.\n\nThe main driver for this was performance. While `db.createReadStream()` performs well under most use cases, `db.createWriteStream()` was highly dependent on the application keys and values. Thus we can't provide a standard implementation and encourage more `write-stream` implementations to be created to solve the broad spectrum of use cases.\n\nCheck out the implementations that the community has already produced [here](https://github.com/level/levelup/wiki/Modules#write-streams).\n\n--------------------------------------------------------\n<a name='approximateSize'></a>\n### db.db.approximateSize(start, end, callback)\n<code>approximateSize()</code> can used to get the approximate number of bytes of file system space used by the range `[start..end)`. The result may not include recently written data.\n\n```js\nvar db = require('level')('./huge.db')\n\ndb.db.approximateSize('a', 'c', function (err, size) {\n  if (err) return console.error('Ooops!', err)\n  console.log('Approximate size of range is %d', size)\n})\n```\n\n**Note:** `approximateSize()` is available via [LevelDOWN](https://github.com/level/leveldown/), which by default is accessible as the `db` property of your LevelUP instance. This is a specific LevelDB operation and is not likely to be available where you replace LevelDOWN with an alternative back-end via the `'db'` option.\n\n\n--------------------------------------------------------\n<a name='getProperty'></a>\n### db.db.getProperty(property)\n<code>getProperty</code> can be used to get internal details from LevelDB. When issued with a valid property string, a readable string will be returned (this method is synchronous).\n\nCurrently, the only valid properties are:\n\n* <b><code>'leveldb.num-files-at-levelN'</code></b>: returns the number of files at level *N*, where N is an integer representing a valid level (e.g. \"0\").\n\n* <b><code>'leveldb.stats'</code></b>: returns a multi-line string describing statistics about LevelDB's internal operation.\n\n* <b><code>'leveldb.sstables'</code></b>: returns a multi-line string describing all of the *sstables* that make up contents of the current database.\n\n\n```js\nvar db = require('level')('./huge.db')\nconsole.log(db.db.getProperty('leveldb.num-files-at-level3'))\n// → '243'\n```\n\n**Note:** `getProperty()` is available via [LevelDOWN](https://github.com/level/leveldown/), which by default is accessible as the `db` property of your LevelUP instance. This is a specific LevelDB operation and is not likely to be available where you replace LevelDOWN with an alternative back-end via the `'db'` option.\n\n\n--------------------------------------------------------\n<a name=\"destroy\"></a>\n### leveldown.destroy(location, callback)\n<code>destroy()</code> is used to completely remove an existing LevelDB database directory. You can use this function in place of a full directory *rm* if you want to be sure to only remove LevelDB-related files. If the directory only contains LevelDB files, the directory itself will be removed as well. If there are additional, non-LevelDB files in the directory, those files, and the directory, will be left alone.\n\nThe callback will be called when the destroy operation is complete, with a possible `error` argument.\n\n**Note:** `destroy()` is available via [LevelDOWN](https://github.com/level/leveldown/) which you will have to install seperately, e.g.:\n\n```js\nrequire('leveldown').destroy('./huge.db', function (err) { console.log('done!') })\n```\n\n--------------------------------------------------------\n<a name=\"repair\"></a>\n### leveldown.repair(location, callback)\n<code>repair()</code> can be used to attempt a restoration of a damaged LevelDB store. From the LevelDB documentation:\n\n> If a DB cannot be opened, you may attempt to call this method to resurrect as much of the contents of the database as possible. Some data may be lost, so be careful when calling this function on a database that contains important information.\n\nYou will find information on the *repair* operation in the *LOG* file inside the store directory.\n\nA `repair()` can also be used to perform a compaction of the LevelDB log into table files.\n\nThe callback will be called when the repair operation is complete, with a possible `error` argument.\n\n**Note:** `repair()` is available via [LevelDOWN](https://github.com/level/leveldown/) which you will have to install seperately, e.g.:\n\n```js\nrequire('leveldown').repair('./huge.db', function (err) { console.log('done!') })\n```\n\n--------------------------------------------------------\n\n<a name=\"events\"></a>\nEvents\n------\n\nLevelUP emits events when the callbacks to the corresponding methods are called.\n\n* `db.emit('put', key, value)` emitted when a new value is `'put'`\n* `db.emit('del', key)` emitted when a value is deleted\n* `db.emit('batch', ary)` emitted when a batch operation has executed\n* `db.emit('ready')` emitted when the database has opened (`'open'` is synonym)\n* `db.emit('closed')` emitted when the database has closed\n* `db.emit('opening')` emitted when the database is opening\n* `db.emit('closing')` emitted when the database is closing\n\nIf you do not pass a callback to an async function, and there is an error, LevelUP will `emit('error', err)` instead.\n\n<a name=\"json\"></a>\nJSON data\n---------\n\nYou specify `'json'` encoding for both keys and/or values, you can then supply JavaScript objects to LevelUP and receive them from all fetch operations, including ReadStreams. LevelUP will automatically *stringify* your objects and store them as *utf8* and parse the strings back into objects before passing them back to you.\n\n<a name=\"custom_encodings\"></a>\nCustom encodings\n----------------\n\nA custom encoding may be provided by passing in an object as a value for `keyEncoding` or `valueEncoding` (wherever accepted), it must have the following properties:\n\n```js\n{\n    encode : function (val) { ... }\n  , decode : function (val) { ... }\n  , buffer : boolean // encode returns a buffer and decode accepts a buffer\n  , type   : String  // name of this encoding type.\n}\n```\n\n<a name=\"extending\"></a>\nExtending LevelUP\n-----------------\n\nA list of <a href=\"https://github.com/level/levelup/wiki/Modules\"><b>Node.js LevelDB modules and projects</b></a> can be found in the wiki.\n\nWhen attempting to extend the functionality of LevelUP, it is recommended that you consider using [level-hooks](https://github.com/dominictarr/level-hooks) and/or [level-sublevel](https://github.com/dominictarr/level-sublevel). **level-sublevel** is particularly helpful for keeping additional, extension-specific, data in a LevelDB store. It allows you to partition a LevelUP instance into multiple sub-instances that each correspond to discrete namespaced key ranges.\n\n<a name=\"multiproc\"></a>\nMulti-process access\n--------------------\n\nLevelDB is thread-safe but is **not** suitable for accessing with multiple processes. You should only ever have a LevelDB database open from a single Node.js process. Node.js clusters are made up of multiple processes so a LevelUP instance cannot be shared between them either.\n\nSee the <a href=\"https://github.com/level/levelup/wiki/Modules\"><b>wiki</b></a> for some LevelUP extensions, including [multilevel](https://github.com/juliangruber/multilevel), that may help if you require a single data store to be shared across processes.\n\n<a name=\"support\"></a>\nGetting support\n---------------\n\nThere are multiple ways you can find help in using LevelDB in Node.js:\n\n * **IRC:** you'll find an active group of LevelUP users in the **##leveldb** channel on Freenode, including most of the contributors to this project.\n * **Mailing list:** there is an active [Node.js LevelDB](https://groups.google.com/forum/#!forum/node-levelup) Google Group.\n * **GitHub:** you're welcome to open an issue here on this GitHub repository if you have a question.\n\n<a name=\"contributing\"></a>\nContributing\n------------\n\nLevelUP is an **OPEN Open Source Project**. This means that:\n\n> Individuals making significant and valuable contributions are given commit-access to the project to contribute as they see fit. This project is more like an open wiki than a standard guarded open source project.\n\nSee the [contribution guide](https://github.com/Level/community/blob/master/CONTRIBUTING.md) for more details.\n\n### Windows\n\nA large portion of the Windows support comes from code by [Krzysztof Kowalczyk](http://blog.kowalczyk.info/) [@kjk](https://twitter.com/kjk), see his Windows LevelDB port [here](http://code.google.com/r/kkowalczyk-leveldb/). If you're using LevelUP on Windows, you should give him your thanks!\n\n\n<a name=\"license\"></a>\nLicense &amp; copyright\n-------------------\n\nCopyright &copy; 2012-2016 **LevelUP** [contributors](https://github.com/level/community#contributors).\n\n**LevelUP** is licensed under the MIT license. All rights not explicitly granted in the MIT license are reserved. See the included `LICENSE.md` file for more details.\n\n=======\n*LevelUP builds on the excellent work of the LevelDB and Snappy teams from Google and additional contributors. LevelDB and Snappy are both issued under the [New BSD Licence](http://opensource.org/licenses/BSD-3-Clause).*\n",
		"readmeFilename": "README.md",
		"repository": {
			"type": "git",
			"url": "git+https://github.com/level/levelup.git"
		},
		"scripts": {
			"test": "tape test/*-test.js | faucet"
		},
		"version": "1.3.3"
	};

/***/ },

/***/ 1274:
/***/ function(module, exports, __webpack_require__) {

	/* Copyright (c) 2012-2016 LevelUP contributors
	 * See list at <https://github.com/level/levelup#contributing>
	 * MIT License
	 * <https://github.com/level/levelup/blob/master/LICENSE.md>
	 */
	
	var util          = __webpack_require__(1269)
	  , WriteError    = __webpack_require__(1259).WriteError
	
	  , getOptions    = util.getOptions
	  , dispatchError = util.dispatchError
	
	function Batch (levelup, codec) {
	  this._levelup = levelup
	  this._codec = codec
	  this.batch = levelup.db.batch()
	  this.ops = []
	  this.length = 0
	}
	
	Batch.prototype.put = function (key_, value_, options) {
	  options = getOptions(options)
	
	  var key   = this._codec.encodeKey(key_, options)
	    , value = this._codec.encodeValue(value_, options)
	
	  try {
	    this.batch.put(key, value)
	  } catch (e) {
	    throw new WriteError(e)
	  }
	  this.ops.push({ type : 'put', key : key, value : value })
	  this.length++
	
	  return this
	}
	
	Batch.prototype.del = function (key_, options) {
	  options = getOptions(options)
	
	  var key = this._codec.encodeKey(key_, options)
	
	  try {
	    this.batch.del(key)
	  } catch (err) {
	    throw new WriteError(err)
	  }
	  this.ops.push({ type : 'del', key : key })
	  this.length++
	
	  return this
	}
	
	Batch.prototype.clear = function () {
	  try {
	    this.batch.clear()
	  } catch (err) {
	    throw new WriteError(err)
	  }
	
	  this.ops = []
	  this.length = 0
	  return this
	}
	
	Batch.prototype.write = function (callback) {
	  var levelup = this._levelup
	    , ops     = this.ops
	
	  try {
	    this.batch.write(function (err) {
	      if (err)
	        return dispatchError(levelup, new WriteError(err), callback)
	      levelup.emit('batch', ops)
	      if (callback)
	        callback()
	    })
	  } catch (err) {
	    throw new WriteError(err)
	  }
	}
	
	module.exports = Batch


/***/ },

/***/ 1294:
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
	  Address: __webpack_require__(1295),
	  base58check: __webpack_require__(1313),
	  Block: __webpack_require__(1314),
	  bufferutils: __webpack_require__(1311),
	  crypto: __webpack_require__(1312),
	  ecdsa: __webpack_require__(1316),
	  ECKey: __webpack_require__(1317),
	  ECPubKey: __webpack_require__(1318),
	  ECSignature: __webpack_require__(1309),
	  Message: __webpack_require__(1319),
	  opcodes: __webpack_require__(1299),
	  HDNode: __webpack_require__(1320),
	  Script: __webpack_require__(1310),
	  scripts: __webpack_require__(1298),
	  Transaction: __webpack_require__(1315),
	  TransactionBuilder: __webpack_require__(1321),
	  networks: __webpack_require__(1297),
	  Wallet: __webpack_require__(1322)
	}


/***/ },

/***/ 1295:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var assert = __webpack_require__(1296)
	var base58check = __webpack_require__(1237)
	var typeForce = __webpack_require__(1054)
	var networks = __webpack_require__(1297)
	var scripts = __webpack_require__(1298)
	
	function findScriptTypeByVersion (version) {
	  for (var networkName in networks) {
	    var network = networks[networkName]
	
	    if (version === network.pubKeyHash) return 'pubkeyhash'
	    if (version === network.scriptHash) return 'scripthash'
	  }
	}
	
	function Address (hash, version) {
	  typeForce('Buffer', hash)
	
	  assert.strictEqual(hash.length, 20, 'Invalid hash length')
	  assert.strictEqual(version & 0xff, version, 'Invalid version byte')
	
	  this.hash = hash
	  this.version = version
	}
	
	Address.fromBase58Check = function (string) {
	  var payload = base58check.decode(string)
	  var version = payload.readUInt8(0)
	  var hash = payload.slice(1)
	
	  return new Address(hash, version)
	}
	
	Address.fromOutputScript = function (script, network) {
	  network = network || networks.bitcoin
	
	  if (scripts.isPubKeyHashOutput(script)) return new Address(script.chunks[2], network.pubKeyHash)
	  if (scripts.isScriptHashOutput(script)) return new Address(script.chunks[1], network.scriptHash)
	
	  assert(false, script.toASM() + ' has no matching Address')
	}
	
	Address.prototype.toBase58Check = function () {
	  var payload = new Buffer(21)
	  payload.writeUInt8(this.version, 0)
	  this.hash.copy(payload, 1)
	
	  return base58check.encode(payload)
	}
	
	Address.prototype.toOutputScript = function () {
	  var scriptType = findScriptTypeByVersion(this.version)
	
	  if (scriptType === 'pubkeyhash') return scripts.pubKeyHashOutput(this.hash)
	  if (scriptType === 'scripthash') return scripts.scriptHashOutput(this.hash)
	
	  assert(false, this.toString() + ' has no matching Script')
	}
	
	Address.prototype.toString = Address.prototype.toBase58Check
	
	module.exports = Address
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(820).Buffer))

/***/ },

/***/ 1297:
/***/ function(module, exports) {

	// https://en.bitcoin.it/wiki/List_of_address_prefixes
	// Dogecoin BIP32 is a proposed standard: https://bitcointalk.org/index.php?topic=409731
	
	var networks = {
	  bitcoin: {
	    magicPrefix: '\x18Bitcoin Signed Message:\n',
	    bip32: {
	      public: 0x0488b21e,
	      private: 0x0488ade4
	    },
	    pubKeyHash: 0x00,
	    scriptHash: 0x05,
	    wif: 0x80,
	    dustThreshold: 546, // https://github.com/bitcoin/bitcoin/blob/v0.9.2/src/core.h#L151-L162
	    feePerKb: 10000, // https://github.com/bitcoin/bitcoin/blob/v0.9.2/src/main.cpp#L53
	    estimateFee: estimateFee('bitcoin')
	  },
	  testnet: {
	    magicPrefix: '\x18Bitcoin Signed Message:\n',
	    bip32: {
	      public: 0x043587cf,
	      private: 0x04358394
	    },
	    pubKeyHash: 0x6f,
	    scriptHash: 0xc4,
	    wif: 0xef,
	    dustThreshold: 546,
	    feePerKb: 10000,
	    estimateFee: estimateFee('testnet')
	  },
	  litecoin: {
	    magicPrefix: '\x19Litecoin Signed Message:\n',
	    bip32: {
	      public: 0x019da462,
	      private: 0x019d9cfe
	    },
	    pubKeyHash: 0x30,
	    scriptHash: 0x05,
	    wif: 0xb0,
	    dustThreshold: 0, // https://github.com/litecoin-project/litecoin/blob/v0.8.7.2/src/main.cpp#L360-L365
	    dustSoftThreshold: 100000, // https://github.com/litecoin-project/litecoin/blob/v0.8.7.2/src/main.h#L53
	    feePerKb: 100000, // https://github.com/litecoin-project/litecoin/blob/v0.8.7.2/src/main.cpp#L56
	    estimateFee: estimateFee('litecoin')
	  },
	  dogecoin: {
	    magicPrefix: '\x19Dogecoin Signed Message:\n',
	    bip32: {
	      public: 0x02facafd,
	      private: 0x02fac398
	    },
	    pubKeyHash: 0x1e,
	    scriptHash: 0x16,
	    wif: 0x9e,
	    dustThreshold: 0, // https://github.com/dogecoin/dogecoin/blob/v1.7.1/src/core.h#L155-L160
	    dustSoftThreshold: 100000000, // https://github.com/dogecoin/dogecoin/blob/v1.7.1/src/main.h#L62
	    feePerKb: 100000000, // https://github.com/dogecoin/dogecoin/blob/v1.7.1/src/main.cpp#L58
	    estimateFee: estimateFee('dogecoin')
	  },
	  viacoin: {
	    magicPrefix: '\x18Viacoin Signed Message:\n',
	    bip32: {
	      public: 0x0488b21e,
	      private: 0x0488ade4
	    },
	    pubKeyHash: 0x47,
	    scriptHash: 0x21,
	    wif: 0xc7,
	    dustThreshold: 560,
	    dustSoftThreshold: 100000,
	    feePerKb: 100000, //
	    estimateFee: estimateFee('viacoin')
	  },
	  viacointestnet: {
	    magicPrefix: '\x18Viacoin Signed Message:\n',
	    bip32: {
	      public: 0x043587cf,
	      private: 0x04358394
	    },
	    pubKeyHash: 0x7f,
	    scriptHash: 0xc4,
	    wif: 0xff,
	    dustThreshold: 560,
	    dustSoftThreshold: 100000,
	    feePerKb: 100000,
	    estimateFee: estimateFee('viacointestnet')
	  },
	  gamerscoin: {
	    magicPrefix: '\x19Gamerscoin Signed Message:\n',
	    bip32: {
	      public: 0x019da462,
	      private: 0x019d9cfe
	    },
	    pubKeyHash: 0x26,
	    scriptHash: 0x05,
	    wif: 0xA6,
	    dustThreshold: 0, // https://github.com/gamers-coin/gamers-coinv3/blob/master/src/main.cpp#L358-L363
	    dustSoftThreshold: 100000, // https://github.com/gamers-coin/gamers-coinv3/blob/master/src/main.cpp#L51
	    feePerKb: 100000, // https://github.com/gamers-coin/gamers-coinv3/blob/master/src/main.cpp#L54
	    estimateFee: estimateFee('gamerscoin')
	  },
	  jumbucks: {
	    magicPrefix: '\x19Jumbucks Signed Message:\n',
	    bip32: {
	      public: 0x037a689a,
	      private: 0x037a6460
	    },
	    pubKeyHash: 0x2b,
	    scriptHash: 0x05,
	    wif: 0xab,
	    dustThreshold: 0,
	    dustSoftThreshold: 10000,
	    feePerKb: 10000,
	    estimateFee: estimateFee('jumbucks')
	  },
	  zetacoin: {
	    magicPrefix: '\x18Zetacoin Signed Message:\n',
	    bip32: {
	      public: 0x0488b21e,
	      private: 0x0488ade4
	    },
	    pubKeyHash: 0x50,
	    scriptHash: 0x09,
	    wif: 0xe0,
	    dustThreshold: 546, // https://github.com/zetacoin/zetacoin/blob/master/src/core.h#L159
	    feePerKb: 10000, // https://github.com/zetacoin/zetacoin/blob/master/src/main.cpp#L54
	    estimateFee: estimateFee('zetacoin')
	  }
	}
	
	function estimateFee (type) {
	  return function (tx) {
	    var network = networks[type]
	    var baseFee = network.feePerKb
	    var byteSize = tx.toBuffer().length
	
	    var fee = baseFee * Math.ceil(byteSize / 1000)
	    if (network.dustSoftThreshold === undefined) return fee
	
	    tx.outs.forEach(function (e) {
	      if (e.value < network.dustSoftThreshold) {
	        fee += baseFee
	      }
	    })
	
	    return fee
	  }
	}
	
	module.exports = networks


/***/ },

/***/ 1298:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var assert = __webpack_require__(1296)
	var ops = __webpack_require__(1299)
	var typeForce = __webpack_require__(1054)
	
	var ecurve = __webpack_require__(1300)
	var curve = ecurve.getCurveByName('secp256k1')
	
	var ECSignature = __webpack_require__(1309)
	var Script = __webpack_require__(1310)
	
	function isCanonicalPubKey (buffer) {
	  if (!Buffer.isBuffer(buffer)) return false
	
	  try {
	    ecurve.Point.decodeFrom(curve, buffer)
	  } catch (e) {
	    if (!(e.message.match(/Invalid sequence (length|tag)/)))
	      throw e
	
	    return false
	  }
	
	  return true
	}
	
	function isCanonicalSignature (buffer) {
	  if (!Buffer.isBuffer(buffer)) return false
	
	  try {
	    ECSignature.parseScriptSignature(buffer)
	  } catch (e) {
	    if (!(e.message.match(/Not a DER sequence|Invalid sequence length|Expected a DER integer|R length is zero|S length is zero|R value excessively padded|S value excessively padded|R value is negative|S value is negative|Invalid hashType/))) {
	      throw e
	    }
	
	    return false
	  }
	
	  return true
	}
	
	function isPubKeyHashInput (script) {
	  return script.chunks.length === 2 &&
	    isCanonicalSignature(script.chunks[0]) &&
	    isCanonicalPubKey(script.chunks[1])
	}
	
	function isPubKeyHashOutput (script) {
	  return script.chunks.length === 5 &&
	    script.chunks[0] === ops.OP_DUP &&
	    script.chunks[1] === ops.OP_HASH160 &&
	    Buffer.isBuffer(script.chunks[2]) &&
	    script.chunks[2].length === 20 &&
	    script.chunks[3] === ops.OP_EQUALVERIFY &&
	    script.chunks[4] === ops.OP_CHECKSIG
	}
	
	function isPubKeyInput (script) {
	  return script.chunks.length === 1 &&
	    isCanonicalSignature(script.chunks[0])
	}
	
	function isPubKeyOutput (script) {
	  return script.chunks.length === 2 &&
	    isCanonicalPubKey(script.chunks[0]) &&
	    script.chunks[1] === ops.OP_CHECKSIG
	}
	
	function isScriptHashInput (script, allowIncomplete) {
	  if (script.chunks.length < 2) return false
	
	  var lastChunk = script.chunks[script.chunks.length - 1]
	  if (!Buffer.isBuffer(lastChunk)) return false
	
	  var scriptSig = Script.fromChunks(script.chunks.slice(0, -1))
	  var redeemScript = Script.fromBuffer(lastChunk)
	
	  // is redeemScript a valid script?
	  if (redeemScript.chunks.length === 0) return false
	
	  return classifyInput(scriptSig, allowIncomplete) === classifyOutput(redeemScript)
	}
	
	function isScriptHashOutput (script) {
	  return script.chunks.length === 3 &&
	    script.chunks[0] === ops.OP_HASH160 &&
	    Buffer.isBuffer(script.chunks[1]) &&
	    script.chunks[1].length === 20 &&
	    script.chunks[2] === ops.OP_EQUAL
	}
	
	// allowIncomplete is to account for combining signatures
	// See https://github.com/bitcoin/bitcoin/blob/f425050546644a36b0b8e0eb2f6934a3e0f6f80f/src/script/sign.cpp#L195-L197
	function isMultisigInput (script, allowIncomplete) {
	  if (script.chunks.length < 2) return false
	  if (script.chunks[0] !== ops.OP_0) return false
	
	  if (allowIncomplete) {
	    return script.chunks.slice(1).every(function (chunk) {
	      return chunk === ops.OP_0 || isCanonicalSignature(chunk)
	    })
	  }
	
	  return script.chunks.slice(1).every(isCanonicalSignature)
	}
	
	function isMultisigOutput (script) {
	  if (script.chunks.length < 4) return false
	  if (script.chunks[script.chunks.length - 1] !== ops.OP_CHECKMULTISIG) return false
	
	  var mOp = script.chunks[0]
	  if (mOp === ops.OP_0) return false
	  if (mOp < ops.OP_1) return false
	  if (mOp > ops.OP_16) return false
	
	  var nOp = script.chunks[script.chunks.length - 2]
	  if (nOp === ops.OP_0) return false
	  if (nOp < ops.OP_1) return false
	  if (nOp > ops.OP_16) return false
	
	  var m = mOp - (ops.OP_1 - 1)
	  var n = nOp - (ops.OP_1 - 1)
	  if (n < m) return false
	
	  var pubKeys = script.chunks.slice(1, -2)
	  if (n < pubKeys.length) return false
	
	  return pubKeys.every(isCanonicalPubKey)
	}
	
	function isNullDataOutput (script) {
	  return script.chunks[0] === ops.OP_RETURN
	}
	
	function classifyOutput (script) {
	  typeForce('Script', script)
	
	  if (isPubKeyHashOutput(script)) {
	    return 'pubkeyhash'
	  } else if (isScriptHashOutput(script)) {
	    return 'scripthash'
	  } else if (isMultisigOutput(script)) {
	    return 'multisig'
	  } else if (isPubKeyOutput(script)) {
	    return 'pubkey'
	  } else if (isNullDataOutput(script)) {
	    return 'nulldata'
	  }
	
	  return 'nonstandard'
	}
	
	function classifyInput (script, allowIncomplete) {
	  typeForce('Script', script)
	
	  if (isPubKeyHashInput(script)) {
	    return 'pubkeyhash'
	  } else if (isMultisigInput(script, allowIncomplete)) {
	    return 'multisig'
	  } else if (isScriptHashInput(script, allowIncomplete)) {
	    return 'scripthash'
	  } else if (isPubKeyInput(script)) {
	    return 'pubkey'
	  }
	
	  return 'nonstandard'
	}
	
	// Standard Script Templates
	// {pubKey} OP_CHECKSIG
	function pubKeyOutput (pubKey) {
	  return Script.fromChunks([
	    pubKey.toBuffer(),
	    ops.OP_CHECKSIG
	  ])
	}
	
	// OP_DUP OP_HASH160 {pubKeyHash} OP_EQUALVERIFY OP_CHECKSIG
	function pubKeyHashOutput (hash) {
	  typeForce('Buffer', hash)
	
	  return Script.fromChunks([
	    ops.OP_DUP,
	    ops.OP_HASH160,
	    hash,
	    ops.OP_EQUALVERIFY,
	    ops.OP_CHECKSIG
	  ])
	}
	
	// OP_HASH160 {scriptHash} OP_EQUAL
	function scriptHashOutput (hash) {
	  typeForce('Buffer', hash)
	
	  return Script.fromChunks([
	    ops.OP_HASH160,
	    hash,
	    ops.OP_EQUAL
	  ])
	}
	
	// m [pubKeys ...] n OP_CHECKMULTISIG
	function multisigOutput (m, pubKeys) {
	  typeForce(['ECPubKey'], pubKeys)
	
	  assert(pubKeys.length >= m, 'Not enough pubKeys provided')
	
	  var pubKeyBuffers = pubKeys.map(function (pubKey) {
	    return pubKey.toBuffer()
	  })
	  var n = pubKeys.length
	
	  return Script.fromChunks([].concat(
	    (ops.OP_1 - 1) + m,
	    pubKeyBuffers,
	    (ops.OP_1 - 1) + n,
	    ops.OP_CHECKMULTISIG
	  ))
	}
	
	// {signature}
	function pubKeyInput (signature) {
	  typeForce('Buffer', signature)
	
	  return Script.fromChunks([signature])
	}
	
	// {signature} {pubKey}
	function pubKeyHashInput (signature, pubKey) {
	  typeForce('Buffer', signature)
	
	  return Script.fromChunks([signature, pubKey.toBuffer()])
	}
	
	// <scriptSig> {serialized scriptPubKey script}
	function scriptHashInput (scriptSig, scriptPubKey) {
	  return Script.fromChunks([].concat(
	    scriptSig.chunks,
	    scriptPubKey.toBuffer()
	  ))
	}
	
	// OP_0 [signatures ...]
	function multisigInput (signatures, scriptPubKey) {
	  if (scriptPubKey) {
	    assert(isMultisigOutput(scriptPubKey))
	
	    var mOp = scriptPubKey.chunks[0]
	    var nOp = scriptPubKey.chunks[scriptPubKey.chunks.length - 2]
	    var m = mOp - (ops.OP_1 - 1)
	    var n = nOp - (ops.OP_1 - 1)
	
	    assert(signatures.length >= m, 'Not enough signatures provided')
	    assert(signatures.length <= n, 'Too many signatures provided')
	  }
	
	  return Script.fromChunks([].concat(ops.OP_0, signatures))
	}
	
	function nullDataOutput (data) {
	  return Script.fromChunks([ops.OP_RETURN, data])
	}
	
	module.exports = {
	  isCanonicalPubKey: isCanonicalPubKey,
	  isCanonicalSignature: isCanonicalSignature,
	  isPubKeyHashInput: isPubKeyHashInput,
	  isPubKeyHashOutput: isPubKeyHashOutput,
	  isPubKeyInput: isPubKeyInput,
	  isPubKeyOutput: isPubKeyOutput,
	  isScriptHashInput: isScriptHashInput,
	  isScriptHashOutput: isScriptHashOutput,
	  isMultisigInput: isMultisigInput,
	  isMultisigOutput: isMultisigOutput,
	  isNullDataOutput: isNullDataOutput,
	  classifyOutput: classifyOutput,
	  classifyInput: classifyInput,
	  pubKeyOutput: pubKeyOutput,
	  pubKeyHashOutput: pubKeyHashOutput,
	  scriptHashOutput: scriptHashOutput,
	  multisigOutput: multisigOutput,
	  pubKeyInput: pubKeyInput,
	  pubKeyHashInput: pubKeyHashInput,
	  scriptHashInput: scriptHashInput,
	  multisigInput: multisigInput,
	  dataOutput: function (data) {
	    console.warn('dataOutput is deprecated, use nullDataOutput by 2.0.0')
	    return nullDataOutput(data)
	  },
	  nullDataOutput: nullDataOutput
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(820).Buffer))

/***/ },

/***/ 1299:
/***/ function(module, exports) {

	module.exports = {
	  // push value
	  OP_FALSE: 0,
	  OP_0: 0,
	  OP_PUSHDATA1: 76,
	  OP_PUSHDATA2: 77,
	  OP_PUSHDATA4: 78,
	  OP_1NEGATE: 79,
	  OP_RESERVED: 80,
	  OP_1: 81,
	  OP_TRUE: 81,
	  OP_2: 82,
	  OP_3: 83,
	  OP_4: 84,
	  OP_5: 85,
	  OP_6: 86,
	  OP_7: 87,
	  OP_8: 88,
	  OP_9: 89,
	  OP_10: 90,
	  OP_11: 91,
	  OP_12: 92,
	  OP_13: 93,
	  OP_14: 94,
	  OP_15: 95,
	  OP_16: 96,
	
	  // control
	  OP_NOP: 97,
	  OP_VER: 98,
	  OP_IF: 99,
	  OP_NOTIF: 100,
	  OP_VERIF: 101,
	  OP_VERNOTIF: 102,
	  OP_ELSE: 103,
	  OP_ENDIF: 104,
	  OP_VERIFY: 105,
	  OP_RETURN: 106,
	
	  // stack ops
	  OP_TOALTSTACK: 107,
	  OP_FROMALTSTACK: 108,
	  OP_2DROP: 109,
	  OP_2DUP: 110,
	  OP_3DUP: 111,
	  OP_2OVER: 112,
	  OP_2ROT: 113,
	  OP_2SWAP: 114,
	  OP_IFDUP: 115,
	  OP_DEPTH: 116,
	  OP_DROP: 117,
	  OP_DUP: 118,
	  OP_NIP: 119,
	  OP_OVER: 120,
	  OP_PICK: 121,
	  OP_ROLL: 122,
	  OP_ROT: 123,
	  OP_SWAP: 124,
	  OP_TUCK: 125,
	
	  // splice ops
	  OP_CAT: 126,
	  OP_SUBSTR: 127,
	  OP_LEFT: 128,
	  OP_RIGHT: 129,
	  OP_SIZE: 130,
	
	  // bit logic
	  OP_INVERT: 131,
	  OP_AND: 132,
	  OP_OR: 133,
	  OP_XOR: 134,
	  OP_EQUAL: 135,
	  OP_EQUALVERIFY: 136,
	  OP_RESERVED1: 137,
	  OP_RESERVED2: 138,
	
	  // numeric
	  OP_1ADD: 139,
	  OP_1SUB: 140,
	  OP_2MUL: 141,
	  OP_2DIV: 142,
	  OP_NEGATE: 143,
	  OP_ABS: 144,
	  OP_NOT: 145,
	  OP_0NOTEQUAL: 146,
	
	  OP_ADD: 147,
	  OP_SUB: 148,
	  OP_MUL: 149,
	  OP_DIV: 150,
	  OP_MOD: 151,
	  OP_LSHIFT: 152,
	  OP_RSHIFT: 153,
	
	  OP_BOOLAND: 154,
	  OP_BOOLOR: 155,
	  OP_NUMEQUAL: 156,
	  OP_NUMEQUALVERIFY: 157,
	  OP_NUMNOTEQUAL: 158,
	  OP_LESSTHAN: 159,
	  OP_GREATERTHAN: 160,
	  OP_LESSTHANOREQUAL: 161,
	  OP_GREATERTHANOREQUAL: 162,
	  OP_MIN: 163,
	  OP_MAX: 164,
	
	  OP_WITHIN: 165,
	
	  // crypto
	  OP_RIPEMD160: 166,
	  OP_SHA1: 167,
	  OP_SHA256: 168,
	  OP_HASH160: 169,
	  OP_HASH256: 170,
	  OP_CODESEPARATOR: 171,
	  OP_CHECKSIG: 172,
	  OP_CHECKSIGVERIFY: 173,
	  OP_CHECKMULTISIG: 174,
	  OP_CHECKMULTISIGVERIFY: 175,
	
	  // expansion
	  OP_NOP1: 176,
	  OP_NOP2: 177,
	  OP_NOP3: 178,
	  OP_NOP4: 179,
	  OP_NOP5: 180,
	  OP_NOP6: 181,
	  OP_NOP7: 182,
	  OP_NOP8: 183,
	  OP_NOP9: 184,
	  OP_NOP10: 185,
	
	  // template matching params
	  OP_PUBKEYHASH: 253,
	  OP_PUBKEY: 254,
	  OP_INVALIDOPCODE: 255
	}


/***/ },

/***/ 1309:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var assert = __webpack_require__(1296)
	var typeForce = __webpack_require__(1054)
	
	var BigInteger = __webpack_require__(1302)
	
	function ECSignature (r, s) {
	  typeForce('BigInteger', r)
	  typeForce('BigInteger', s)
	
	  this.r = r
	  this.s = s
	}
	
	ECSignature.parseCompact = function (buffer) {
	  assert.equal(buffer.length, 65, 'Invalid signature length')
	  var i = buffer.readUInt8(0) - 27
	
	  // At most 3 bits
	  assert.equal(i, i & 7, 'Invalid signature parameter')
	  var compressed = !!(i & 4)
	
	  // Recovery param only
	  i = i & 3
	
	  var r = BigInteger.fromBuffer(buffer.slice(1, 33))
	  var s = BigInteger.fromBuffer(buffer.slice(33))
	
	  return {
	    compressed: compressed,
	    i: i,
	    signature: new ECSignature(r, s)
	  }
	}
	
	ECSignature.fromDER = function (buffer) {
	  assert.equal(buffer.readUInt8(0), 0x30, 'Not a DER sequence')
	  assert.equal(buffer.readUInt8(1), buffer.length - 2, 'Invalid sequence length')
	  assert.equal(buffer.readUInt8(2), 0x02, 'Expected a DER integer')
	
	  var rLen = buffer.readUInt8(3)
	  assert(rLen > 0, 'R length is zero')
	
	  var offset = 4 + rLen
	  assert.equal(buffer.readUInt8(offset), 0x02, 'Expected a DER integer (2)')
	
	  var sLen = buffer.readUInt8(offset + 1)
	  assert(sLen > 0, 'S length is zero')
	
	  var rB = buffer.slice(4, offset)
	  var sB = buffer.slice(offset + 2)
	  offset += 2 + sLen
	
	  if (rLen > 1 && rB.readUInt8(0) === 0x00) {
	    assert(rB.readUInt8(1) & 0x80, 'R value excessively padded')
	  }
	
	  if (sLen > 1 && sB.readUInt8(0) === 0x00) {
	    assert(sB.readUInt8(1) & 0x80, 'S value excessively padded')
	  }
	
	  assert.equal(offset, buffer.length, 'Invalid DER encoding')
	  var r = BigInteger.fromDERInteger(rB)
	  var s = BigInteger.fromDERInteger(sB)
	
	  assert(r.signum() >= 0, 'R value is negative')
	  assert(s.signum() >= 0, 'S value is negative')
	
	  return new ECSignature(r, s)
	}
	
	// BIP62: 1 byte hashType flag (only 0x01, 0x02, 0x03, 0x81, 0x82 and 0x83 are allowed)
	ECSignature.parseScriptSignature = function (buffer) {
	  var hashType = buffer.readUInt8(buffer.length - 1)
	  var hashTypeMod = hashType & ~0x80
	
	  assert(hashTypeMod > 0x00 && hashTypeMod < 0x04, 'Invalid hashType ' + hashType)
	
	  return {
	    signature: ECSignature.fromDER(buffer.slice(0, -1)),
	    hashType: hashType
	  }
	}
	
	ECSignature.prototype.toCompact = function (i, compressed) {
	  if (compressed) {
	    i += 4
	  }
	
	  i += 27
	
	  var buffer = new Buffer(65)
	  buffer.writeUInt8(i, 0)
	
	  this.r.toBuffer(32).copy(buffer, 1)
	  this.s.toBuffer(32).copy(buffer, 33)
	
	  return buffer
	}
	
	ECSignature.prototype.toDER = function () {
	  var rBa = this.r.toDERInteger()
	  var sBa = this.s.toDERInteger()
	
	  var sequence = []
	
	  // INTEGER
	  sequence.push(0x02, rBa.length)
	  sequence = sequence.concat(rBa)
	
	  // INTEGER
	  sequence.push(0x02, sBa.length)
	  sequence = sequence.concat(sBa)
	
	  // SEQUENCE
	  sequence.unshift(0x30, sequence.length)
	
	  return new Buffer(sequence)
	}
	
	ECSignature.prototype.toScriptSignature = function (hashType) {
	  var hashTypeMod = hashType & ~0x80
	  assert(hashTypeMod > 0x00 && hashTypeMod < 0x04, 'Invalid hashType ' + hashType)
	
	  var hashTypeBuffer = new Buffer(1)
	  hashTypeBuffer.writeUInt8(hashType, 0)
	
	  return Buffer.concat([this.toDER(), hashTypeBuffer])
	}
	
	module.exports = ECSignature
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(820).Buffer))

/***/ },

/***/ 1310:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var assert = __webpack_require__(1296)
	var bufferutils = __webpack_require__(1311)
	var crypto = __webpack_require__(1312)
	var typeForce = __webpack_require__(1054)
	var opcodes = __webpack_require__(1299)
	
	function Script (buffer, chunks) {
	  typeForce('Buffer', buffer)
	  typeForce('Array', chunks)
	
	  this.buffer = buffer
	  this.chunks = chunks
	}
	
	Script.fromASM = function (asm) {
	  var strChunks = asm.split(' ')
	  var chunks = strChunks.map(function (strChunk) {
	    // opcode
	    if (strChunk in opcodes) {
	      return opcodes[strChunk]
	
	    // data chunk
	    } else {
	      return new Buffer(strChunk, 'hex')
	    }
	  })
	
	  return Script.fromChunks(chunks)
	}
	
	Script.fromBuffer = function (buffer) {
	  var chunks = []
	  var i = 0
	
	  while (i < buffer.length) {
	    var opcode = buffer.readUInt8(i)
	
	    // data chunk
	    if ((opcode > opcodes.OP_0) && (opcode <= opcodes.OP_PUSHDATA4)) {
	      var d = bufferutils.readPushDataInt(buffer, i)
	
	      // did reading a pushDataInt fail? return non-chunked script
	      if (d === null) return new Script(buffer, [])
	      i += d.size
	
	      // attempt to read too much data?
	      if (i + d.number > buffer.length) return new Script(buffer, [])
	
	      var data = buffer.slice(i, i + d.number)
	      i += d.number
	
	      chunks.push(data)
	
	    // opcode
	    } else {
	      chunks.push(opcode)
	
	      i += 1
	    }
	  }
	
	  return new Script(buffer, chunks)
	}
	
	Script.fromChunks = function (chunks) {
	  typeForce('Array', chunks)
	
	  var bufferSize = chunks.reduce(function (accum, chunk) {
	    // data chunk
	    if (Buffer.isBuffer(chunk)) {
	      return accum + bufferutils.pushDataSize(chunk.length) + chunk.length
	    }
	
	    // opcode
	    return accum + 1
	  }, 0.0)
	
	  var buffer = new Buffer(bufferSize)
	  var offset = 0
	
	  chunks.forEach(function (chunk) {
	    // data chunk
	    if (Buffer.isBuffer(chunk)) {
	      offset += bufferutils.writePushDataInt(buffer, chunk.length, offset)
	
	      chunk.copy(buffer, offset)
	      offset += chunk.length
	
	    // opcode
	    } else {
	      buffer.writeUInt8(chunk, offset)
	      offset += 1
	    }
	  })
	
	  assert.equal(offset, buffer.length, 'Could not decode chunks')
	  return new Script(buffer, chunks)
	}
	
	Script.fromHex = function (hex) {
	  return Script.fromBuffer(new Buffer(hex, 'hex'))
	}
	
	Script.EMPTY = Script.fromChunks([])
	
	Script.prototype.getHash = function () {
	  return crypto.hash160(this.buffer)
	}
	
	// FIXME: doesn't work for data chunks, maybe time to use buffertools.compare...
	Script.prototype.without = function (needle) {
	  return Script.fromChunks(this.chunks.filter(function (op) {
	    return op !== needle
	  }))
	}
	
	var reverseOps = []
	for (var op in opcodes) {
	  var code = opcodes[op]
	  reverseOps[code] = op
	}
	
	Script.prototype.toASM = function () {
	  return this.chunks.map(function (chunk) {
	    // data chunk
	    if (Buffer.isBuffer(chunk)) {
	      return chunk.toString('hex')
	
	    // opcode
	    } else {
	      return reverseOps[chunk]
	    }
	  }).join(' ')
	}
	
	Script.prototype.toBuffer = function () {
	  return this.buffer
	}
	
	Script.prototype.toHex = function () {
	  return this.toBuffer().toString('hex')
	}
	
	module.exports = Script
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(820).Buffer))

/***/ },

/***/ 1311:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var assert = __webpack_require__(1296)
	var opcodes = __webpack_require__(1299)
	
	// https://github.com/feross/buffer/blob/master/index.js#L1127
	function verifuint (value, max) {
	  assert(typeof value === 'number', 'cannot write a non-number as a number')
	  assert(value >= 0, 'specified a negative value for writing an unsigned value')
	  assert(value <= max, 'value is larger than maximum value for type')
	  assert(Math.floor(value) === value, 'value has a fractional component')
	}
	
	function pushDataSize (i) {
	  return i < opcodes.OP_PUSHDATA1 ? 1
	  : i < 0xff ? 2
	  : i < 0xffff ? 3
	  : 5
	}
	
	function readPushDataInt (buffer, offset) {
	  var opcode = buffer.readUInt8(offset)
	  var number, size
	
	  // ~6 bit
	  if (opcode < opcodes.OP_PUSHDATA1) {
	    number = opcode
	    size = 1
	
	  // 8 bit
	  } else if (opcode === opcodes.OP_PUSHDATA1) {
	    if (offset + 2 > buffer.length) return null
	    number = buffer.readUInt8(offset + 1)
	    size = 2
	
	  // 16 bit
	  } else if (opcode === opcodes.OP_PUSHDATA2) {
	    if (offset + 3 > buffer.length) return null
	    number = buffer.readUInt16LE(offset + 1)
	    size = 3
	
	  // 32 bit
	  } else {
	    if (offset + 5 > buffer.length) return null
	    assert.equal(opcode, opcodes.OP_PUSHDATA4, 'Unexpected opcode')
	
	    number = buffer.readUInt32LE(offset + 1)
	    size = 5
	  }
	
	  return {
	    opcode: opcode,
	    number: number,
	    size: size
	  }
	}
	
	function readUInt64LE (buffer, offset) {
	  var a = buffer.readUInt32LE(offset)
	  var b = buffer.readUInt32LE(offset + 4)
	  b *= 0x100000000
	
	  verifuint(b + a, 0x001fffffffffffff)
	
	  return b + a
	}
	
	function readVarInt (buffer, offset) {
	  var t = buffer.readUInt8(offset)
	  var number, size
	
	  // 8 bit
	  if (t < 253) {
	    number = t
	    size = 1
	
	  // 16 bit
	  } else if (t < 254) {
	    number = buffer.readUInt16LE(offset + 1)
	    size = 3
	
	  // 32 bit
	  } else if (t < 255) {
	    number = buffer.readUInt32LE(offset + 1)
	    size = 5
	
	  // 64 bit
	  } else {
	    number = readUInt64LE(buffer, offset + 1)
	    size = 9
	  }
	
	  return {
	    number: number,
	    size: size
	  }
	}
	
	function writePushDataInt (buffer, number, offset) {
	  var size = pushDataSize(number)
	
	  // ~6 bit
	  if (size === 1) {
	    buffer.writeUInt8(number, offset)
	
	  // 8 bit
	  } else if (size === 2) {
	    buffer.writeUInt8(opcodes.OP_PUSHDATA1, offset)
	    buffer.writeUInt8(number, offset + 1)
	
	  // 16 bit
	  } else if (size === 3) {
	    buffer.writeUInt8(opcodes.OP_PUSHDATA2, offset)
	    buffer.writeUInt16LE(number, offset + 1)
	
	  // 32 bit
	  } else {
	    buffer.writeUInt8(opcodes.OP_PUSHDATA4, offset)
	    buffer.writeUInt32LE(number, offset + 1)
	  }
	
	  return size
	}
	
	function writeUInt64LE (buffer, value, offset) {
	  verifuint(value, 0x001fffffffffffff)
	
	  buffer.writeInt32LE(value & -1, offset)
	  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4)
	}
	
	function varIntSize (i) {
	  return i < 253 ? 1
	  : i < 0x10000 ? 3
	  : i < 0x100000000 ? 5
	  : 9
	}
	
	function writeVarInt (buffer, number, offset) {
	  var size = varIntSize(number)
	
	  // 8 bit
	  if (size === 1) {
	    buffer.writeUInt8(number, offset)
	
	  // 16 bit
	  } else if (size === 3) {
	    buffer.writeUInt8(253, offset)
	    buffer.writeUInt16LE(number, offset + 1)
	
	  // 32 bit
	  } else if (size === 5) {
	    buffer.writeUInt8(254, offset)
	    buffer.writeUInt32LE(number, offset + 1)
	
	  // 64 bit
	  } else {
	    buffer.writeUInt8(255, offset)
	    writeUInt64LE(buffer, number, offset + 1)
	  }
	
	  return size
	}
	
	function varIntBuffer (i) {
	  var size = varIntSize(i)
	  var buffer = new Buffer(size)
	  writeVarInt(buffer, i, 0)
	
	  return buffer
	}
	
	function reverse (buffer) {
	  var buffer2 = new Buffer(buffer)
	  Array.prototype.reverse.call(buffer2)
	  return buffer2
	}
	
	module.exports = {
	  pushDataSize: pushDataSize,
	  readPushDataInt: readPushDataInt,
	  readUInt64LE: readUInt64LE,
	  readVarInt: readVarInt,
	  reverse: reverse,
	  varIntBuffer: varIntBuffer,
	  varIntSize: varIntSize,
	  writePushDataInt: writePushDataInt,
	  writeUInt64LE: writeUInt64LE,
	  writeVarInt: writeVarInt
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(820).Buffer))

/***/ },

/***/ 1312:
/***/ function(module, exports, __webpack_require__) {

	var createHash = __webpack_require__(906)
	
	function hash160 (buffer) {
	  return ripemd160(sha256(buffer))
	}
	
	function hash256 (buffer) {
	  return sha256(sha256(buffer))
	}
	
	function ripemd160 (buffer) {
	  return createHash('rmd160').update(buffer).digest()
	}
	
	function sha1 (buffer) {
	  return createHash('sha1').update(buffer).digest()
	}
	
	function sha256 (buffer) {
	  return createHash('sha256').update(buffer).digest()
	}
	
	// FIXME: Name not consistent with others
	var createHmac = __webpack_require__(919)
	
	function HmacSHA256 (buffer, secret) {
	  console.warn('Hmac* functions are deprecated for removal in 2.0.0, use node crypto instead')
	  return createHmac('sha256', secret).update(buffer).digest()
	}
	
	function HmacSHA512 (buffer, secret) {
	  console.warn('Hmac* functions are deprecated for removal in 2.0.0, use node crypto instead')
	  return createHmac('sha512', secret).update(buffer).digest()
	}
	
	module.exports = {
	  ripemd160: ripemd160,
	  sha1: sha1,
	  sha256: sha256,
	  hash160: hash160,
	  hash256: hash256,
	  HmacSHA256: HmacSHA256,
	  HmacSHA512: HmacSHA512
	}


/***/ },

/***/ 1313:
/***/ function(module, exports, __webpack_require__) {

	var bs58check = __webpack_require__(1237)
	
	function decode () {
	  console.warn('bs58check will be removed in 2.0.0. require("bs58check") instead.')
	
	  return bs58check.decode.apply(undefined, arguments)
	}
	
	function encode () {
	  console.warn('bs58check will be removed in 2.0.0. require("bs58check") instead.')
	
	  return bs58check.encode.apply(undefined, arguments)
	}
	
	module.exports = {
	  decode: decode,
	  encode: encode
	}


/***/ },

/***/ 1314:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var assert = __webpack_require__(1296)
	var bufferutils = __webpack_require__(1311)
	var crypto = __webpack_require__(1312)
	
	var Transaction = __webpack_require__(1315)
	
	function Block () {
	  this.version = 1
	  this.prevHash = null
	  this.merkleRoot = null
	  this.timestamp = 0
	  this.bits = 0
	  this.nonce = 0
	}
	
	Block.fromBuffer = function (buffer) {
	  assert(buffer.length >= 80, 'Buffer too small (< 80 bytes)')
	
	  var offset = 0
	  function readSlice (n) {
	    offset += n
	    return buffer.slice(offset - n, offset)
	  }
	
	  function readUInt32 () {
	    var i = buffer.readUInt32LE(offset)
	    offset += 4
	    return i
	  }
	
	  var block = new Block()
	  block.version = readUInt32()
	  block.prevHash = readSlice(32)
	  block.merkleRoot = readSlice(32)
	  block.timestamp = readUInt32()
	  block.bits = readUInt32()
	  block.nonce = readUInt32()
	
	  if (buffer.length === 80) return block
	
	  function readVarInt () {
	    var vi = bufferutils.readVarInt(buffer, offset)
	    offset += vi.size
	    return vi.number
	  }
	
	  // FIXME: poor performance
	  function readTransaction () {
	    var tx = Transaction.fromBuffer(buffer.slice(offset), true)
	
	    offset += tx.toBuffer().length
	    return tx
	  }
	
	  var nTransactions = readVarInt()
	  block.transactions = []
	
	  for (var i = 0; i < nTransactions; ++i) {
	    var tx = readTransaction()
	    block.transactions.push(tx)
	  }
	
	  return block
	}
	
	Block.fromHex = function (hex) {
	  return Block.fromBuffer(new Buffer(hex, 'hex'))
	}
	
	Block.prototype.getHash = function () {
	  return crypto.hash256(this.toBuffer(true))
	}
	
	Block.prototype.getId = function () {
	  return bufferutils.reverse(this.getHash()).toString('hex')
	}
	
	Block.prototype.getUTCDate = function () {
	  var date = new Date(0) // epoch
	  date.setUTCSeconds(this.timestamp)
	
	  return date
	}
	
	Block.prototype.toBuffer = function (headersOnly) {
	  var buffer = new Buffer(80)
	
	  var offset = 0
	  function writeSlice (slice) {
	    slice.copy(buffer, offset)
	    offset += slice.length
	  }
	
	  function writeUInt32 (i) {
	    buffer.writeUInt32LE(i, offset)
	    offset += 4
	  }
	
	  writeUInt32(this.version)
	  writeSlice(this.prevHash)
	  writeSlice(this.merkleRoot)
	  writeUInt32(this.timestamp)
	  writeUInt32(this.bits)
	  writeUInt32(this.nonce)
	
	  if (headersOnly || !this.transactions) return buffer
	
	  var txLenBuffer = bufferutils.varIntBuffer(this.transactions.length)
	  var txBuffers = this.transactions.map(function (tx) {
	    return tx.toBuffer()
	  })
	
	  return Buffer.concat([buffer, txLenBuffer].concat(txBuffers))
	}
	
	Block.prototype.toHex = function (headersOnly) {
	  return this.toBuffer(headersOnly).toString('hex')
	}
	
	module.exports = Block
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(820).Buffer))

/***/ },

/***/ 1315:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var assert = __webpack_require__(1296)
	var bufferutils = __webpack_require__(1311)
	var crypto = __webpack_require__(1312)
	var typeForce = __webpack_require__(1054)
	var opcodes = __webpack_require__(1299)
	var scripts = __webpack_require__(1298)
	
	var Address = __webpack_require__(1295)
	var ECSignature = __webpack_require__(1309)
	var Script = __webpack_require__(1310)
	
	function Transaction () {
	  this.version = 1
	  this.locktime = 0
	  this.ins = []
	  this.outs = []
	}
	
	Transaction.DEFAULT_SEQUENCE = 0xffffffff
	Transaction.SIGHASH_ALL = 0x01
	Transaction.SIGHASH_NONE = 0x02
	Transaction.SIGHASH_SINGLE = 0x03
	Transaction.SIGHASH_ANYONECANPAY = 0x80
	
	Transaction.fromBuffer = function (buffer, __disableAssert) {
	  var offset = 0
	  function readSlice (n) {
	    offset += n
	    return buffer.slice(offset - n, offset)
	  }
	
	  function readUInt32 () {
	    var i = buffer.readUInt32LE(offset)
	    offset += 4
	    return i
	  }
	
	  function readUInt64 () {
	    var i = bufferutils.readUInt64LE(buffer, offset)
	    offset += 8
	    return i
	  }
	
	  function readVarInt () {
	    var vi = bufferutils.readVarInt(buffer, offset)
	    offset += vi.size
	    return vi.number
	  }
	
	  function readScript () {
	    return Script.fromBuffer(readSlice(readVarInt()))
	  }
	
	  function readGenerationScript () {
	    return new Script(readSlice(readVarInt()), [])
	  }
	
	  var tx = new Transaction()
	  tx.version = readUInt32()
	
	  var vinLen = readVarInt()
	  for (var i = 0; i < vinLen; ++i) {
	    var hash = readSlice(32)
	
	    if (Transaction.isCoinbaseHash(hash)) {
	      tx.ins.push({
	        hash: hash,
	        index: readUInt32(),
	        script: readGenerationScript(),
	        sequence: readUInt32()
	      })
	    } else {
	      tx.ins.push({
	        hash: hash,
	        index: readUInt32(),
	        script: readScript(),
	        sequence: readUInt32()
	      })
	    }
	  }
	
	  var voutLen = readVarInt()
	  for (i = 0; i < voutLen; ++i) {
	    tx.outs.push({
	      value: readUInt64(),
	      script: readScript()
	    })
	  }
	
	  tx.locktime = readUInt32()
	
	  if (!__disableAssert) {
	    assert.equal(offset, buffer.length, 'Transaction has unexpected data')
	  }
	
	  return tx
	}
	
	Transaction.fromHex = function (hex) {
	  return Transaction.fromBuffer(new Buffer(hex, 'hex'))
	}
	
	Transaction.isCoinbaseHash = function (buffer) {
	  return Array.prototype.every.call(buffer, function (x) {
	    return x === 0
	  })
	}
	
	/**
	 * Create a new txIn.
	 *
	 * Can be called with any of:
	 *
	 * - A transaction and an index
	 * - A transaction hash and an index
	 *
	 * Note that this method does not sign the created input.
	 */
	Transaction.prototype.addInput = function (hash, index, sequence, script) {
	  if (sequence === undefined || sequence === null) {
	    sequence = Transaction.DEFAULT_SEQUENCE
	  }
	
	  script = script || Script.EMPTY
	
	  if (typeof hash === 'string') {
	    // TxId hex is big-endian, we need little-endian
	    hash = bufferutils.reverse(new Buffer(hash, 'hex'))
	  } else if (hash instanceof Transaction) {
	    hash = hash.getHash()
	  }
	
	  typeForce('Buffer', hash)
	  typeForce('Number', index)
	  typeForce('Number', sequence)
	  typeForce('Script', script)
	
	  assert.equal(hash.length, 32, 'Expected hash length of 32, got ' + hash.length)
	
	  // Add the input and return the input's index
	  return (this.ins.push({
	    hash: hash,
	    index: index,
	    script: script,
	    sequence: sequence
	  }) - 1)
	}
	
	/**
	 * Create a new txOut.
	 *
	 * Can be called with:
	 *
	 * - A base58 address string and a value
	 * - An Address object and a value
	 * - A scriptPubKey Script and a value
	 */
	Transaction.prototype.addOutput = function (scriptPubKey, value) {
	  // Attempt to get a valid address if it's a base58 address string
	  if (typeof scriptPubKey === 'string') {
	    scriptPubKey = Address.fromBase58Check(scriptPubKey)
	  }
	
	  // Attempt to get a valid script if it's an Address object
	  if (scriptPubKey instanceof Address) {
	    scriptPubKey = scriptPubKey.toOutputScript()
	  }
	
	  typeForce('Script', scriptPubKey)
	  typeForce('Number', value)
	
	  // Add the output and return the output's index
	  return (this.outs.push({
	    script: scriptPubKey,
	    value: value
	  }) - 1)
	}
	
	Transaction.prototype.clone = function () {
	  var newTx = new Transaction()
	  newTx.version = this.version
	  newTx.locktime = this.locktime
	
	  newTx.ins = this.ins.map(function (txIn) {
	    return {
	      hash: txIn.hash,
	      index: txIn.index,
	      script: txIn.script,
	      sequence: txIn.sequence
	    }
	  })
	
	  newTx.outs = this.outs.map(function (txOut) {
	    return {
	      script: txOut.script,
	      value: txOut.value
	    }
	  })
	
	  return newTx
	}
	
	/**
	 * Hash transaction for signing a specific input.
	 *
	 * Bitcoin uses a different hash for each signed transaction input. This
	 * method copies the transaction, makes the necessary changes based on the
	 * hashType, serializes and finally hashes the result. This hash can then be
	 * used to sign the transaction input in question.
	 */
	Transaction.prototype.hashForSignature = function (inIndex, prevOutScript, hashType) {
	  // FIXME: remove in 2.x.y
	  if (arguments[0] instanceof Script) {
	    console.warn('hashForSignature(prevOutScript, inIndex, ...) has been deprecated. Use hashForSignature(inIndex, prevOutScript, ...)')
	
	    // swap the arguments (must be stored in tmp, arguments is special)
	    var tmp = arguments[0]
	    inIndex = arguments[1]
	    prevOutScript = tmp
	  }
	
	  typeForce('Number', inIndex)
	  typeForce('Script', prevOutScript)
	  typeForce('Number', hashType)
	
	  assert(inIndex >= 0, 'Invalid vin index')
	  assert(inIndex < this.ins.length, 'Invalid vin index')
	
	  var txTmp = this.clone()
	  var hashScript = prevOutScript.without(opcodes.OP_CODESEPARATOR)
	
	  // Blank out other inputs' signatures
	  txTmp.ins.forEach(function (txIn) {
	    txIn.script = Script.EMPTY
	  })
	  txTmp.ins[inIndex].script = hashScript
	
	  var hashTypeModifier = hashType & 0x1f
	
	  if (hashTypeModifier === Transaction.SIGHASH_NONE) {
	    assert(false, 'SIGHASH_NONE not yet supported')
	  } else if (hashTypeModifier === Transaction.SIGHASH_SINGLE) {
	    assert(false, 'SIGHASH_SINGLE not yet supported')
	  }
	
	  if (hashType & Transaction.SIGHASH_ANYONECANPAY) {
	    assert(false, 'SIGHASH_ANYONECANPAY not yet supported')
	  }
	
	  var hashTypeBuffer = new Buffer(4)
	  hashTypeBuffer.writeInt32LE(hashType, 0)
	
	  var buffer = Buffer.concat([txTmp.toBuffer(), hashTypeBuffer])
	  return crypto.hash256(buffer)
	}
	
	Transaction.prototype.getHash = function () {
	  return crypto.hash256(this.toBuffer())
	}
	
	Transaction.prototype.getId = function () {
	  // TxHash is little-endian, we need big-endian
	  return bufferutils.reverse(this.getHash()).toString('hex')
	}
	
	Transaction.prototype.toBuffer = function () {
	  function scriptSize (script) {
	    var length = script.buffer.length
	
	    return bufferutils.varIntSize(length) + length
	  }
	
	  var buffer = new Buffer(
	    8 +
	    bufferutils.varIntSize(this.ins.length) +
	    bufferutils.varIntSize(this.outs.length) +
	    this.ins.reduce(function (sum, input) { return sum + 40 + scriptSize(input.script) }, 0) +
	    this.outs.reduce(function (sum, output) { return sum + 8 + scriptSize(output.script) }, 0)
	  )
	
	  var offset = 0
	  function writeSlice (slice) {
	    slice.copy(buffer, offset)
	    offset += slice.length
	  }
	
	  function writeUInt32 (i) {
	    buffer.writeUInt32LE(i, offset)
	    offset += 4
	  }
	
	  function writeUInt64 (i) {
	    bufferutils.writeUInt64LE(buffer, i, offset)
	    offset += 8
	  }
	
	  function writeVarInt (i) {
	    var n = bufferutils.writeVarInt(buffer, i, offset)
	    offset += n
	  }
	
	  writeUInt32(this.version)
	  writeVarInt(this.ins.length)
	
	  this.ins.forEach(function (txIn) {
	    writeSlice(txIn.hash)
	    writeUInt32(txIn.index)
	    writeVarInt(txIn.script.buffer.length)
	    writeSlice(txIn.script.buffer)
	    writeUInt32(txIn.sequence)
	  })
	
	  writeVarInt(this.outs.length)
	  this.outs.forEach(function (txOut) {
	    writeUInt64(txOut.value)
	    writeVarInt(txOut.script.buffer.length)
	    writeSlice(txOut.script.buffer)
	  })
	
	  writeUInt32(this.locktime)
	
	  return buffer
	}
	
	Transaction.prototype.toHex = function () {
	  return this.toBuffer().toString('hex')
	}
	
	Transaction.prototype.setInputScript = function (index, script) {
	  typeForce('Number', index)
	  typeForce('Script', script)
	
	  this.ins[index].script = script
	}
	
	// FIXME: remove in 2.x.y
	Transaction.prototype.sign = function (index, privKey, hashType) {
	  console.warn('Transaction.prototype.sign is deprecated.  Use TransactionBuilder instead.')
	
	  var prevOutScript = privKey.pub.getAddress().toOutputScript()
	  var signature = this.signInput(index, prevOutScript, privKey, hashType)
	
	  var scriptSig = scripts.pubKeyHashInput(signature, privKey.pub)
	  this.setInputScript(index, scriptSig)
	}
	
	// FIXME: remove in 2.x.y
	Transaction.prototype.signInput = function (index, prevOutScript, privKey, hashType) {
	  console.warn('Transaction.prototype.signInput is deprecated.  Use TransactionBuilder instead.')
	
	  hashType = hashType || Transaction.SIGHASH_ALL
	
	  var hash = this.hashForSignature(index, prevOutScript, hashType)
	  var signature = privKey.sign(hash)
	
	  return signature.toScriptSignature(hashType)
	}
	
	// FIXME: remove in 2.x.y
	Transaction.prototype.validateInput = function (index, prevOutScript, pubKey, buffer) {
	  console.warn('Transaction.prototype.validateInput is deprecated.  Use TransactionBuilder instead.')
	
	  var parsed = ECSignature.parseScriptSignature(buffer)
	  var hash = this.hashForSignature(index, prevOutScript, parsed.hashType)
	
	  return pubKey.verify(hash, parsed.signature)
	}
	
	module.exports = Transaction
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(820).Buffer))

/***/ },

/***/ 1316:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var assert = __webpack_require__(1296)
	var createHmac = __webpack_require__(919)
	var typeForce = __webpack_require__(1054)
	
	var BigInteger = __webpack_require__(1302)
	var ECSignature = __webpack_require__(1309)
	
	var ZERO = new Buffer([0])
	var ONE = new Buffer([1])
	
	// https://tools.ietf.org/html/rfc6979#section-3.2
	function deterministicGenerateK (curve, hash, d, checkSig) {
	  typeForce('Buffer', hash)
	  typeForce('BigInteger', d)
	
	  // FIXME: remove/uncomment for 2.0.0
	  //  typeForce('Function', checkSig)
	
	  if (typeof checkSig !== 'function') {
	    console.warn('deterministicGenerateK requires a checkSig callback in 2.0.0, see #337 for more information')
	
	    checkSig = function (k) {
	      var G = curve.G
	      var n = curve.n
	      var e = BigInteger.fromBuffer(hash)
	
	      var Q = G.multiply(k)
	
	      if (curve.isInfinity(Q))
	        return false
	
	      var r = Q.affineX.mod(n)
	      if (r.signum() === 0)
	        return false
	
	      var s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n)
	      if (s.signum() === 0)
	        return false
	
	      return true
	    }
	  }
	
	  // sanity check
	  assert.equal(hash.length, 32, 'Hash must be 256 bit')
	
	  var x = d.toBuffer(32)
	  var k = new Buffer(32)
	  var v = new Buffer(32)
	
	  // Step A, ignored as hash already provided
	  // Step B
	  v.fill(1)
	
	  // Step C
	  k.fill(0)
	
	  // Step D
	  k = createHmac('sha256', k)
	    .update(v)
	    .update(ZERO)
	    .update(x)
	    .update(hash)
	    .digest()
	
	  // Step E
	  v = createHmac('sha256', k).update(v).digest()
	
	  // Step F
	  k = createHmac('sha256', k)
	    .update(v)
	    .update(ONE)
	    .update(x)
	    .update(hash)
	    .digest()
	
	  // Step G
	  v = createHmac('sha256', k).update(v).digest()
	
	  // Step H1/H2a, ignored as tlen === qlen (256 bit)
	  // Step H2b
	  v = createHmac('sha256', k).update(v).digest()
	
	  var T = BigInteger.fromBuffer(v)
	
	  // Step H3, repeat until T is within the interval [1, n - 1] and is suitable for ECDSA
	  while ((T.signum() <= 0) || (T.compareTo(curve.n) >= 0) || !checkSig(T)) {
	    k = createHmac('sha256', k)
	      .update(v)
	      .update(ZERO)
	      .digest()
	
	    v = createHmac('sha256', k).update(v).digest()
	
	    // Step H1/H2a, again, ignored as tlen === qlen (256 bit)
	    // Step H2b again
	    v = createHmac('sha256', k).update(v).digest()
	    T = BigInteger.fromBuffer(v)
	  }
	
	  return T
	}
	
	function sign (curve, hash, d) {
	  var r, s
	
	  var e = BigInteger.fromBuffer(hash)
	  var n = curve.n
	  var G = curve.G
	
	  deterministicGenerateK(curve, hash, d, function (k) {
	    var Q = G.multiply(k)
	
	    if (curve.isInfinity(Q))
	      return false
	
	    r = Q.affineX.mod(n)
	    if (r.signum() === 0)
	      return false
	
	    s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n)
	    if (s.signum() === 0)
	      return false
	
	    return true
	  })
	
	  var N_OVER_TWO = n.shiftRight(1)
	
	  // enforce low S values, see bip62: 'low s values in signatures'
	  if (s.compareTo(N_OVER_TWO) > 0) {
	    s = n.subtract(s)
	  }
	
	  return new ECSignature(r, s)
	}
	
	function verifyRaw (curve, e, signature, Q) {
	  var n = curve.n
	  var G = curve.G
	
	  var r = signature.r
	  var s = signature.s
	
	  // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1]
	  if (r.signum() <= 0 || r.compareTo(n) >= 0) return false
	  if (s.signum() <= 0 || s.compareTo(n) >= 0) return false
	
	  // c = s^-1 mod n
	  var c = s.modInverse(n)
	
	  // 1.4.4 Compute u1 = es^−1 mod n
	  //               u2 = rs^−1 mod n
	  var u1 = e.multiply(c).mod(n)
	  var u2 = r.multiply(c).mod(n)
	
	  // 1.4.5 Compute R = (xR, yR) = u1G + u2Q
	  var R = G.multiplyTwo(u1, Q, u2)
	  var v = R.affineX.mod(n)
	
	  // 1.4.5 (cont.) Enforce R is not at infinity
	  if (curve.isInfinity(R)) return false
	
	  // 1.4.8 If v = r, output "valid", and if v != r, output "invalid"
	  return v.equals(r)
	}
	
	function verify (curve, hash, signature, Q) {
	  // 1.4.2 H = Hash(M), already done by the user
	  // 1.4.3 e = H
	  var e = BigInteger.fromBuffer(hash)
	
	  return verifyRaw(curve, e, signature, Q)
	}
	
	/**
	  * Recover a public key from a signature.
	  *
	  * See SEC 1: Elliptic Curve Cryptography, section 4.1.6, "Public
	  * Key Recovery Operation".
	  *
	  * http://www.secg.org/download/aid-780/sec1-v2.pdf
	  */
	function recoverPubKey (curve, e, signature, i) {
	  assert.strictEqual(i & 3, i, 'Recovery param is more than two bits')
	
	  var n = curve.n
	  var G = curve.G
	
	  var r = signature.r
	  var s = signature.s
	
	  assert(r.signum() > 0 && r.compareTo(n) < 0, 'Invalid r value')
	  assert(s.signum() > 0 && s.compareTo(n) < 0, 'Invalid s value')
	
	  // A set LSB signifies that the y-coordinate is odd
	  var isYOdd = i & 1
	
	  // The more significant bit specifies whether we should use the
	  // first or second candidate key.
	  var isSecondKey = i >> 1
	
	  // 1.1 Let x = r + jn
	  var x = isSecondKey ? r.add(n) : r
	  var R = curve.pointFromX(isYOdd, x)
	
	  // 1.4 Check that nR is at infinity
	  var nR = R.multiply(n)
	  assert(curve.isInfinity(nR), 'nR is not a valid curve point')
	
	  // Compute -e from e
	  var eNeg = e.negate().mod(n)
	
	  // 1.6.1 Compute Q = r^-1 (sR -  eG)
	  //               Q = r^-1 (sR + -eG)
	  var rInv = r.modInverse(n)
	
	  var Q = R.multiplyTwo(s, G, eNeg).multiply(rInv)
	  curve.validate(Q)
	
	  return Q
	}
	
	/**
	  * Calculate pubkey extraction parameter.
	  *
	  * When extracting a pubkey from a signature, we have to
	  * distinguish four different cases. Rather than putting this
	  * burden on the verifier, Bitcoin includes a 2-bit value with the
	  * signature.
	  *
	  * This function simply tries all four cases and returns the value
	  * that resulted in a successful pubkey recovery.
	  */
	function calcPubKeyRecoveryParam (curve, e, signature, Q) {
	  for (var i = 0; i < 4; i++) {
	    var Qprime = recoverPubKey(curve, e, signature, i)
	
	    // 1.6.2 Verify Q
	    if (Qprime.equals(Q)) {
	      return i
	    }
	  }
	
	  throw new Error('Unable to find valid recovery factor')
	}
	
	module.exports = {
	  calcPubKeyRecoveryParam: calcPubKeyRecoveryParam,
	  deterministicGenerateK: deterministicGenerateK,
	  recoverPubKey: recoverPubKey,
	  sign: sign,
	  verify: verify,
	  verifyRaw: verifyRaw
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(820).Buffer))

/***/ },

/***/ 1317:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var assert = __webpack_require__(1296)
	var base58check = __webpack_require__(1237)
	var ecdsa = __webpack_require__(1316)
	var networks = __webpack_require__(1297)
	var randomBytes = __webpack_require__(905)
	var typeForce = __webpack_require__(1054)
	
	var BigInteger = __webpack_require__(1302)
	var ECPubKey = __webpack_require__(1318)
	
	var ecurve = __webpack_require__(1300)
	var secp256k1 = ecurve.getCurveByName('secp256k1')
	
	function ECKey (d, compressed) {
	  assert(d.signum() > 0, 'Private key must be greater than 0')
	  assert(d.compareTo(ECKey.curve.n) < 0, 'Private key must be less than the curve order')
	
	  this.d = d
	  this.compressed = compressed
	}
	
	// Constants
	ECKey.curve = secp256k1
	
	Object.defineProperty(ECKey.prototype, 'pub', {
	  get: function () {
	    if (!this.__pub && this.d) {
	      var Q = ECKey.curve.G.multiply(this.d)
	      this.__pub = new ECPubKey(Q, this.compressed)
	    }
	
	    return this.__pub
	  }
	})
	
	// Static constructors
	ECKey.fromWIF = function (string) {
	  var payload = base58check.decode(string)
	  var compressed = false
	
	  // Ignore the version byte
	  payload = payload.slice(1)
	
	  if (payload.length === 33) {
	    assert.strictEqual(payload[32], 0x01, 'Invalid compression flag')
	
	    // Truncate the compression flag
	    payload = payload.slice(0, -1)
	    compressed = true
	  }
	
	  assert.equal(payload.length, 32, 'Invalid WIF payload length')
	
	  var d = BigInteger.fromBuffer(payload)
	  return new ECKey(d, compressed)
	}
	
	ECKey.makeRandom = function (compressed, rng, callback) {
	  rng = rng || randomBytes
	
	  var async = !!callback
	  return rand(32, function (err, buffer) {
	    if (err) {
	      if (async) return callback(err)
	      else throw err
	    }
	
	    typeForce('Buffer', buffer)
	    assert.equal(buffer.length, 32, 'Expected 256-bit Buffer from RNG')
	
	    var d = BigInteger.fromBuffer(buffer)
	    d = d.mod(ECKey.curve.n)
	
	    var key = new ECKey(d, compressed)
	    if (callback) callback(null, key)
	
	    return key
	  })
	
	  function rand (size, rCallback) {
	    // async
	    if (!async) return rCallback(null, rng(size))
	
	    rng(size, function (err, bytes) {
	      rCallback(err, bytes)
	    })
	  }
	}
	
	// Export functions
	ECKey.prototype.toWIF = function (network) {
	  network = network || networks.bitcoin
	
	  var bufferLen = this.pub.compressed ? 34 : 33
	  var buffer = new Buffer(bufferLen)
	
	  buffer.writeUInt8(network.wif, 0)
	  this.d.toBuffer(32).copy(buffer, 1)
	
	  if (this.pub.compressed) {
	    buffer.writeUInt8(0x01, 33)
	  }
	
	  return base58check.encode(buffer)
	}
	
	// Operations
	ECKey.prototype.sign = function (hash) {
	  return ecdsa.sign(ECKey.curve, hash, this.d)
	}
	
	module.exports = ECKey
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(820).Buffer))

/***/ },

/***/ 1318:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var crypto = __webpack_require__(1312)
	var ecdsa = __webpack_require__(1316)
	var typeForce = __webpack_require__(1054)
	var networks = __webpack_require__(1297)
	
	var Address = __webpack_require__(1295)
	
	var ecurve = __webpack_require__(1300)
	var secp256k1 = ecurve.getCurveByName('secp256k1')
	
	function ECPubKey (Q, compressed) {
	  if (compressed === undefined) {
	    compressed = true
	  }
	
	  typeForce('Point', Q)
	  typeForce('Boolean', compressed)
	
	  this.compressed = compressed
	  this.Q = Q
	}
	
	// Constants
	ECPubKey.curve = secp256k1
	
	// Static constructors
	ECPubKey.fromBuffer = function (buffer) {
	  var Q = ecurve.Point.decodeFrom(ECPubKey.curve, buffer)
	  return new ECPubKey(Q, Q.compressed)
	}
	
	ECPubKey.fromHex = function (hex) {
	  return ECPubKey.fromBuffer(new Buffer(hex, 'hex'))
	}
	
	// Operations
	ECPubKey.prototype.getAddress = function (network) {
	  network = network || networks.bitcoin
	
	  return new Address(crypto.hash160(this.toBuffer()), network.pubKeyHash)
	}
	
	ECPubKey.prototype.verify = function (hash, signature) {
	  return ecdsa.verify(ECPubKey.curve, hash, signature, this.Q)
	}
	
	// Export functions
	ECPubKey.prototype.toBuffer = function () {
	  return this.Q.getEncoded(this.compressed)
	}
	
	ECPubKey.prototype.toHex = function () {
	  return this.toBuffer().toString('hex')
	}
	
	module.exports = ECPubKey
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(820).Buffer))

/***/ },

/***/ 1319:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var bufferutils = __webpack_require__(1311)
	var crypto = __webpack_require__(1312)
	var ecdsa = __webpack_require__(1316)
	var networks = __webpack_require__(1297)
	
	var BigInteger = __webpack_require__(1302)
	var ECPubKey = __webpack_require__(1318)
	var ECSignature = __webpack_require__(1309)
	
	var ecurve = __webpack_require__(1300)
	var ecparams = ecurve.getCurveByName('secp256k1')
	
	function magicHash (message, network) {
	  var magicPrefix = new Buffer(network.magicPrefix)
	  var messageBuffer = new Buffer(message)
	  var lengthBuffer = bufferutils.varIntBuffer(messageBuffer.length)
	
	  var buffer = Buffer.concat([magicPrefix, lengthBuffer, messageBuffer])
	  return crypto.hash256(buffer)
	}
	
	function sign (privKey, message, network) {
	  network = network || networks.bitcoin
	
	  var hash = magicHash(message, network)
	  var signature = privKey.sign(hash)
	  var e = BigInteger.fromBuffer(hash)
	  var i = ecdsa.calcPubKeyRecoveryParam(ecparams, e, signature, privKey.pub.Q)
	
	  return signature.toCompact(i, privKey.pub.compressed)
	}
	
	// TODO: network could be implied from address
	function verify (address, signature, message, network) {
	  if (!Buffer.isBuffer(signature)) {
	    signature = new Buffer(signature, 'base64')
	  }
	
	  network = network || networks.bitcoin
	
	  var hash = magicHash(message, network)
	  var parsed = ECSignature.parseCompact(signature)
	  var e = BigInteger.fromBuffer(hash)
	  var Q = ecdsa.recoverPubKey(ecparams, e, parsed.signature, parsed.i)
	
	  var pubKey = new ECPubKey(Q, parsed.compressed)
	  return pubKey.getAddress(network).toString() === address.toString()
	}
	
	module.exports = {
	  magicHash: magicHash,
	  sign: sign,
	  verify: verify
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(820).Buffer))

/***/ },

/***/ 1320:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var assert = __webpack_require__(1296)
	var base58check = __webpack_require__(1237)
	var bcrypto = __webpack_require__(1312)
	var createHmac = __webpack_require__(919)
	var typeForce = __webpack_require__(1054)
	var networks = __webpack_require__(1297)
	
	var BigInteger = __webpack_require__(1302)
	var ECKey = __webpack_require__(1317)
	var ECPubKey = __webpack_require__(1318)
	
	var ecurve = __webpack_require__(1300)
	var curve = ecurve.getCurveByName('secp256k1')
	
	function findBIP32NetworkByVersion (version) {
	  for (var name in networks) {
	    var network = networks[name]
	
	    if (version === network.bip32.private || version === network.bip32.public) {
	      return network
	    }
	  }
	
	  assert(false, 'Could not find network for ' + version.toString(16))
	}
	
	function HDNode (K, chainCode, network) {
	  network = network || networks.bitcoin
	
	  typeForce('Buffer', chainCode)
	
	  assert.equal(chainCode.length, 32, 'Expected chainCode length of 32, got ' + chainCode.length)
	  assert(network.bip32, 'Unknown BIP32 constants for network')
	
	  this.chainCode = chainCode
	  this.depth = 0
	  this.index = 0
	  this.parentFingerprint = 0x00000000
	  this.network = network
	
	  if (K instanceof BigInteger) {
	    this.privKey = new ECKey(K, true)
	    this.pubKey = this.privKey.pub
	  } else if (K instanceof ECKey) {
	    assert(K.pub.compressed, 'ECKey must be compressed')
	    this.privKey = K
	    this.pubKey = K.pub
	  } else if (K instanceof ECPubKey) {
	    assert(K.compressed, 'ECPubKey must be compressed')
	    this.pubKey = K
	  } else {
	    this.pubKey = new ECPubKey(K, true)
	  }
	}
	
	HDNode.MASTER_SECRET = new Buffer('Bitcoin seed')
	HDNode.HIGHEST_BIT = 0x80000000
	HDNode.LENGTH = 78
	
	HDNode.fromSeedBuffer = function (seed, network) {
	  typeForce('Buffer', seed)
	
	  assert(seed.length >= 16, 'Seed should be at least 128 bits')
	  assert(seed.length <= 64, 'Seed should be at most 512 bits')
	
	  var I = createHmac('sha512', HDNode.MASTER_SECRET).update(seed).digest()
	  var IL = I.slice(0, 32)
	  var IR = I.slice(32)
	
	  // In case IL is 0 or >= n, the master key is invalid
	  // This is handled by `new ECKey` in the HDNode constructor
	  var pIL = BigInteger.fromBuffer(IL)
	
	  return new HDNode(pIL, IR, network)
	}
	
	HDNode.fromSeedHex = function (hex, network) {
	  return HDNode.fromSeedBuffer(new Buffer(hex, 'hex'), network)
	}
	
	HDNode.fromBase58 = function (string, network) {
	  return HDNode.fromBuffer(base58check.decode(string), network, true)
	}
	
	// FIXME: remove in 2.x.y
	HDNode.fromBuffer = function (buffer, network, __ignoreDeprecation) {
	  if (!__ignoreDeprecation) {
	    console.warn('HDNode.fromBuffer() is deprecated for removal in 2.x.y, use fromBase58 instead')
	  }
	
	  assert.strictEqual(buffer.length, HDNode.LENGTH, 'Invalid buffer length')
	
	  // 4 byte: version bytes
	  var version = buffer.readUInt32BE(0)
	
	  if (network) {
	    assert(version === network.bip32.private || version === network.bip32.public, "Network doesn't match")
	
	  // auto-detect
	  } else {
	    network = findBIP32NetworkByVersion(version)
	  }
	
	  // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...
	  var depth = buffer.readUInt8(4)
	
	  // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)
	  var parentFingerprint = buffer.readUInt32BE(5)
	  if (depth === 0) {
	    assert.strictEqual(parentFingerprint, 0x00000000, 'Invalid parent fingerprint')
	  }
	
	  // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.
	  // This is encoded in MSB order. (0x00000000 if master key)
	  var index = buffer.readUInt32BE(9)
	  assert(depth > 0 || index === 0, 'Invalid index')
	
	  // 32 bytes: the chain code
	  var chainCode = buffer.slice(13, 45)
	  var data, hd
	
	  // 33 bytes: private key data (0x00 + k)
	  if (version === network.bip32.private) {
	    assert.strictEqual(buffer.readUInt8(45), 0x00, 'Invalid private key')
	    data = buffer.slice(46, 78)
	    var d = BigInteger.fromBuffer(data)
	    hd = new HDNode(d, chainCode, network)
	
	  // 33 bytes: public key data (0x02 + X or 0x03 + X)
	  } else {
	    data = buffer.slice(45, 78)
	    var Q = ecurve.Point.decodeFrom(curve, data)
	    assert.equal(Q.compressed, true, 'Invalid public key')
	
	    // Verify that the X coordinate in the public point corresponds to a point on the curve.
	    // If not, the extended public key is invalid.
	    curve.validate(Q)
	
	    hd = new HDNode(Q, chainCode, network)
	  }
	
	  hd.depth = depth
	  hd.index = index
	  hd.parentFingerprint = parentFingerprint
	
	  return hd
	}
	
	// FIXME: remove in 2.x.y
	HDNode.fromHex = function (hex, network) {
	  return HDNode.fromBuffer(new Buffer(hex, 'hex'), network)
	}
	
	HDNode.prototype.getIdentifier = function () {
	  return bcrypto.hash160(this.pubKey.toBuffer())
	}
	
	HDNode.prototype.getFingerprint = function () {
	  return this.getIdentifier().slice(0, 4)
	}
	
	HDNode.prototype.getAddress = function () {
	  return this.pubKey.getAddress(this.network)
	}
	
	HDNode.prototype.neutered = function () {
	  var neutered = new HDNode(this.pubKey.Q, this.chainCode, this.network)
	  neutered.depth = this.depth
	  neutered.index = this.index
	  neutered.parentFingerprint = this.parentFingerprint
	
	  return neutered
	}
	
	HDNode.prototype.toBase58 = function (isPrivate) {
	  return base58check.encode(this.toBuffer(isPrivate, true))
	}
	
	// FIXME: remove in 2.x.y
	HDNode.prototype.toBuffer = function (isPrivate, __ignoreDeprecation) {
	  if (isPrivate === undefined) {
	    isPrivate = !!this.privKey
	
	  // FIXME: remove in 2.x.y
	  } else {
	    console.warn('isPrivate flag is deprecated, please use the .neutered() method instead')
	  }
	
	  if (!__ignoreDeprecation) {
	    console.warn('HDNode.toBuffer() is deprecated for removal in 2.x.y, use toBase58 instead')
	  }
	
	  // Version
	  var version = isPrivate ? this.network.bip32.private : this.network.bip32.public
	  var buffer = new Buffer(HDNode.LENGTH)
	
	  // 4 bytes: version bytes
	  buffer.writeUInt32BE(version, 0)
	
	  // Depth
	  // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....
	  buffer.writeUInt8(this.depth, 4)
	
	  // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)
	  buffer.writeUInt32BE(this.parentFingerprint, 5)
	
	  // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.
	  // This is encoded in Big endian. (0x00000000 if master key)
	  buffer.writeUInt32BE(this.index, 9)
	
	  // 32 bytes: the chain code
	  this.chainCode.copy(buffer, 13)
	
	  // 33 bytes: the public key or private key data
	  if (isPrivate) {
	    // FIXME: remove in 2.x.y
	    assert(this.privKey, 'Missing private key')
	
	    // 0x00 + k for private keys
	    buffer.writeUInt8(0, 45)
	    this.privKey.d.toBuffer(32).copy(buffer, 46)
	  } else {
	    // X9.62 encoding for public keys
	    this.pubKey.toBuffer().copy(buffer, 45)
	  }
	
	  return buffer
	}
	
	// FIXME: remove in 2.x.y
	HDNode.prototype.toHex = function (isPrivate) {
	  return this.toBuffer(isPrivate).toString('hex')
	}
	
	// https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions
	HDNode.prototype.derive = function (index) {
	  var isHardened = index >= HDNode.HIGHEST_BIT
	  var indexBuffer = new Buffer(4)
	  indexBuffer.writeUInt32BE(index, 0)
	
	  var data
	
	  // Hardened child
	  if (isHardened) {
	    assert(this.privKey, 'Could not derive hardened child key')
	
	    // data = 0x00 || ser256(kpar) || ser32(index)
	    data = Buffer.concat([
	      this.privKey.d.toBuffer(33),
	      indexBuffer
	    ])
	
	  // Normal child
	  } else {
	    // data = serP(point(kpar)) || ser32(index)
	    //      = serP(Kpar) || ser32(index)
	    data = Buffer.concat([
	      this.pubKey.toBuffer(),
	      indexBuffer
	    ])
	  }
	
	  var I = createHmac('sha512', this.chainCode).update(data).digest()
	  var IL = I.slice(0, 32)
	  var IR = I.slice(32)
	
	  var pIL = BigInteger.fromBuffer(IL)
	
	  // In case parse256(IL) >= n, proceed with the next value for i
	  if (pIL.compareTo(curve.n) >= 0) {
	    return this.derive(index + 1)
	  }
	
	  // Private parent key -> private child key
	  var hd
	  if (this.privKey) {
	    // ki = parse256(IL) + kpar (mod n)
	    var ki = pIL.add(this.privKey.d).mod(curve.n)
	
	    // In case ki == 0, proceed with the next value for i
	    if (ki.signum() === 0) {
	      return this.derive(index + 1)
	    }
	
	    hd = new HDNode(ki, IR, this.network)
	
	  // Public parent key -> public child key
	  } else {
	    // Ki = point(parse256(IL)) + Kpar
	    //    = G*IL + Kpar
	    var Ki = curve.G.multiply(pIL).add(this.pubKey.Q)
	
	    // In case Ki is the point at infinity, proceed with the next value for i
	    if (curve.isInfinity(Ki)) {
	      return this.derive(index + 1)
	    }
	
	    hd = new HDNode(Ki, IR, this.network)
	  }
	
	  hd.depth = this.depth + 1
	  hd.index = index
	  hd.parentFingerprint = this.getFingerprint().readUInt32BE(0)
	
	  return hd
	}
	
	HDNode.prototype.deriveHardened = function (index) {
	  // Only derives hardened private keys by default
	  return this.derive(index + HDNode.HIGHEST_BIT)
	}
	
	HDNode.prototype.toString = HDNode.prototype.toBase58
	
	module.exports = HDNode
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(820).Buffer))

/***/ },

/***/ 1321:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var assert = __webpack_require__(1296)
	var ops = __webpack_require__(1299)
	var scripts = __webpack_require__(1298)
	
	var ECPubKey = __webpack_require__(1318)
	var ECSignature = __webpack_require__(1309)
	var Script = __webpack_require__(1310)
	var Transaction = __webpack_require__(1315)
	
	function extractInput (txIn) {
	  var redeemScript
	  var scriptSig = txIn.script
	  var prevOutScript
	  var prevOutType = scripts.classifyInput(scriptSig, true)
	  var scriptType
	
	  // Re-classify if scriptHash
	  if (prevOutType === 'scripthash') {
	    redeemScript = Script.fromBuffer(scriptSig.chunks.slice(-1)[0])
	    prevOutScript = scripts.scriptHashOutput(redeemScript.getHash())
	
	    scriptSig = Script.fromChunks(scriptSig.chunks.slice(0, -1))
	    scriptType = scripts.classifyInput(scriptSig, true)
	  } else {
	    scriptType = prevOutType
	  }
	
	  // Extract hashType, pubKeys and signatures
	  var hashType, parsed, pubKeys, signatures
	
	  switch (scriptType) {
	    case 'pubkeyhash': {
	      parsed = ECSignature.parseScriptSignature(scriptSig.chunks[0])
	      hashType = parsed.hashType
	      pubKeys = [ECPubKey.fromBuffer(scriptSig.chunks[1])]
	      signatures = [parsed.signature]
	      prevOutScript = pubKeys[0].getAddress().toOutputScript()
	
	      break
	    }
	
	    case 'pubkey': {
	      parsed = ECSignature.parseScriptSignature(scriptSig.chunks[0])
	      hashType = parsed.hashType
	      signatures = [parsed.signature]
	
	      if (redeemScript) {
	        pubKeys = [ECPubKey.fromBuffer(redeemScript.chunks[0])]
	      }
	
	      break
	    }
	
	    case 'multisig': {
	      signatures = scriptSig.chunks.slice(1).map(function (chunk) {
	        if (chunk === ops.OP_0) return chunk
	
	        var parsed = ECSignature.parseScriptSignature(chunk)
	        hashType = parsed.hashType
	
	        return parsed.signature
	      })
	
	      if (redeemScript) {
	        pubKeys = redeemScript.chunks.slice(1, -2).map(ECPubKey.fromBuffer)
	      }
	
	      break
	    }
	  }
	
	  return {
	    hashType: hashType,
	    prevOutScript: prevOutScript,
	    prevOutType: prevOutType,
	    pubKeys: pubKeys,
	    redeemScript: redeemScript,
	    scriptType: scriptType,
	    signatures: signatures
	  }
	}
	
	function TransactionBuilder () {
	  this.prevTxMap = {}
	  this.prevOutScripts = {}
	  this.prevOutTypes = {}
	
	  this.inputs = []
	  this.tx = new Transaction()
	}
	
	TransactionBuilder.fromTransaction = function (transaction) {
	  var txb = new TransactionBuilder()
	
	  // Copy other transaction fields
	  txb.tx.version = transaction.version
	  txb.tx.locktime = transaction.locktime
	
	  // Extract/add inputs
	  transaction.ins.forEach(function (txIn) {
	    txb.addInput(txIn.hash, txIn.index, txIn.sequence)
	  })
	
	  // Extract/add outputs
	  transaction.outs.forEach(function (txOut) {
	    txb.addOutput(txOut.script, txOut.value)
	  })
	
	  // Extract/add signatures
	  txb.inputs = transaction.ins.map(function (txIn) {
	    // TODO: remove me after testcase added
	    assert(!Transaction.isCoinbaseHash(txIn.hash), 'coinbase inputs not supported')
	
	    // Ignore empty scripts
	    if (txIn.script.buffer.length === 0) return {}
	
	    return extractInput(txIn)
	  })
	
	  return txb
	}
	
	TransactionBuilder.prototype.addInput = function (prevTx, index, sequence, prevOutScript) {
	  var prevOutHash
	
	  // txId
	  if (typeof prevTx === 'string') {
	    prevOutHash = new Buffer(prevTx, 'hex')
	
	    // TxId hex is big-endian, we want little-endian hash
	    Array.prototype.reverse.call(prevOutHash)
	
	  // Transaction
	  } else if (prevTx instanceof Transaction) {
	    prevOutHash = prevTx.getHash()
	    prevOutScript = prevTx.outs[index].script
	
	  // txHash
	  } else {
	    prevOutHash = prevTx
	  }
	
	  var input = {}
	  if (prevOutScript) {
	    var prevOutType = scripts.classifyOutput(prevOutScript)
	
	    // if we can, extract pubKey information
	    switch (prevOutType) {
	      case 'multisig': {
	        input.pubKeys = prevOutScript.chunks.slice(1, -2).map(ECPubKey.fromBuffer)
	        break
	      }
	
	      case 'pubkey': {
	        input.pubKeys = prevOutScript.chunks.slice(0, 1).map(ECPubKey.fromBuffer)
	        break
	      }
	    }
	
	    if (prevOutType !== 'scripthash') {
	      input.scriptType = prevOutType
	    }
	
	    input.prevOutScript = prevOutScript
	    input.prevOutType = prevOutType
	  }
	
	  assert(this.inputs.every(function (input2) {
	    if (input2.hashType === undefined) return true
	
	    return input2.hashType & Transaction.SIGHASH_ANYONECANPAY
	  }), 'No, this would invalidate signatures')
	
	  var prevOut = prevOutHash.toString('hex') + ':' + index
	  assert(!(prevOut in this.prevTxMap), 'Transaction is already an input')
	
	  var vin = this.tx.addInput(prevOutHash, index, sequence)
	  this.inputs[vin] = input
	  this.prevTxMap[prevOut] = vin
	
	  return vin
	}
	
	TransactionBuilder.prototype.addOutput = function (scriptPubKey, value) {
	  assert(this.inputs.every(function (input) {
	    if (input.hashType === undefined) return true
	
	    return (input.hashType & 0x1f) === Transaction.SIGHASH_SINGLE
	  }), 'No, this would invalidate signatures')
	
	  return this.tx.addOutput(scriptPubKey, value)
	}
	
	TransactionBuilder.prototype.build = function () {
	  return this.__build(false)
	}
	TransactionBuilder.prototype.buildIncomplete = function () {
	  return this.__build(true)
	}
	
	var canSignTypes = {
	  'pubkeyhash': true,
	  'multisig': true,
	  'pubkey': true
	}
	
	TransactionBuilder.prototype.__build = function (allowIncomplete) {
	  if (!allowIncomplete) {
	    assert(this.tx.ins.length > 0, 'Transaction has no inputs')
	    assert(this.tx.outs.length > 0, 'Transaction has no outputs')
	  }
	
	  var tx = this.tx.clone()
	
	  // Create script signatures from signature meta-data
	  this.inputs.forEach(function (input, index) {
	    var scriptType = input.scriptType
	    var scriptSig
	
	    if (!allowIncomplete) {
	      assert(!!scriptType, 'Transaction is not complete')
	      assert(scriptType in canSignTypes, scriptType + ' not supported')
	      assert(input.signatures, 'Transaction is missing signatures')
	    }
	
	    if (input.signatures) {
	      switch (scriptType) {
	        case 'pubkeyhash': {
	          var pkhSignature = input.signatures[0].toScriptSignature(input.hashType)
	          scriptSig = scripts.pubKeyHashInput(pkhSignature, input.pubKeys[0])
	          break
	        }
	
	        case 'multisig': {
	          // Array.prototype.map is sparse-compatible
	          var msSignatures = input.signatures.map(function (signature) {
	            return signature && signature.toScriptSignature(input.hashType)
	          })
	
	          // fill in blanks with OP_0
	          if (allowIncomplete) {
	            for (var i = 0; i < msSignatures.length; ++i) {
	              if (msSignatures[i]) continue
	
	              msSignatures[i] = ops.OP_0
	            }
	          } else {
	            // Array.prototype.filter returns non-sparse array
	            msSignatures = msSignatures.filter(function (x) { return x })
	          }
	
	          var redeemScript = allowIncomplete ? undefined : input.redeemScript
	          scriptSig = scripts.multisigInput(msSignatures, redeemScript)
	          break
	        }
	
	        case 'pubkey': {
	          var pkSignature = input.signatures[0].toScriptSignature(input.hashType)
	          scriptSig = scripts.pubKeyInput(pkSignature)
	          break
	        }
	      }
	    }
	
	    // did we build a scriptSig?
	    if (scriptSig) {
	      // wrap as scriptHash if necessary
	      if (input.prevOutType === 'scripthash') {
	        scriptSig = scripts.scriptHashInput(scriptSig, input.redeemScript)
	      }
	
	      tx.setInputScript(index, scriptSig)
	    }
	  })
	
	  return tx
	}
	
	TransactionBuilder.prototype.sign = function (index, privKey, redeemScript, hashType) {
	  assert(index in this.inputs, 'No input at index: ' + index)
	  hashType = hashType || Transaction.SIGHASH_ALL
	
	  var input = this.inputs[index]
	  var canSign = input.hashType &&
	    input.prevOutScript &&
	    input.prevOutType &&
	    input.pubKeys &&
	    input.scriptType &&
	    input.signatures
	
	  // are we almost ready to sign?
	  if (canSign) {
	    // if redeemScript was provided, enforce consistency
	    if (redeemScript) {
	      assert.deepEqual(input.redeemScript, redeemScript, 'Inconsistent redeemScript')
	    }
	
	    assert.equal(input.hashType, hashType, 'Inconsistent hashType')
	
	  // no? prepare
	  } else {
	    // must be pay-to-scriptHash?
	    if (redeemScript) {
	      // if we have a prevOutScript, enforce scriptHash equality to the redeemScript
	      if (input.prevOutScript) {
	        assert.equal(input.prevOutType, 'scripthash', 'PrevOutScript must be P2SH')
	
	        var scriptHash = input.prevOutScript.chunks[1]
	        assert.deepEqual(scriptHash, redeemScript.getHash(), 'RedeemScript does not match ' + scriptHash.toString('hex'))
	      }
	
	      var scriptType = scripts.classifyOutput(redeemScript)
	      assert(scriptType in canSignTypes, 'RedeemScript not supported (' + scriptType + ')')
	
	      var pubKeys = []
	      switch (scriptType) {
	        case 'multisig': {
	          pubKeys = redeemScript.chunks.slice(1, -2).map(ECPubKey.fromBuffer)
	          break
	        }
	
	        case 'pubkeyhash': {
	          var pkh1 = redeemScript.chunks[2]
	          var pkh2 = privKey.pub.getAddress().hash
	
	          assert.deepEqual(pkh1, pkh2, 'privateKey cannot sign for this input')
	          pubKeys = [privKey.pub]
	          break
	        }
	
	        case 'pubkey': {
	          pubKeys = redeemScript.chunks.slice(0, 1).map(ECPubKey.fromBuffer)
	          break
	        }
	      }
	
	      if (!input.prevOutScript) {
	        input.prevOutScript = scripts.scriptHashOutput(redeemScript.getHash())
	        input.prevOutType = 'scripthash'
	      }
	
	      input.pubKeys = pubKeys
	      input.redeemScript = redeemScript
	      input.scriptType = scriptType
	
	    // cannot be pay-to-scriptHash
	    } else {
	      assert.notEqual(input.prevOutType, 'scripthash', 'PrevOutScript is P2SH, missing redeemScript')
	
	      // can we otherwise sign this?
	      if (input.scriptType) {
	        assert(input.pubKeys, input.scriptType + ' not supported')
	
	      // we know nothin' Jon Snow, assume pubKeyHash
	      } else {
	        input.prevOutScript = privKey.pub.getAddress().toOutputScript()
	        input.prevOutType = 'pubkeyhash'
	        input.pubKeys = [privKey.pub]
	        input.scriptType = input.prevOutType
	      }
	    }
	
	    input.hashType = hashType
	    input.signatures = input.signatures || []
	  }
	
	  var signatureScript = input.redeemScript || input.prevOutScript
	  var signatureHash = this.tx.hashForSignature(index, signatureScript, hashType)
	
	  // enforce signature order matches public keys
	  if (input.scriptType === 'multisig' && input.redeemScript && input.signatures.length !== input.pubKeys.length) {
	    // maintain a local copy of unmatched signatures
	    var unmatched = input.signatures.slice()
	
	    input.signatures = input.pubKeys.map(function (pubKey) {
	      var match
	
	      // check for any matching signatures
	      unmatched.some(function (signature, i) {
	        if (!pubKey.verify(signatureHash, signature)) return false
	        match = signature
	
	        // remove matched signature from unmatched
	        unmatched.splice(i, 1)
	
	        return true
	      })
	
	      return match || undefined
	    })
	  }
	
	  // enforce in order signing of public keys
	  assert(input.pubKeys.some(function (pubKey, i) {
	    if (!privKey.pub.Q.equals(pubKey.Q)) return false
	
	    assert(!input.signatures[i], 'Signature already exists')
	    var signature = privKey.sign(signatureHash)
	    input.signatures[i] = signature
	
	    return true
	  }, this), 'privateKey cannot sign for this input')
	}
	
	module.exports = TransactionBuilder
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(820).Buffer))

/***/ },

/***/ 1322:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var assert = __webpack_require__(1296)
	var bufferutils = __webpack_require__(1311)
	var typeForce = __webpack_require__(1054)
	var networks = __webpack_require__(1297)
	var randomBytes = __webpack_require__(905)
	
	var Address = __webpack_require__(1295)
	var HDNode = __webpack_require__(1320)
	var TransactionBuilder = __webpack_require__(1321)
	var Script = __webpack_require__(1310)
	
	function Wallet (seed, network) {
	  console.warn('Wallet is deprecated and will be removed in 2.0.0, see #296')
	
	  seed = seed || randomBytes(32)
	  network = network || networks.bitcoin
	
	  // Stored in a closure to make accidental serialization less likely
	  var masterKey = HDNode.fromSeedBuffer(seed, network)
	
	  // HD first-level child derivation method should be hardened
	  // See https://bitcointalk.org/index.php?topic=405179.msg4415254#msg4415254
	  var accountZero = masterKey.deriveHardened(0)
	  var externalAccount = accountZero.derive(0)
	  var internalAccount = accountZero.derive(1)
	
	  this.addresses = []
	  this.changeAddresses = []
	  this.network = network
	  this.unspents = []
	
	  // FIXME: remove in 2.0.0
	  this.unspentMap = {}
	
	  // FIXME: remove in 2.0.0
	  var me = this
	  this.newMasterKey = function (seed) {
	    console.warn('newMasterKey is deprecated, please make a new Wallet instance instead')
	
	    seed = seed || randomBytes(32)
	    masterKey = HDNode.fromSeedBuffer(seed, network)
	
	    accountZero = masterKey.deriveHardened(0)
	    externalAccount = accountZero.derive(0)
	    internalAccount = accountZero.derive(1)
	
	    me.addresses = []
	    me.changeAddresses = []
	
	    me.unspents = []
	    me.unspentMap = {}
	  }
	
	  this.getMasterKey = function () {
	    return masterKey
	  }
	  this.getAccountZero = function () {
	    return accountZero
	  }
	  this.getExternalAccount = function () {
	    return externalAccount
	  }
	  this.getInternalAccount = function () {
	    return internalAccount
	  }
	}
	
	Wallet.prototype.createTransaction = function (to, value, options) {
	  // FIXME: remove in 2.0.0
	  if (typeof options !== 'object') {
	    if (options !== undefined) {
	      console.warn('Non options object parameters are deprecated, use options object instead')
	
	      options = {
	        fixedFee: arguments[2],
	        changeAddress: arguments[3]
	      }
	    }
	  }
	
	  options = options || {}
	
	  assert(value > this.network.dustThreshold, value + ' must be above dust threshold (' + this.network.dustThreshold + ' Satoshis)')
	
	  var changeAddress = options.changeAddress
	  var fixedFee = options.fixedFee
	  var minConf = options.minConf === undefined ? 0 : options.minConf // FIXME: change minConf:1 by default in 2.0.0
	
	  // filter by minConf, then pending and sort by descending value
	  var unspents = this.unspents.filter(function (unspent) {
	    return unspent.confirmations >= minConf
	  }).filter(function (unspent) {
	    return !unspent.pending
	  }).sort(function (o1, o2) {
	    return o2.value - o1.value
	  })
	
	  var accum = 0
	  var addresses = []
	  var subTotal = value
	
	  var txb = new TransactionBuilder()
	  txb.addOutput(to, value)
	
	  for (var i = 0; i < unspents.length; ++i) {
	    var unspent = unspents[i]
	    addresses.push(unspent.address)
	
	    txb.addInput(unspent.txHash, unspent.index)
	
	    var fee = fixedFee === undefined ? estimatePaddedFee(txb.buildIncomplete(), this.network) : fixedFee
	
	    accum += unspent.value
	    subTotal = value + fee
	
	    if (accum >= subTotal) {
	      var change = accum - subTotal
	
	      if (change > this.network.dustThreshold) {
	        txb.addOutput(changeAddress || this.getChangeAddress(), change)
	      }
	
	      break
	    }
	  }
	
	  assert(accum >= subTotal, 'Not enough funds (incl. fee): ' + accum + ' < ' + subTotal)
	
	  return this.signWith(txb, addresses).build()
	}
	
	// FIXME: remove in 2.0.0
	Wallet.prototype.processPendingTx = function (tx) {
	  this.__processTx(tx, true)
	}
	
	// FIXME: remove in 2.0.0
	Wallet.prototype.processConfirmedTx = function (tx) {
	  this.__processTx(tx, false)
	}
	
	// FIXME: remove in 2.0.0
	Wallet.prototype.__processTx = function (tx, isPending) {
	  console.warn('processTransaction is considered harmful, see issue #260 for more information')
	
	  var txId = tx.getId()
	  var txHash = tx.getHash()
	
	  tx.outs.forEach(function (txOut, i) {
	    var address
	
	    try {
	      address = Address.fromOutputScript(txOut.script, this.network).toString()
	    } catch (e) {
	      if (!(e.message.match(/has no matching Address/)))
	        throw e
	    }
	
	    var myAddresses = this.addresses.concat(this.changeAddresses)
	    if (myAddresses.indexOf(address) > -1) {
	      var lookup = txId + ':' + i
	      if (lookup in this.unspentMap) return
	
	      // its unique, add it
	      var unspent = {
	        address: address,
	        confirmations: 0, // no way to determine this without more information
	        index: i,
	        txHash: txHash,
	        txId: txId,
	        value: txOut.value,
	        pending: isPending
	      }
	
	      this.unspentMap[lookup] = unspent
	      this.unspents.push(unspent)
	    }
	  }, this)
	
	  tx.ins.forEach(function (txIn) {
	    // copy and convert to big-endian hex
	    var txInId = bufferutils.reverse(txIn.hash).toString('hex')
	
	    var lookup = txInId + ':' + txIn.index
	    if (!(lookup in this.unspentMap)) return
	
	    var unspent = this.unspentMap[lookup]
	
	    if (isPending) {
	      unspent.pending = true
	      unspent.spent = true
	    } else {
	      delete this.unspentMap[lookup]
	
	      this.unspents = this.unspents.filter(function (unspent2) {
	        return unspent !== unspent2
	      })
	    }
	  }, this)
	}
	
	Wallet.prototype.generateAddress = function () {
	  var k = this.addresses.length
	  var address = this.getExternalAccount().derive(k).getAddress()
	
	  this.addresses.push(address.toString())
	
	  return this.getReceiveAddress()
	}
	
	Wallet.prototype.generateChangeAddress = function () {
	  var k = this.changeAddresses.length
	  var address = this.getInternalAccount().derive(k).getAddress()
	
	  this.changeAddresses.push(address.toString())
	
	  return this.getChangeAddress()
	}
	
	Wallet.prototype.getAddress = function () {
	  if (this.addresses.length === 0) {
	    this.generateAddress()
	  }
	
	  return this.addresses[this.addresses.length - 1]
	}
	
	Wallet.prototype.getBalance = function (minConf) {
	  minConf = minConf || 0
	
	  return this.unspents.filter(function (unspent) {
	    return unspent.confirmations >= minConf
	
	      // FIXME: remove spent filter in 2.0.0
	  }).filter(function (unspent) {
	    return !unspent.spent
	  }).reduce(function (accum, unspent) {
	    return accum + unspent.value
	  }, 0)
	}
	
	Wallet.prototype.getChangeAddress = function () {
	  if (this.changeAddresses.length === 0) {
	    this.generateChangeAddress()
	  }
	
	  return this.changeAddresses[this.changeAddresses.length - 1]
	}
	
	Wallet.prototype.getInternalPrivateKey = function (index) {
	  return this.getInternalAccount().derive(index).privKey
	}
	
	Wallet.prototype.getPrivateKey = function (index) {
	  return this.getExternalAccount().derive(index).privKey
	}
	
	Wallet.prototype.getPrivateKeyForAddress = function (address) {
	  var index
	
	  if ((index = this.addresses.indexOf(address)) > -1) {
	    return this.getPrivateKey(index)
	  }
	
	  if ((index = this.changeAddresses.indexOf(address)) > -1) {
	    return this.getInternalPrivateKey(index)
	  }
	
	  assert(false, 'Unknown address. Make sure the address is from the keychain and has been generated')
	}
	
	Wallet.prototype.getUnspentOutputs = function (minConf) {
	  minConf = minConf || 0
	
	  return this.unspents.filter(function (unspent) {
	    return unspent.confirmations >= minConf
	
	      // FIXME: remove spent filter in 2.0.0
	  }).filter(function (unspent) {
	    return !unspent.spent
	  }).map(function (unspent) {
	    return {
	      address: unspent.address,
	      confirmations: unspent.confirmations,
	      index: unspent.index,
	      txId: unspent.txId,
	      value: unspent.value,
	
	      // FIXME: remove in 2.0.0
	      hash: unspent.txId,
	      pending: unspent.pending
	    }
	  })
	}
	
	Wallet.prototype.setUnspentOutputs = function (unspents) {
	  this.unspentMap = {}
	  this.unspents = unspents.map(function (unspent) {
	    // FIXME: remove unspent.hash in 2.0.0
	    var txId = unspent.txId || unspent.hash
	    var index = unspent.index
	
	    // FIXME: remove in 2.0.0
	    if (unspent.hash !== undefined) {
	      console.warn('unspent.hash is deprecated, use unspent.txId instead')
	    }
	
	    // FIXME: remove in 2.0.0
	    if (index === undefined) {
	      console.warn('unspent.outputIndex is deprecated, use unspent.index instead')
	      index = unspent.outputIndex
	    }
	
	    typeForce('String', txId)
	    typeForce('Number', index)
	    typeForce('Number', unspent.value)
	
	    assert.equal(txId.length, 64, 'Expected valid txId, got ' + txId)
	    assert.doesNotThrow(function () {
	      Address.fromBase58Check(unspent.address)
	    }, 'Expected Base58 Address, got ' + unspent.address)
	    assert(isFinite(index), 'Expected finite index, got ' + index)
	
	    // FIXME: remove branch in 2.0.0
	    if (unspent.confirmations !== undefined) {
	      typeForce('Number', unspent.confirmations)
	    }
	
	    var txHash = bufferutils.reverse(new Buffer(txId, 'hex'))
	
	    unspent = {
	      address: unspent.address,
	      confirmations: unspent.confirmations || 0,
	      index: index,
	      txHash: txHash,
	      txId: txId,
	      value: unspent.value,
	
	      // FIXME: remove in 2.0.0
	      pending: unspent.pending || false
	    }
	
	    // FIXME: remove in 2.0.0
	    this.unspentMap[txId + ':' + index] = unspent
	
	    return unspent
	  }, this)
	}
	
	Wallet.prototype.signWith = function (tx, addresses) {
	  addresses.forEach(function (address, i) {
	    var privKey = this.getPrivateKeyForAddress(address)
	
	    tx.sign(i, privKey)
	  }, this)
	
	  return tx
	}
	
	function estimatePaddedFee (tx, network) {
	  var tmpTx = tx.clone()
	  tmpTx.addOutput(Script.EMPTY, network.dustSoftThreshold || 0)
	
	  return network.estimateFee(tmpTx)
	}
	
	// FIXME: 1.0.0 shims, remove in 2.0.0
	Wallet.prototype.getReceiveAddress = Wallet.prototype.getAddress
	Wallet.prototype.createTx = Wallet.prototype.createTransaction
	
	module.exports = Wallet
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(820).Buffer))

/***/ },

/***/ 1323:
/***/ function(module, exports, __webpack_require__) {

	/**
	 * protocol buffers schema
	 * @module protobufs
	 */
	
	const typeforce = __webpack_require__(1054)
	const protocol = __webpack_require__(1150)
	const constants = __webpack_require__(1224)
	const SIG = constants.SIG
	const SEQ = constants.SEQ
	const PREV_TO_SENDER = constants.PREV_TO_SENDER
	const PREVLINK = constants.PREVLINK
	const PERMALINK = constants.PERMALINK
	const types = __webpack_require__(1223)
	const proto = exports.schema = __webpack_require__(1184)(`
	  ${protocol.protobufs.string}
	
	  // message PubKey {
	  //   required PubKeyType type = 1;
	  //   optional ECPubKey ec = 2;
	  //   // optional DSAPubKey dsa = 3;
	  //   // optional RSAPubKey rsa = 4;
	  // }
	
	  // enum PubKeyType {
	  //   EC = 1;
	  //   RSA = 2;
	  //   DSA = 3;
	  // }
	
	  message Message {
	    // don't need authorPubKey, SIG, already has it
	    // required ECPubKey authorPubKey = 1;
	    required ECPubKey recipientPubKey = 1;
	    required bytes object = 2;
	    required ECSignature ${SIG} = 3;
	    optional bytes ${PREV_TO_SENDER} = 4;
	    optional uint32 ${SEQ} = 5;
	    optional bytes other = 6;
	    optional Seal seal = 7;
	  }
	
	  enum Network {
	    none = 1;
	    btcmain = 2;
	    btctest = 3;
	  }
	
	  message Seal {
	    required Network network = 1;
	    // presumably all keys on a network
	    // are homogenous (e.g. have the save curve for elliptic curve based networks)
	    required bytes basePubKey = 2;
	    required bytes link = 3;
	  }
	
	  enum KeyType {
	    bitcoin = 1;
	    ec = 2;
	    dsa = 3;
	  }
	
	  enum ECurve {
	    none = 1;
	    ed25519 = 2;
	    secp256k1 = 3;
	    p256 = 4;
	    curve25519 = 5;
	  }
	
	  enum KeyPurpose {
	    payment = 1;
	    sign = 2;
	    update = 3;
	    messaging = 4;
	    tls = 5;
	  }
	
	  message PubKey {
	    required KeyType type = 1;
	    required KeyPurpose purpose = 2;
	    required bytes pub = 3;
	    optional ECurve curve = 4 [default = none];
	    optional Network network = 5 [default = none];
	    optional bytes fingerprint = 6;
	  }
	
	  message Identity {
	    required bytes ${SIG} = 1;
	    optional bytes ${PREVLINK} = 2;
	    optional bytes ${PERMALINK} = 3;
	    repeated PubKey pubkeys = 4;
	  }
	`)
	
	  // message Message {
	  //   required bytes object = 1;
	  //   required Signature sig = 2;
	  // }
	
	  // enum IdentifierType {
	  //   ROOT = 0;
	  //   CUR = 1;
	  //   PUBKEY = 2;
	  // }
	
	  // message Recipient {
	  //   required IdentifierType identifierType = 1;
	  //   required bytes identifier = 2;
	  // }
	
	  // message TxData {
	  //   required bytes merkleRoot = 1;
	  //   required Recipient recipient = 2;
	  // }
	
	  // message Object {
	  //   required bytes json = 1;
	  // }
	
	  // message Message {
	  //   repeated Header header = 1;
	  //   required bytes object = 2;
	  // }
	
	  // message Object {
	  //   required bytes body = 1;
	  //   required Signature sig = 2;
	  // }
	
	  // message Object {
	  //   required Signature sig = 1;
	  //   required bytes body = 2;
	  // }
	
	  // message Share {
	  //   required Header header = 1;
	  //   required Signature sig = 2;
	  //   required bytes body = 3;
	  // }
	
	// exports.serialize = function (opts) {
	//   typeforce({
	//     toKey: typeforce.Buffer,
	//     object: typeforce.Object
	//   }, opts)
	
	//   return proto.Message.encode({
	//     header: [
	//       {
	//         sig: header.sig,
	//         sigKey: header.sigKey,
	//         sigInput: {
	//           merkleRoot: header.sigInput.merkleRoot,
	//           recipient: {
	//             identifierType: proto.IdentifierType.PUBKEY,
	//             identifier: opts.toKey
	//           }
	//         }
	//       }
	//     ],
	//     object: new Buffer(JSON.stringify(opts.object))
	//   })
	// }
	
	// exports.unserialize = function (msg) {
	//   msg = exports.proto.Message.decode(msg)
	//   const sigInput = msg.header[0].sigInput
	//   // only pubKeys for now
	//   sigInput.recipient = sigInput.recipient.identifier
	//   msg.object = JSON.parse(msg.object)
	//   msg.headers = msg.header
	//   delete msg.header
	//   return msg
	// }


/***/ },

/***/ 1324:
/***/ function(module, exports) {

	
	/**
	 * supported blockchain networks
	 * @module networks
	 */
	module.exports = {
	  bitcoin: {
	    messagePrefix: '\x18Bitcoin Signed Message:\n',
	    bip32: {
	      public: 0x0488b21e,
	      private: 0x0488ade4
	    },
	    pubKeyHash: 0x00,
	    scriptHash: 0x05,
	    wif: 0x80,
	    dustThreshold: 546 // https://github.com/bitcoin/bitcoin/blob/v0.9.2/src/core.h#L151-L162
	  },
	  testnet: {
	    messagePrefix: '\x18Bitcoin Signed Message:\n',
	    bip32: {
	      public: 0x043587cf,
	      private: 0x04358394
	    },
	    pubKeyHash: 0x6f,
	    scriptHash: 0xc4,
	    wif: 0xef,
	    dustThreshold: 546
	  }
	}


/***/ },

/***/ 1325:
/***/ function(module, exports, __webpack_require__) {

	// Copyright (c) 2014 John Firebaugh
	// https://github.com/jfirebaugh/node-take-stream
	
	const Transform = __webpack_require__(829).Transform
	
	module.exports = head
	
	/**
	 * stream that emits the first n items in a piped-in stream
	 * @module  head
	 * @param {Number} n   how many items to take from the piped-in stream
	 */
	function head (n) {
	  var count = 0
	  var stream = new Transform({
	    objectMode: true,
	      highWaterMark: 2 // Should be 1 or 0 but https://github.com/joyent/node/issues/7364
	  })
	
	  if (n === 0) {
	    stream.push(null)
	  }
	
	  stream._transform = function (chunk, encoding, callback) {
	    if (++count <= n) {
	      stream.push(chunk)
	      callback()
	    }
	
	    if (count === n) {
	      stream.push(null)
	    }
	  }
	
	  return stream
	}


/***/ },

/***/ 1326:
/***/ function(module, exports) {

	
	/**
	 * API manifests, for promisification, etc.
	 * @module manifest
	 */
	
	exports.node = {
	  sign              : {type: 'async'},
	  send              : {type: 'async'},
	  signAndSend       : {type: 'async'},
	  receive           : {type: 'async'},
	  seal              : {type: 'async'},
	  watchSeal         : {type: 'async'},
	  watchNextVersion  : {type: 'async'},
	  forget            : {type: 'async'},
	  addContact        : {type: 'async'},
	  addContactIdentity: {type: 'async'},
	  destroy           : {type: 'async'},
	  saveObject        : {type: 'async'},
	  createObject      : {type: 'async'},
	  objectSealStatus  : {type: 'async'},
	  identitySealStatus: {type: 'async'},
	  conversation      : {type: 'readable'},
	  pause             : {type: 'sync'},
	  resume            : {type: 'sync'},
	}
	
	exports.objects = {
	  get               : {type: 'async'},
	  list              : {type: 'async'},
	  createReadStream  : {type:'readable'},
	  type              : {type: 'readable'},
	  sealed            : {type: 'readable'},
	  unsealed          : {type: 'readable'},
	  unsent            : {type: 'readable'},
	  unsentTo          : {type: 'readable'},
	  byPermalink       : {type: 'async'},
	  from              : {type: 'readable'},
	  to                : {type: 'readable'},
	  lastMessage       : {type: 'async'},
	  exists            : {type: 'async'},
	  messages          : {type: 'readable'},
	  messagesWithObject: {type: 'readable'}
	}
	
	exports.addressBook = {
	  lookupIdentity    : {type: 'async'},
	  byPubKey          : {type: 'async'},
	  byFingerprint     : {type: 'async'},
	  byPermalink       : {type: 'async'},
	  byLink            : {type: 'async'},
	  createReadStream  : {type:'readable'}
	}
	
	exports.seals = {
	  pending           : {type: 'readable'},
	  sealed            : {type: 'readable'},
	  find              : {type: 'async'},
	  findOne           : {type: 'async'},
	}
	
	exports.watches = {
	  get               : {type: 'async'},
	  exists            : {type: 'async'},
	  list              : {type: 'async'},
	  find              : {type: 'async'},
	  findOne           : {type: 'async'},
	}


/***/ },

/***/ 1327:
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @module  errors
	 */
	
	const TypedError = __webpack_require__(1328)
	const constants = __webpack_require__(1224)
	const LINK = constants.LINK
	
	exports.ObjectExists = TypedError({
	  type: 'exists',
	  message: 'object {link} already exists',
	  link: null
	})
	
	exports.MessageExists = TypedError({
	  type: 'exists',
	  message: 'message {link} already exists',
	  link: null
	})
	
	exports.AlreadySaving = TypedError({
	  type: 'saving',
	  message: 'already saving object with link {link}',
	  link: null
	})
	
	exports.SealExists = TypedError({
	  type: 'exists',
	  message: 'seal {seal} already exists',
	  seal: null
	})
	
	exports.WatchExists = TypedError({
	  type: 'exists',
	  message: 'watch with address {address} and link {link} already exists',
	  address: null,
	  link: null
	})
	
	exports.InvalidSignature = TypedError({
	  type: 'invalidsignature',
	  message: 'signature {sig} is invalid: {reason}',
	  sig: null,
	  reason: 'verification failed'
	})
	
	exports.Author = TypedError({
	  type: 'author',
	  message: 'author {author} doesn\'t match signature {sig}',
	  sig: null,
	  author: null
	})
	
	exports.InvalidVersion = TypedError({
	  type: 'version',
	  message: 'object is incorrectly versioned: {error}',
	  error: null
	})
	
	exports.InvalidPartial = TypedError({
	  type: 'partial',
	  message: 'partial is malformed: {error}',
	  error: null
	})


/***/ },

/***/ 1330:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {
	const merkleProofs = __webpack_require__(1156)
	const protocol = __webpack_require__(1150)
	const flat = __webpack_require__(1171)
	const utils = __webpack_require__(1225)
	const typeforce = __webpack_require__(1207)
	const types = __webpack_require__(1223)
	const { SIG, TYPE, TYPES } = __webpack_require__(1224)
	const { PARTIAL } = TYPES
	
	exports.from = function (object) {
	  typeforce(types.signedObject, object)
	
	  const neutered = utils.omit(object, SIG)
	  const prover = protocol.prover(neutered)
	  const indices = protocol.indices(neutered)
	  const added = {}
	  const builder = {
	    add: opts => {
	      const { property, key, value } = opts
	      if (!key && !value) {
	        throw new Error('"key" and/or "value" must be true')
	      }
	
	      if (key === SIG) {
	        throw new Error(SIG + ' is a signature of the merkle root, ' +
	          'and thus is not covered by it...and thus can\'t proven with a merkle proof')
	      }
	
	      if (added[property]) {
	        throw new Error('already added ' + property)
	      }
	
	      added[property] = true
	      prover.add(opts)
	      return builder
	    },
	    build: () => {
	      const proof = prover.proof().map(stripBuffers)
	      const leaves = prover
	        .leaves()
	        .map(leaf => utils.pick(leaf, 'index', 'data'))
	        .map(stripBuffers)
	
	      return {
	        [TYPE]: PARTIAL,
	        root: proof.pop(),
	        leaves,
	        proof,
	        sig: object[SIG]
	      }
	    }
	  }
	
	  return builder
	}
	
	exports.verify = function (partial) {
	  const proof = partial.proof.concat(partial.root).map(bufferizeMerkleNode)
	  const opts = utils.clone({ proof }, protocol.DEFAULT_MERKLE_OPTS)
	  const verify = merkleProofs.verifier(opts)
	  return partial.leaves.every(node => verify(node))
	}
	
	exports.extractSigPubKey = function (partial, cb) {
	  const { pubKey, sig } = utils.parseSig(partial.sig)
	  pubKey.type = 'ec'
	  const nkey = utils.importKey(pubKey)
	  nkey.verify(new Buffer(partial.root.hash, 'hex'), sig, function (err, verified) {
	    if (err) return cb(err)
	
	    cb(null, verified && pubKey)
	  })
	}
	
	exports.interpretLeaves = function interpretLeaves (leaves) {
	  // assumes flat-tree was used to index nodes
	  leaves = leaves.slice().sort(function (a, b) {
	    return a.index - b.index
	  })
	
	  const props = []
	  let key
	  for (var i = 0; i < leaves.length; i++) {
	    let leaf = leaves[i]
	    let isKey = leaf.index % 4 === 0
	    if (isKey) {
	      key = leaf
	      props.push({ key: leaf.data })
	    } else {
	      // merkle tree uses stringified values
	      let value = leaf.data
	      let prev = i > 0 && leaves[i - 1]
	      if (prev && flat.sibling(prev.index) === leaf.index) {
	        props[props.length - 1].value = value
	      } else {
	        props.push({ value: leaf.data })
	      }
	
	      key = null
	    }
	  }
	
	  props.forEach(function parse (prop) {
	    if ('key' in prop) prop.key = JSON.parse(prop.key)
	    if ('value' in prop) prop.value = JSON.parse(prop.value)
	  })
	
	  return props
	}
	
	function stripBuffers (node) {
	  const clean = {
	    index: node.index
	  }
	
	  if (node.hash) {
	    clean.hash = node.hash.toString('hex')
	  }
	
	  if (node.data) {
	    clean.data = node.data.toString()
	  }
	
	  return clean
	}
	
	function bufferizeMerkleNode (node) {
	  const withBufs = {
	    index: node.index
	  }
	
	  if (node.hash) {
	    withBufs.hash = new Buffer(node.hash, 'hex')
	  }
	
	  if (node.data) {
	    withBufs.data = new Buffer(node.data)
	  }
	
	  return withBufs
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(820).Buffer))

/***/ },

/***/ 1375:
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	/**
	 * @module controls
	 */
	
	const EventEmitter = __webpack_require__(786).EventEmitter
	const typeforce = __webpack_require__(1207)
	const utils = __webpack_require__(1225)
	// const noop = () => {}
	
	/**
	 * start/stop/pause/resume controls
	 * @alias: module controls
	 * @typedef {controls}
	 * @param {function} start
	 * @param {function} [pause]
	 */
	module.exports = function controls (opts) {
	  typeforce({
	    start: typeforce.Function,
	    pause: typeforce.maybe(typeforce.Function)
	  }, opts)
	
	  let _start = opts.start
	  let _pause = opts.pause
	  let _stop
	  let _resume
	  const ee = new EventEmitter()
	
	  function start () {
	    if (_stop) return
	
	    _stop = _start.apply(this, arguments)
	    typeforce(typeforce.Function, _stop)
	    ee.emit('start')
	  }
	
	  function stop () {
	    if (!_stop) return // already stopped
	
	    // prevent race condition
	    const tmp = _stop
	    _stop = null
	    _resume = function () {
	      assert(false, 'can\'t resume when stopped, only when paused')
	    }
	
	    tmp.apply(this, arguments)
	    ee.emit('stop')
	  }
	
	  function pause () {
	    if (_resume) return // already resumed
	
	    utils.assert(isRunning(), 'can\'t pause before start')
	    utils.assert(_pause, 'no "pause" function provided')
	
	    _resume = _pause.apply(this, arguments)
	    typeforce(typeforce.Function, _resume)
	    ee.emit('pause')
	  }
	
	  function resume () {
	    if (!_resume) return
	
	    // prevent race condition
	    const tmp = _resume
	    _resume = null
	    tmp.apply(this, arguments)
	    ee.emit('resume')
	  }
	
	  function isRunning () {
	    return !!(_stop && !_resume)
	  }
	
	  return utils.extend(ee, {
	    start,
	    stop,
	    pause,
	    resume,
	    isRunning
	  })
	}


/***/ },

/***/ 1376:
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	/**
	 * @module channel
	 */
	
	const inherits = __webpack_require__(1130).inherits
	const EventEmitter = __webpack_require__(786).EventEmitter
	const createBackoff = __webpack_require__(1126)
	const debug = __webpack_require__(787)('tradle:channel')
	const pump = __webpack_require__(1208)
	const through = __webpack_require__(1213)
	const createRetryStream = __webpack_require__(1377)
	const utils = __webpack_require__(1225)
	const constants = __webpack_require__(1224)
	
	module.exports.DEFAULT_BACKOFF_OPTS = constants.DEFAULT_BACKOFF_OPTS
	
	module.exports = Channel
	
	/**
	 * message delivery channel
	 * @constructor
	 * @alias module:channel
	 * @param {AddressBook}  opts.addressBook
	 * @param {ObjectsDB}    opts.objects
	 * @param {Function}     opts.send
	 * @param {Actions}      opts.actions
	 * @param {Object}       [opts.backoffOptions]
	 */
	function Channel (opts) {
	  // const addressBook = opts.addressBook
	  // this._debugId = op
	  EventEmitter.call(this)
	  this.opts = opts
	  this.createBackoff = function () {
	    return createBackoff.exponential(opts.backoffOptions || module.exports.DEFAULT_BACKOFF_OPTS)
	  }
	}
	
	inherits(Channel, EventEmitter)
	
	Channel.prototype._debug = function () {
	  utils.subdebug(debug, this.opts.name, arguments)
	}
	
	/**
	 * set the recipient
	 * @param {String} recipient
	 */
	Channel.prototype.setRecipient = function (recipient) {
	  this.recipient = recipient
	}
	
	Channel.prototype.pause = function () {
	  this._paused = true
	  if (this.stream) this.stream.pause()
	  this.emit('pause')
	}
	
	Channel.prototype.resume = function () {
	  this._paused = false
	  if (this.stream) this.stream.resume()
	  this.emit('resume')
	}
	
	/**
	 * close the channel
	 */
	Channel.prototype.destroy = function () {
	  if (this._destroyed) throw new Error('already destroyed!')
	
	  this._destroyed = true
	  if (this.stream)  {
	    this.stream.destroy()
	    this.stream = null
	  }
	
	  this.emit('destroy')
	}
	
	/**
	 * start sending any messages queued up the database for this channel
	 */
	Channel.prototype.start = function () {
	  const self = this
	  if (!this.recipient) throw new Error('call "setRecipient" first')
	  if (this.started) return
	
	  this.started = true
	  const opts = this.opts
	  const addressBook = opts.addressBook
	  const objects = opts.objects
	  const send = opts.send
	  const actions = opts.actions
	  const senderStream = createRetryStream({
	      primaryKey: 'link',
	      worker: worker,
	      backoff: this.createBackoff()
	    })
	    .on('error', err => {
	      if (!this._destroyed) {
	        this.emit('error', err)
	      }
	    })
	    // // switch to old mode to keep stream flowing
	    // // otherwise it stops when it hits highWaterMark
	    // .on('data', data => {
	    //   self._debug('sent ' + describe(data.input))
	    // })
	
	  this.stream = pump(
	    objects.unsentTo(this.recipient.permalink, { live: true, keys: false, body: false }),
	    // add body
	    through.obj({ highWaterMark: 1 }, function (data, enc, cb) {
	      const link = data.link
	      objects.addBody(data, err => {
	        if (err) {
	          self._debug(`missing ${data.objectinfo.type} body for ${link}, skipping message`)
	          return cb()
	        }
	
	        cb(null, data)
	      })
	    }),
	    senderStream,
	    through.obj(function (data, enc, cb) {
	      // drain results of senderStream
	      cb()
	    })
	  )
	
	  // this.stream.resume()
	
	  // TODO: setRecipient again if their identity changes
	  function worker (data, cb) {
	    if (self._destroyed) return cb(new Error('not running'))
	    if (self._paused) {
	      return self.once('resume', function () {
	        worker(data, cb)
	      })
	    }
	
	    self._debug('sending ' + describe(data))
	    const serialized = utils.serializeMessage(data.object)
	    serialized.unserialized = data
	    send(serialized, self.recipient, function (err) {
	      if (err) {
	        self._debug(`send failed for ${describe(data)}: ${err.stack}`)
	        return cb(err)
	      }
	
	      self._debug(`send succeeded for ${describe(data)}`)
	      actions.sentMessage(data.link, cb)
	    })
	  }
	}
	
	function describe (data) {
	  return ['message', data.link, 'carrying', data.objectinfo.type, data.objectinfo.link, 'to', data.recipient].join(' ')
	}


/***/ },

/***/ 1377:
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	/**
	 * actions
	 * @module retrystream
	 */
	
	// const EventEmitter = require('events')
	const createBackoff = __webpack_require__(1126)
	const through = __webpack_require__(1213)
	const combine = __webpack_require__(1226)
	const typeforce = __webpack_require__(1207)
	const constants = __webpack_require__(1224)
	
	module.exports = exports = createRetryStream
	// for ease of testing
	module.exports.DEFAULT_BACKOFF_OPTS = constants.DEFAULT_BACKOFF_OPTS
	
	/**
	 * stream-based queue
	 * @alias module:retrystream
	 * @param  {Object} opts
	 * @param  {string} opts.primaryKey
	 * @param  {Function} opts.worker
	 * @return {stream}
	 */
	function createRetryStream (opts) {
	  typeforce({
	    primaryKey: typeforce.String,
	    worker: typeforce.Function
	  }, opts)
	
	  // to support concurrency, use map-stream, but then you obviously lose order guarantees
	
	  const worker = opts.worker
	  const backoff = opts.backoff || createBackoff.exponential(exports.DEFAULT_BACKOFF_OPTS)
	  const primaryKey = opts.primaryKey
	  const inProgress = {}
	  const registrar = through.obj(function jotDown (data, enc, cb) {
	    const id = data[primaryKey]
	    if (typeof id === 'undefined') throw new Error('invalid data, missing: ' + primaryKey)
	    if (id in inProgress) return cb() // already queued
	
	    inProgress[id] = true
	    cb(null, data)
	  })
	
	  let running = true
	  registrar.once('end', () => running = false)
	
	  let paused
	  const processor = through.obj(function write (data, enc, cb) {
	    ;(function loop () {
	      if (!running) return // ignore
	      if (paused) return transform.once('resume', loop)
	
	      worker(data, function (err, val) {
	        if (!running) return
	        if (err) {
	          // allow to skip the failed job
	          if (!err.skip) {
	            // or unshift back into stream
	            backoff.once('ready', loop)
	            return backoff.backoff()
	          }
	        }
	
	        const id = data[primaryKey]
	        delete inProgress[id]
	        cb(null, {
	          input: data,
	          output: val
	        })
	      })
	    })()
	  })
	
	  const transform = combine.obj(
	    registrar,
	    processor
	  )
	
	  transform.on('pause', () => paused = true)
	  transform.on('resume', () => paused = false)
	
	  if (!transform.destroy) {
	    transform.destroy = transform.end
	  }
	
	  return transform
	}


/***/ },

/***/ 1378:
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	/**
	 * @module sealer
	 */
	
	const EventEmitter = __webpack_require__(786).EventEmitter
	const collect = __webpack_require__(1051)
	const pump = __webpack_require__(1208)
	const typeforce = __webpack_require__(1207)
	const createBackoff = __webpack_require__(1126)
	const debug = __webpack_require__(787)('tradle:sealer')
	const protocol = __webpack_require__(1150)
	const through = __webpack_require__(1213)
	const constants = __webpack_require__(1224)
	const LINK = constants.LINK
	const utils = __webpack_require__(1225)
	const controls = __webpack_require__(1375)
	const types = __webpack_require__(1223)
	const createRetryStream = __webpack_require__(1377)
	const DEFAULT_AMOUNT = 547
	
	module.exports = sealer
	module.exports.DEFAULT_BACKOFF_OPTS = constants.DEFAULT_BACKOFF_OPTS
	
	
	/**
	 * blockchain seal creator with retry
	 * @alias module:sealer
	 * @param {Object}     opts
	 * @param {sealsDB}    opts.seals
	 * @param {transactor} opts.transactor
	 * @param {Actions}    opts.actions
	 * @param {String}     opts.networkName
	 * @param {Object}     [opts.backoffOptions]
	 * @param {String}     [opts.name]  for logging
	 */
	function sealer (opts) {
	  typeforce({
	    seals: typeforce.Object,
	    transactor: types.transactor,
	    actions: typeforce.Object,
	    networkName: typeforce.String,
	    backoffOptions: typeforce.maybe(typeforce.Object),
	    name: typeforce.maybe(typeforce.String)
	  }, opts)
	
	  const myDebug = utils.subdebugger(debug, opts.name)
	  const actions = opts.actions
	  const seals = opts.seals
	  const transactor = opts.transactor
	  const networkName = opts.networkName
	  const newBackoff = function () {
	    return createBackoff.exponential(opts.backoffOptions || module.exports.DEFAULT_BACKOFF_OPTS)
	  }
	
	  const ee = new EventEmitter()
	  let sealsStream
	  let sealerStream
	  return utils.extend(ee, controls({ start, pause }))
	
	  function writeSeal (state, cb) {
	    let to = [ state.sealAddress ]
	    if (state.sealPrevAddress) to.push(state.sealPrevAddress)
	
	    to = to.map(function (address) {
	      return {
	        amount: state.amount || DEFAULT_AMOUNT,
	        address: address
	      }
	    })
	
	    myDebug('sealing ' + state.link)
	    transactor.send({
	      to: to
	    }, function (err, tx) {
	      if (err) {
	        myDebug('seal failed: ' + err.message)
	        return cb(err)
	      }
	
	      tx = utils.parseTx(tx, networkName)
	      actions.wroteSeal(state, tx, err => {
	        if (err) return cb(err)
	
	        cb(null, tx)
	      })
	    })
	  }
	
	  function pause () {
	    sealerStream.pause()
	    return function () {
	      sealerStream.resume()
	    }
	  }
	
	  function start () {
	    sealsStream = seals.pending({ live: true, keys: false })
	    sealerStream = createRetryStream({
	        worker: writeSeal,
	        // primaryKey: 'link'
	        primaryKey: 'uid',
	        backoff: newBackoff()
	      })
	      .on('error', err => ee.emit('error', err))
	
	    pump(
	      sealsStream,
	      sealerStream,
	      through.obj(function (data, enc, cb) {
	        // drain results of sealerStream
	        myDebug(`sealed ${data.input.link} to address ${data.input.sealAddress} with tx ${data.output.txId}`)
	        cb()
	      })
	    )
	
	    return sealsStream.end.bind(sealsStream)
	  }
	}


/***/ },

/***/ 1379:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict'
	
	/**
	 * @module sealwatch
	 */
	
	const EventEmitter = __webpack_require__(786).EventEmitter
	const debug = __webpack_require__(787)('tradle:sealwatch')
	const thunky = __webpack_require__(1212)
	const typeforce = __webpack_require__(1207)
	const async = __webpack_require__(1239)
	const constants = __webpack_require__(1224)
	const utils = __webpack_require__(1225)
	const types = __webpack_require__(1223)
	const TEST = ("development") === 'test'
	const DEFAULT_BATCH_SIZE = Number(process.env.SEALWATCH_BATCH_SIZE) || 50
	const DEFAULT_SYNC_INTERVAL = Number(process.env.SEALWATCH_SYNC_INTERVAL) || 600000 // 10 mins
	const DEFAULT_INTER_BATCH_TIMEOUT = Number(process.env.SEALWATCH_BATCH_TIMEOUT) || 60000
	
	/**
	 * blockchain seal monitor
	 * @alias module:sealwatch
	 * @param {Object}     opts
	 * @param {Blockchain} opts.blockchain
	 * @param {string}     opts.networkName
	 * @param {objectsDB}  opts.objectsDB
	 * @param {Actions}    opts.actions
	 * @param {Number}     opts.syncInterval
	 * @param {Number}     opts.confirmedAfter
	 */
	module.exports = function sealwatch (opts) {
	  typeforce({
	    blockchain: types.blockchain,
	    networkName: typeforce.String,
	    watches: typeforce.Object,
	    objects: typeforce.Object,
	    actions: typeforce.Object,
	    // chaintracker: typeforce.Object,
	    syncInterval: typeforce.Number,
	    confirmedAfter: typeforce.Number,
	    batchSize: typeforce.maybe(typeforce.Number),
	    interBatchTimeout: typeforce.maybe(typeforce.Number)
	  }, opts)
	
	  const emitter = new EventEmitter()
	  const myDebug = opts.name ? utils.subdebugger(debug, opts.name) : debug
	
	  const {
	    blockchain,
	    networkName,
	    actions,
	    confirmedAfter,
	    batchSize=DEFAULT_BATCH_SIZE,
	    interBatchTimeout=DEFAULT_INTER_BATCH_TIMEOUT,
	    syncInterval=DEFAULT_SYNC_INTERVAL
	  } = opts
	
	  // const chaintracker = opts.chaintracker
	  const watchesDB = opts.watches
	  const objectsDB = opts.objects
	  let addrs = []
	
	  init = thunky(init)
	  init()
	
	  watchesDB.follow().on('data', function (data) {
	    const addr = data.value.address
	    if (data.type === 'del') {
	      addrs = addrs.filter(existing => addr !== existing)
	      return
	    }
	
	    const topic = data.value.topic
	    if (topic === 'newwatch') {
	      if (addrs.indexOf(addr) === -1) {
	        addrs.push(addr)
	        if (addrs.length === 1) sync()
	      }
	    }
	  })
	
	  let stopped
	  let timeout
	  let batchTimeout
	  let syncing
	  let queued
	  let paused
	  emitter.sync = function (cb) {
	    init(() => sync())
	    if (cb) {
	      emitter.once('sync', txInfos => cb(null, txInfos))
	    }
	  }
	
	  emitter.start = function () {
	    stopped = false
	    paused = false
	    queued = false
	    emitter.sync()
	  }
	
	  emitter.resume = function start () {
	    paused = false
	    if (queued) {
	      queued = false
	      emitter.sync()
	    }
	  }
	
	  emitter.stop = function () {
	    stopped = true
	    if (timeout) {
	      clearTimeout(timeout)
	      timeout = null
	    }
	  }
	
	  emitter.pause = function stop () {
	    paused = true
	  }
	
	  return emitter
	
	  function init (cb) {
	    watchesDB.list(function (err, watches) {
	      if (err) {
	        emitter.emit('error', err)
	      } else if (watches.length) {
	        addrs = watches.map(w => w.address).concat(addrs)
	      }
	
	      cb()
	    })
	  }
	
	  function sync () {
	    if (stopped) return
	    if (paused || syncing) return queued = true
	    if (!addrs.length) return myDebug('sync skipped, no watched addresses')
	
	    myDebug(`syncing ${addrs.length} addresses`)
	    // myDebug(`syncing ${addrs.join(', ')}`)
	    syncing = true
	    async.waterfall([
	      getHeight,
	      syncAddresses,
	    ], function (err, txInfos) {
	      syncing = false
	      if (err) {
	        myDebug('failed to sync addresses: ' + err.message)
	      } else {
	        emitter.emit('sync', txInfos)
	      }
	
	      if (queued) {
	        queued = false
	        sync()
	      } else if (!stopped) {
	        // schedule next sync
	        clearTimeout(timeout)
	        timeout = utils.timeout(sync, syncInterval)
	      }
	    })
	  }
	
	  function getHeight (cb) {
	    const fn = typeof blockchain.info === 'function'
	      ? blockchain.info.bind(blockchain)
	      : blockchain.blocks.latest.bind(blockchain.blocks)
	
	    fn(function (err, block) {
	      cb(err, block && block.blockHeight)
	    })
	  }
	
	  function syncAddresses (height, cb) {
	    const batches = toBatches(addrs)
	    const tasks = []
	    let results = []
	    batches.forEach(batch => {
	      tasks.push(done => {
	        syncBatch(batch, height, function (err, txInfos) {
	          if (err) return done(err)
	
	          clearTimeout(batchTimeout)
	          batchTimeout = utils.timeout(() => {
	            results = results.concat(txInfos)
	            done()
	          }, interBatchTimeout)
	        })
	      })
	    })
	
	    async.series(tasks, function (err) {
	      if (err) return cb(err)
	
	      cb(null, results)
	    })
	  }
	
	  function toBatches (addrs) {
	    const batches = []
	    let copy = addrs.slice()
	    while (copy.length) {
	      let thisBatchSize = Math.min(copy.length, batchSize)
	      batches.push(copy.slice(0, thisBatchSize))
	      copy = copy.slice(thisBatchSize)
	    }
	
	    return batches
	  }
	
	  function syncBatch (batch, height, cb) {
	    // resetInterval()
	    blockchain.addresses.transactions(batch, function (err, txInfos) {
	      if (err) return cb(err)
	
	      try {
	        txInfos = txInfos.map(function (info) {
	          return utils.parseTx(info, networkName)
	        })
	      } catch (err) {
	        myDebug('failed to parse blockchain txs', err)
	        return cb(err)
	      }
	
	      txInfos.forEach(info => {
	        if (!info.confirmations && typeof info.blockHeight === 'number') {
	          info.confirmations = height - info.blockHeight
	        }
	      })
	
	      async.each(txInfos, processTx, function (err) {
	        if (err) cb(err)
	        else cb(null, txInfos)
	      })
	    })
	  }
	
	  // function maybeEmitErr (err) {
	  //   if (err) emitter.emit('error', err)
	  // }
	
	  function processTx (txInfo, cb) {
	    const toAddrs = txInfo.to.addresses
	
	    // check relevant watches
	    let watch
	    async.find(toAddrs, function iterator (address, done) {
	      watchesDB.findOne('address', address, function (err, result) {
	        watch = watch ? watch : result
	        done(null, err ? null : result)
	      })
	    }, function (err) {
	      if (err || !watch) return cb(err)
	
	      if (watch.txId) {
	        if (!txInfo.confirmations || txInfo.confirmations <= watch.confirmations) {
	          return cb()
	        }
	      }
	
	      const sealsExistingVersion = watch.watchType === constants.watchType.thisVersion
	      let addressProp, linkProp
	      if (sealsExistingVersion) {
	        addressProp = 'sealAddress'
	        linkProp = 'link'
	      } else {
	        addressProp = 'sealPrevAddress'
	        linkProp = 'prevLink'
	      }
	
	      // TODO: to avoid log-abuse, slim this down if txId is already known (on confirmations)
	      const data = {
	        [linkProp]: watch.link,
	        [addressProp]: watch.address,
	        // link: watch.link,
	        basePubKey: watch.basePubKey,
	        txId: txInfo.txId,
	        confirmations: txInfo.confirmations || 0,
	        // confirmed: txInfo.confirmations >= confirmedAfter,
	        addresses: toAddrs
	      }
	
	      if (sealsExistingVersion) return actions.readSeal(data, cb)
	
	      objectsDB.findOne('prevLink', watch.link, function (err, obj) {
	        if (obj) {
	          const { link } = obj
	          const sealAddress = utils.sealAddress(watch.basePubKey, link, networkName)
	          if (toAddrs.indexOf(sealAddress) !== -1) {
	            data.link = link
	            data.sealAddress = sealAddress
	          }
	
	          //   debug('ignoring transaction seals only previous version: ' + )
	        }
	
	        actions.readSeal(data, cb)
	      })
	
	      // lookup seal and object to figure out if this is
	      // a valid seal
	
	      // const uid = utils.sealUID({
	      //   networkName: networkName,
	      //   [addressProp]: watch.address,
	      //   link: watch.link
	      // })
	
	      // async.find([
	      //   function lookupSeal (done) {
	      //     seals.byLink(watch.link, function (err, seals) {
	      //       if (err) return done()
	
	      //       const sealed = seals.some(seal => {
	      //         const sealAddrs = utils.getSealAddresses(seal)
	      //         return sealAddrs.every(addr => toAddrs.indexOf(addr) !== -1)
	      //       })
	
	      //       done(null, sealed)
	      //     })
	      //   }
	      // ], cb)
	
	      // actions.readSeal({
	      //   link: watch.link,
	      //   address
	      // })
	    })
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(294)))

/***/ },

/***/ 1380:
/***/ function(module, exports, __webpack_require__) {

	
	'use strict'
	
	/** @module objectsDB */
	
	const EventEmitter = __webpack_require__(786).EventEmitter
	const collect = __webpack_require__(1051)
	const async = __webpack_require__(1239)
	const pump = __webpack_require__(1208)
	const through = __webpack_require__(1213)
	const typeforce = __webpack_require__(1207)
	const subdown = __webpack_require__(1240)
	const debug = __webpack_require__(787)('tradle:db:objects')
	const indexer = __webpack_require__(1381)
	const Readable = __webpack_require__(829).Readable
	const lexint = __webpack_require__(1400)
	const constants = __webpack_require__(1224)
	const utils = __webpack_require__(1225)
	const Status = __webpack_require__(1222)
	const SealStatus = Status.seal
	const SendStatus = Status.send
	const topics = __webpack_require__(1221)
	const types = __webpack_require__(1223)
	const IDENTITY = constants.TYPES.IDENTITY
	const MESSAGE_TYPE = constants.TYPES.MESSAGE
	const LINK = constants.LINK
	const SEQ = constants.SEQ
	const PREV_TO_SENDER = constants.PREV_TO_SENDER
	const PERMALINK = constants.PERMALINK
	const PREVLINK = constants.PREVLINK
	const SEPARATOR = constants.INDEX_SEPARATOR
	const ENTRY_PROP = constants.ENTRY_PROP
	
	// messages shouldn't be stored differently form
	// other objects. This will create annoying asymmetry for message/object seals
	
	module.exports = exports = createObjectDB
	
	/**
	 * @typedef {Object} objectsDB
	 */
	
	/**
	 * @alias module:objectsDB
	 * @param  {Object} opts
	 * @param  {Levelup} opts.db
	 * @param  {Keeper} opts.keeper
	 * @param  {changes} opts.changes
	 * @param  {IdentityInfo} opts.identityInfo
	 * @return {Object}
	 */
	function createObjectDB (opts) {
	  typeforce({
	    db: types.db,
	    keeper: types.keeper,
	    changes: types.changes,
	    identityInfo: types.identityInfo
	  }, opts)
	
	  let closed
	  opts.db.once('closing', () => closed = true)
	
	  const me = opts.identityInfo
	  const myDebug = utils.subdebugger(debug, opts.name || me.permalink.slice(0, 6))
	  const emitter = new EventEmitter()
	  const changes = opts.changes
	  const objTopics = [
	    topics.newobj,
	    topics.archiveobj,
	    topics.unarchiveobj,
	    topics.sent,
	    // topics.received,
	    topics.queueseal,
	    topics.readseal,
	    topics.wroteseal
	  ]
	
	  // we want to monitor each version being sent/sealed etc.
	  const primaryKey = 'link'
	  const indexedDB = indexer({
	    feed: changes,
	    db: opts.db,
	    primaryKey: primaryKey,
	    entryProp: ENTRY_PROP,
	    filter: function (val) {
	      return objTopics.indexOf(val.topic) !== -1
	    },
	    reduce: function (state, change, cb) {
	      let newState
	      const changeVal = change.value
	      const topic = changeVal.topic
	
	      switch (topic) {
	        case topics.queueseal: {
	          newState = state ? utils.clone(state) : utils.pick(changeVal, 'link')
	          newState.sealstatus = SealStatus.pending
	          break
	        }
	        case topics.readseal:
	        case topics.wroteseal: {
	          newState = state ? utils.clone(state) : utils.pick(changeVal, 'link')
	          newState.sealstatus = SealStatus.sealed
	          newState.txId = changeVal.txId
	          newState.confirmations = changeVal.confirmations
	          if (changeVal.sealAddress) newState.sealAddress = changeVal.sealAddress
	          if (changeVal.sealPrevAddress) newState.sealPrevAddress = changeVal.sealPrevAddress
	          break
	        }
	        case topics.archiveobj:
	        case topics.unarchiveobj: {
	          newState = state ? utils.clone(state) : utils.pick(changeVal, 'link')
	          const archiving = newState.archived = topic === topics.archiveobj
	          myDebug(`${archiving ? '': 'un'}archiving object: ${newState.link}`)
	          break
	        }
	        default: {
	          newState = indexedDB.merge(state, change)
	          break
	        }
	      }
	
	      delete newState.topic
	      cb(null, newState)
	    }
	  })
	
	  const sep = indexedDB.separator
	
	  // maybe these props should
	  const indexedProps = [
	    'sealstatus',
	    'sendstatus',
	    'watchstatus',
	    'confirmations',
	    // 'archived',
	    /*'type',*/
	    'link',
	    'prevLink',
	    'permalink',
	    'txId'
	  ]
	
	  const indexes = {}
	  indexedProps.forEach(prop => indexes[prop] = indexedDB.by(prop))
	
	  // need this because the by('permalink') points to 'link'
	  indexes.latest = indexedDB.by('latest', function (state) {
	    return state.permalink + sep + state.permalink
	  })
	
	  // latest versions only
	  indexes.type = indexedDB.by('type', function (state) {
	    // cannot retain log order here
	    // if log entry link is inserted, this index will not be overwritten
	    // on modifications to an object, as a modified object has a new `link`
	    return state.type && state.permalink
	      ? state.type + sep + state.permalink
	      : undefined
	  })
	
	  indexes.from = indexedDB.by('from', function (state, change) {
	    if (state.type === MESSAGE_TYPE) {
	      // retain log order
	      return state.author + sep + getEntryLink(state) + sep + state.link
	    }
	  })
	
	  indexes.to = indexedDB.by('to', function (state) {
	    if (state.type === MESSAGE_TYPE) {
	      // retain log order
	      return state.recipient + sep + getEntryLink(state) + sep + state.link
	    }
	  })
	
	  indexes.sendstatus = indexedDB.by('sendstatus', function (state) {
	    if (state.type === MESSAGE_TYPE && typeof state.sendstatus !== 'undefined') {
	      return state.sendstatus + sep +
	        state.recipient + sep +
	        // retain log order
	        getEntryLink(state) + sep +
	        state.link
	    }
	  })
	
	  indexes.lastMessage = indexedDB.by('lastMessage', function (state) {
	    if (state.type === MESSAGE_TYPE) {
	      // only one value per recipient
	      return state.author + sep + state.recipient + sep + 'last'
	    }
	  })
	
	  indexes.messagesWithObject = indexedDB.by('messagesWithObject', function (state) {
	    if (state.type === MESSAGE_TYPE) {
	      return state.objectinfo.permalink + sep + state.objectinfo.link + sep + state.permalink
	    }
	  })
	
	  const keeper = opts.keeper
	  indexedDB.on('change', function (change, newState, oldState) {
	    if (closed) return
	
	    const event = getEvent(change.value, oldState)
	    if (!event) return
	
	    keeper.get(newState.link, function (err, body) {
	      if (err) return emitter.emit('error', err)
	
	      newState = utils.clone(newState)
	      newState.object = body
	      emitter.emit(event, newState)
	    })
	  })
	
	  function addBodyTransform (opts) {
	    return through.obj(function (data, enc, cb) {
	      const val = opts.keys === false ? data : data.value
	      addBody(val, function (err) {
	        if (err) return cb(err)
	
	        cb(null, opts.keys === false ? val : data)
	      })
	    })
	  }
	
	  function addBody (val, cb) {
	    if (closed) return
	
	    keeper.get(val.link, function (err, body) {
	      if (err) return cb(err)
	
	      val.object = body
	      cb(null, val)
	    })
	  }
	
	  function getEvent (change, oldState) {
	    switch (change.topic) {
	    case topics.newobj:
	      if (change.recipient === me.permalink &&
	          change.author !== me.permalink &&
	          change.type === MESSAGE_TYPE) {
	        return 'message'
	      }
	
	      return
	    case topics.sent:
	      return 'sent'
	    case topics.wroteseal:
	      return 'wroteseal'
	    case topics.readseal:
	      // only emit for new seals
	      if (!oldState || oldState.confirmations == null) return 'readseal'
	    // case topics.received:
	    //   return 'message'
	    }
	  }
	
	  /**
	   * stream objects by type
	   * @param  {string}    type
	   * @param  {Object}    [opts]
	   * @param  {boolean}   [opts.body=true]
	   * @param  {boolean}   [opts.archived=false]
	   * @return {stream}
	   */
	  function byType (type, opts) {
	    opts = utils.extend({ eq: type, keys: false }, opts || {})
	    return indexes.type.createReadStream(opts)
	  }
	
	  Object.keys(indexes).forEach(prop => {
	    const index = indexes[prop]
	    const createReadStream = index.createReadStream
	    index.createReadStream = function (opts) {
	      opts = opts || {}
	      if (typeof opts === 'string') opts = { eq: opts }
	
	      const pipeline = [ createReadStream.call(index, opts) ]
	      // if (opts.excludeArchived !== false) {
	      //   pipeline.push(filterArchived(opts))
	      // }
	
	      if (!opts.archived) {
	        pipeline.push(utils.filterStream(notArchived))
	      }
	
	      if (opts.body !== false) {
	        pipeline.push(addBodyTransform(opts))
	      }
	
	      return executePipeline(pipeline)
	    }
	  })
	
	  // indexedProps.concat('latest', 'type').forEach(prop => {
	  //   indexAPIs[prop] = {
	  //     find: indexes[prop].find,
	  //     findOne: indexes[prop].findOne,
	  //     createReadStream:
	  //   }
	  // })
	
	  emitter.findOne = function (prop, val, cb) {
	    findOneByProp(prop, val, cb)
	  }
	
	  emitter.find = function (prop, val, cb) {
	    findByProp(prop, val, cb)
	  }
	
	  function findByProp (prop, val, cb) {
	    indexes[prop].find({ eq: val, keys: false }, wrapCallback(cb))
	  }
	
	  function findOneByProp (prop, val, cb) {
	    indexes[prop].findOne({ eq: val, keys: false }, wrapCallback(cb))
	  }
	
	  function from (opts) {
	    return indexes.from.createReadStream(utils.extend({ keys: false, body: false }, opts))
	  }
	
	  function to (opts) {
	    return indexes.to.createReadStream(utils.extend({ keys: false, body: false }, opts))
	  }
	
	  function streamFromTo (opts) {
	    const to = opts.to
	    const fromOpts = utils.omit(opts, 'from', 'to')
	    fromOpts.eq = opts.from
	    return pump(
	      from(fromOpts),
	      through.obj(function (data, enc, cb) {
	        if (data.recipient === to) {
	          cb(null, data)
	        } else {
	          cb()
	        }
	      })
	    )
	  }
	
	  function wrapStream (stream, opts) {
	    if (opts.archived) return stream
	
	    return stream.pipe(utils.filterStream(notArchived))
	  }
	
	  function notArchived (data) {
	    return !data.archived
	  }
	
	  function wrapCallback (cb, opts) {
	    if (!cb) return utils.noop
	    if (opts && opts.archived) return cb
	
	    return function (err, data) {
	      if (err || !data.archived) return cb(err, data)
	
	      cb(utils.notFoundErr())
	    }
	  }
	
	  function maybeAddBody (stream, opts) {
	    const pipeline = [ stream ]
	    if (opts.body !== false) {
	      pipeline.push(addBodyTransform(opts))
	    }
	
	    return executePipeline(pipeline)
	  }
	
	  function lastMessage (opts, cb) {
	    if (!(opts.from || opts.to) || (opts.from && opts.to)) {
	      throw new Error('expected "from" OR "to"')
	    }
	
	    // cb = once(cb)
	    const from = opts.from || me.permalink
	    const to = opts.to || me.permalink
	    opts = utils.omit(opts, 'from', 'to')
	    opts.eq = from + sep + to
	    opts.keys = false
	    opts.limit = 1
	    utils.firstInStream(indexes.lastMessage.createReadStream(opts), cb)
	    // indexes.lastMessage.createReadStream(opts)
	    //   .on('error', cb)
	    //   .on('data', data => cb(null, data))
	    //   .on('end', () => cb(new Error('NotFound')))
	  }
	
	  function listObjects (opts, cb) {
	    if (typeof opts === 'function') {
	      cb = opts
	      opts = null
	    }
	
	    return collect(streamLatest(opts), cb)
	  }
	
	  function streamLatest (opts) {
	    opts = utils.extend({ keys: false }, opts || {})
	    return indexes.latest.createReadStream(opts)
	  }
	
	  return utils.extend(emitter, {
	    index: indexes,
	    get: function (opts, cb) {
	      if (typeof opts === 'string') {
	        opts = { link: opts }
	      }
	
	      indexedDB.get(opts.link, wrapCallback(function (err, info) {
	        if (err || opts.body === false) return cb(err, info)
	
	        addBody(info, cb)
	      }, opts))
	    },
	    // get: function (link, cb) {
	    //   indexedDB.get(link, checkNotArchived(cb))
	    // },
	    byPermalink: function byPermalink (permalink, cb)  {
	      findOneByProp('latest', permalink, cb)
	    },
	    // byPermalink: function (permalink, cb)  {
	    //   indexes.latest.findOne(permalink, checkNotArchived(cb))
	    // },
	    unsent: function (opts) {
	      opts = opts || {}
	      opts.eq = SendStatus.pending
	      return indexes.sendstatus.createReadStream(opts)
	    },
	    unsentTo: function (recipient, opts) {
	      opts = opts || {}
	      opts.eq = SendStatus.pending + sep + recipient
	      return indexes.sendstatus.createReadStream(opts)
	    },
	    unsealed: function (opts={}) {
	      opts = opts || {}
	      opts.eq = SealStatus.pending
	      return indexes.sealstatus.createReadStream(opts)
	    },
	    sealed: function (opts={}) {
	      if (!('gte' in opts)) opts.gte = opts.confirmations || 0
	
	      return indexes.confirmations.createReadStream(opts)
	    },
	    createReadStream: streamLatest,
	    list: listObjects,
	    messages: function (opts) {
	      return byType(MESSAGE_TYPE, opts)
	    },
	    // messages: list.bind(null, MESSAGE_TYPE),
	    from: from,
	    to: to,
	    lastMessage: lastMessage,
	    type: byType,
	    exists: function exists (link, cb) {
	      indexedDB.get(link, wrapCallback(err => cb(!err)))
	    },
	    conversation: function conversation (opts) {
	      typeforce({
	        with: typeforce.maybe(typeforce.String),
	        body: typeforce.maybe(typeforce.Boolean),
	        a: typeforce.maybe(typeforce.String),
	        b: typeforce.maybe(typeforce.String)
	      }, opts)
	
	      if (!(opts.b || opts.with)) {
	        throw new Error('expected "with" or "b"')
	      }
	
	      const us = opts.a || me.permalink
	      const them = opts.b || opts.with
	      const outbound = streamFromTo({ from: us, to: them })
	      const inbound = streamFromTo({ from: them, to: us })
	
	      const pipeline = [
	        utils.mergeStreams([outbound, inbound], byLogPosition)
	      ]
	
	      if (opts.body !== false) {
	        pipeline.push(addBodyTransform({ keys: false }))
	      }
	
	      return executePipeline(pipeline)
	    },
	    nextMessageMetadata: function (opts, cb) {
	      typeforce({
	        with: typeforce.String,
	      }, opts)
	
	      lastMessage({
	        to: opts.with,
	        body: false,
	        archived: true
	      }, function (err, msg) {
	        const seq = err ? 0 : (msg.seq || 0) + 1
	        const meta = { [SEQ]: seq }
	        if (msg) meta[PREV_TO_SENDER] = msg.link
	
	        cb(null, meta)
	      })
	    },
	    messagesWithObject: function (opts) {
	      typeforce({
	        permalink: typeforce.String,
	        link: typeforce.maybe(typeforce.String)
	      }, opts)
	
	      let query = opts.permalink
	      if (opts.link) query += sep + opts.link
	
	      return indexes.messagesWithObject.createReadStream({ eq: query, keys: false })
	    },
	    addBody: addBody
	    // nextMessageSeq: function (opts, cb) {
	    //   typeforce({
	    //     with: typeforce.String,
	    //   }, opts)
	
	    //   lastMessage({
	    //     to: opts.with
	    //   }, function (err, msg) {
	    //     const seq = err ? 0 : (msg.object[SEQ] || 0) + 1
	    //     cb(null, seq)
	    //   })
	    // }
	  })
	}
	
	function byLogPosition (a, b) {
	  return a[ENTRY_PROP] - b[ENTRY_PROP]
	}
	
	function executePipeline (pipeline) {
	  return pipeline.length === 1 ? pipeline[0] : pump.apply(null, pipeline)
	}
	
	function getEntryLink (state) {
	  return lexint.pack(state[ENTRY_PROP], 'hex')
	}
	
	// function safeClone (state) {
	
	// }


/***/ },

/***/ 1401:
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	/** @module sealsDB */
	
	const EventEmitter = __webpack_require__(786).EventEmitter
	const typeforce = __webpack_require__(1207)
	const indexer = __webpack_require__(1381)
	const topics = __webpack_require__(1221)
	const statuses = __webpack_require__(1222)
	const SealStatus = statuses.seal
	const types = __webpack_require__(1223)
	// const reducer = require('../reducers').seal
	
	/**
	 * @typedef {Object} sealsDB
	 */
	
	/**
	 * blockchain seals database, bootstrapped from log
	 *
	 * @alias module:sealsDB
	 * @param  {Object} opts
	 * @param  {Object} opts.changes  changes-feed
	 * @param  {Object} opts.db       database to use to track seals
	 */
	module.exports = function createSealsDB (opts) {
	  typeforce({
	    changes: types.changes,
	    db: types.db
	  }, opts)
	
	  const syncInterval = opts.syncInterval || 10 * 60000 // 10 mins
	  const relevantTopics = [
	    topics.readseal,
	    topics.wroteseal,
	    topics.queueseal
	  ]
	
	  const indexedDB = indexer({
	    feed: opts.changes,
	    db: opts.db,
	    primaryKey: calcPrimaryKey,
	    filter: function (val) {
	      return relevantTopics.indexOf(val.topic) !== -1
	    },
	    reduce: function (state, change, cb) {
	      const newState = indexedDB.merge(state, change)
	      delete newState.topic
	      newState.uid = calcPrimaryKey(change.value)
	      cb(null, newState)
	    }
	  })
	
	  const indexedProps = ['sealAddress', 'sealPrevAddress', 'link', 'txId', 'status']
	  const indexes = {}
	  indexedProps.forEach(prop => indexes[prop] = indexedDB.by(prop))
	
	  const emitter = new EventEmitter()
	  indexedDB.on('change', function (change, newState, oldState) {
	    const event = getEvent(change.value, oldState)
	    if (event) emitter.emit(event, newState)
	  })
	
	  // function worker (change, cb) {
	  //   const val = change.value
	  //   if (relevantTopics.indexOf(val.topic) === -1) return cb()
	
	  //   const link = val.link
	  //   // live === false, because otherwise we'll get a deadlock
	  //   indexed.search('link', link, { live: false }, function (err, seals) {
	  //     if (seals.length > 1) {
	  //       throw new Error('found multiple seals for link: ' + link)
	  //     }
	
	  //     const state = seals[0]
	  //     if (!state) val.uid = utils.uuid()
	
	  //     const newState = reducer(state, val)
	  //     const batch = indexed.batchForChange(state, newState)
	  //     saveAndEmit(batch, newState, val, cb)
	  //   })
	  // }
	
	  // TODO: generalize
	  // this code is currently repeated in all dbs
	  // function saveAndEmit (batch, newState, changeVal, cb) {
	  //   db.batch(batch, function (err) {
	  //     if (err) return cb(err)
	
	  //     cb()
	
	  //     let event = getEvent(changeVal)
	  //     if (event) emitter.emit(event, newState)
	  //   })
	  // }
	
	  function calcPrimaryKey (change) {
	    // sealPrevAddress takes priority
	    // that way if sealAddress is not known initially,
	    // when it becomes known, the uid won't change
	    const primaryKey = change.sealPrevAddress || change.sealAddress
	    if (!primaryKey) throw new Error('unable to derive seal primaryKey')
	
	    return primaryKey
	    // return data.link + ':' + data.sealAddress
	  }
	
	  function getEvent (change, oldState) {
	    const topic = change.topic
	    switch (topic) {
	    case topics.readseal:
	      if (oldState && oldState.confirmations != null) return
	      /* fall through */
	    case topics.wroteseal:
	      return topic
	    }
	  }
	
	  emitter.get = indexedDB.get
	
	  // emitter.search = indexed.search.bind(indexed)
	  emitter.findOne = function (prop, val, cb) {
	    indexes[prop].findOne(val, cb)
	  }
	
	  emitter.find = function (prop, val, cb) {
	    indexes[prop].find(val, cb)
	  }
	
	  emitter.pending = function (opts) {
	    opts.eq = SealStatus.pending
	    return indexes.status.createReadStream(opts)
	  }
	
	  emitter.sealed = function (opts) {
	    opts.eq = SealStatus.sealed
	    return indexes.status.createReadStream(opts)
	  }
	
	  return emitter
	}
	
	// function logErr (err) {
	//   if (err) debug(err)
	// }


/***/ },

/***/ 1402:
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	/**
	 * @module watchesDB
	 */
	
	const extend = __webpack_require__(859)
	const collect = __webpack_require__(1051)
	const typeforce = __webpack_require__(1207)
	const subdown = __webpack_require__(1240)
	const debug = __webpack_require__(787)('tradle:db:watches')
	const indexer = __webpack_require__(1381)
	const utils = __webpack_require__(1225)
	const topics = __webpack_require__(1221)
	const types = __webpack_require__(1223)
	const statuses = __webpack_require__(1222)
	
	/**
	 * @typedef {Object} watchesDB
	 */
	
	/**
	 * database for monitored addresses, bootstrapped from log
	 * @alias module:watchesDB
	 * @param  {Object} opts
	 * @param  {Object} opts.changes            changes-feed
	 * @param  {Object} opts.db                 database to use to track seals
	 * @param  {Number} opts.confirmedAfter     how many confirmations to wait for before the watch is complete
	 */
	module.exports = function createWatchesDB (opts) {
	  typeforce({
	    changes: types.changes,
	    db: types.db,
	    confirmedAfter: typeforce.maybe(typeforce.Number)
	  }, opts)
	
	  const confirmedAfter = opts.confirmedAfter
	  const relevantTopics = [
	    topics.newwatch,
	    topics.readseal,
	    // topics.newobj
	  ]
	
	  const indexedDB = indexer({
	    feed: opts.changes,
	    db: opts.db,
	    primaryKey: calcPrimaryKey,
	    filter: function (val) {
	      return relevantTopics.indexOf(val.topic) !== -1
	    },
	    reduce: function (state, change, cb) {
	      const changeVal = change.value
	      if (state && changeVal.confirmations >= confirmedAfter) {
	        // delete
	        debug(`deleting watch for ${state.sealAddress} after ${changeVal.confirmations} confirmations`)
	        cb(null, null)
	      } else {
	        cb(null, indexedDB.merge(state, change))
	      }
	    }
	
	    // custom: function (change, cb) {
	    //   if (change.confirmations > 10) {
	
	    //   }
	    // },
	    // reduce: function (state, change, cb) {
	    //   const newState = indexedDB.merge(state, change)
	    //   // console.log('state', state)
	    //   // console.log('change', change)
	    //   cb(null, newState)
	    // }
	  })
	
	  const indexedProps = ['address', 'link', 'watchType', 'confirmations', 'blockHeight']
	  const indexes = {}
	  indexedProps.forEach(prop => indexes[prop] = indexedDB.by(prop))
	
	  const ee = {}
	
	  /**
	   * find the first match in the db for a given index property and value
	   * @memberOf! watchesDB
	   * @param  {string}          prop indexed property
	   * @param  {string|Number}   val
	   * @param  {Function} cb
	   */
	  ee.findOne = function (prop, val, cb) {
	    indexes[prop].findOne(val, cb)
	  }
	
	  /**
	   * find all matches in the db for a given index property and value
	   * @memberOf watchesDB
	   * @param  {string}          prop indexed property
	   * @param  {string|Number}   val
	   * @param  {Function} cb
	   */
	  ee.find = function (prop, val, cb) {
	    indexes[prop].find(val, cb)
	  }
	
	  /**
	   * find a watch by its primary keys
	   * @memberOf watchesDB
	   * @param  {Object}   opts
	   * @param  {string}   opts.address
	   * @param  {string}   opts.link
	   * @param  {Function} cb
	   */
	  ee.get = function (opts, cb) {
	    typeforce({
	      address: typeforce.String,
	      link: typeforce.String
	    }, opts)
	
	    const pKey = calcPrimaryKey(opts)
	    indexedDB.get(pKey, cb)
	  }
	
	  /**
	   * check if a watch exists by its primary keys
	   * @memberOf watchesDB
	   * @param  {Object}   opts
	   * @param  {string}   opts.address
	   * @param  {string}   opts.link
	   * @param  {Function} cb
	   */
	  ee.exists = function (opts, cb) {
	    ee.get(opts, function (err, result) {
	      cb(null, !!result)
	    })
	  }
	
	  /**
	   * stream stored watches
	   * @memberOf watchesDB
	   * @param  {Object}   opts  same as levelup.createReadStream opts
	   * @param  {Function} cb
	   */
	  ee.createReadStream = indexedDB.createReadStream
	
	  /**
	   * get all stored watches
	   * @memberOf watchesDB
	   * @param  {Function} cb
	   */
	  ee.list = function (cb) {
	    return collect(indexedDB.createReadStream({ keys: false }), cb)
	  }
	
	  /**
	   * live stream of watches
	   * @memberOf watchesDB
	   * @return {stream}
	   */
	  ee.follow = function () {
	    return indexedDB.createReadStream({
	      live: true,
	      tail: true,
	      old: false
	    })
	  }
	
	  return ee
	
	  function calcPrimaryKey (change) {
	    let parts
	    if (change.topic === topics.newwatch) {
	      parts = [
	        change.address,
	        change.link
	      ]
	    } else {
	      parts = [
	        change.sealPrevAddress || change.sealAddress,
	        change.prevLink || change.link
	      ]
	    }
	
	    typeforce.arrayOf(typeforce.String, parts)
	    return parts.join(indexedDB.separator)
	  }
	}


/***/ },

/***/ 1403:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {
	'use strict'
	
	/** @module addressBook */
	
	const EventEmitter = __webpack_require__(786).EventEmitter
	const async = __webpack_require__(1239)
	const pump = __webpack_require__(1208)
	const typeforce = __webpack_require__(1207)
	const through = __webpack_require__(1213)
	const subdown = __webpack_require__(1240)
	const debug = __webpack_require__(787)('tradle:addressBook')
	const indexer = __webpack_require__(1381)
	const protocol = __webpack_require__(1150)
	const clone = __webpack_require__(1404)
	// const LiveStream = require('level-live-stream')
	const constants = __webpack_require__(1224)
	const PERMALINK = constants.PERMALINK
	const LINK = constants.LINK
	const PREVLINK = constants.PREVLINK
	const utils = __webpack_require__(1225)
	const topics = __webpack_require__(1221)
	const types = __webpack_require__(1223)
	const TEST = ("development") === 'test'
	const IDENTITY_TYPE = constants.TYPES.IDENTITY
	const LINK_PREFIX = 'c!'
	
	/**
	 * @typedef {Object} AddressBook
	 * @property {Function} lookupIdentity
	 * @property {Function} byFingerprint
	 * @property {Function} byPubKey
	 * @property {Function} byLink
	 * @property {Function} byPermalink
	 * @property {Function} createReadStream
	 */
	
	/**
	 * address book database, bootstrapped from log
	 * @alias module:addressBook
	 * @param  {Object} opts
	 * @param  {changes} opts.changes           changes-feed
	 * @param  {levelup} opts.db                database to use to track identities
	 * @param  {Keeper} opts.keeper             object storage
	 * @param  {Object} [opts.name]             name, for logging
	 * @return {AddressBook}
	 */
	module.exports = function createAddressBook (opts) {
	  typeforce({
	    changes: types.changes,
	    db: types.db,
	    keeper: types.keeper,
	    // identityInfo: types.identityInfo,
	    name: typeforce.maybe(typeforce.String)
	  }, opts)
	
	  let cache
	  let closed
	  opts.db.once('closing', () => closed = true)
	
	  let me
	  let myDebug
	  if (opts.identityInfo) setIdentityInfo(opts.identityInfo)
	
	  const keeper = opts.keeper
	  const relevantTopics = [
	    topics.addcontact
	  ]
	
	  const primaryKey = 'permalink'
	  const indexedDB = indexer({
	    feed: opts.changes,
	    db: opts.db,
	    primaryKey: primaryKey,
	    filter: function (val) {
	      return relevantTopics.indexOf(val.topic) !== -1
	    },
	    reduce: function (state, change, cb) {
	      if (closed) return
	
	      keeper.get(change.value.link, function (err, body) {
	        if (err) return cb(err)
	        if (state) uncacheIdentity(state)
	
	        const newState = indexedDB.merge(state, change)
	        delete newState.topic
	        newState.object = body
	        cacheIdentity(newState)
	        cb(null, newState)
	      })
	    }
	  })
	
	  const emitter = new EventEmitter()
	  indexedDB.on('change', function (change, state) {
	    myDebug('added contact: ' + utils.uid(state))
	    emitter.emit('contact', state)
	  })
	
	  // maybe these props should
	  const simple = ['link', 'permalink'] //, 'prevLink']
	  const complex = ['fingerprint', 'pub']
	  const indexedProps = simple.concat(complex)
	  const indexes = {}
	
	  simple.forEach(prop => indexes[prop] = indexedDB.by(prop))
	  complex.forEach(prop => {
	    indexes[prop] = indexedDB.by(prop, function reducer (state, cb) {
	      return state.object.pubkeys.map(key => {
	        myDebug('indexing by ' + prop, key[prop])
	        return key[prop] + indexedDB.separator + state[primaryKey]
	      })
	    })
	  })
	
	  const indexMap = {}
	  indexes.pub.on('change', function (state, iMap) {
	    utils.extend(indexMap, iMap)
	  })
	
	  indexes.link.on('change', function (state, val) {
	    indexMap[val] = state.permalink
	  })
	
	  /**
	   * lookup an identity by a fingerprint, pubKey, link or permalink
	   * @param  {String}   propVal
	   * @param  {Function} cb
	   */
	  function lookupIdentity (propVal, cb) {
	    if (!propVal) throw new Error('expected "propVal"')
	
	    if (typeof propVal === 'object') {
	      if (propVal.permalink) return findOneByProp('permalink', propVal.permalink, cb)
	      if (propVal.link) return findOneByProp('link', propVal.link, cb)
	      if (propVal.fingerprint) return findOneByProp('fingerprint', propVal.fingerprint, cb)
	      if (propVal.pubKey) return findOneByProp('pub', utils.pubKeyString(propVal.pubKey), cb)
	    }
	
	    let match
	    async.some(indexedProps, function iterator (prop, done) {
	      findOneByProp(prop, propVal, function (err, result) {
	        if (err) return done()
	
	        match = match || result
	        done(null, true)
	      })
	    }, function (err) {
	      if (err) return cb(err)
	      if (!match) return cb(utils.notFoundErr())
	
	      cb(null, match)
	    })
	  }
	
	  function setIdentityInfo (identityInfo) {
	    me = opts.identityInfo
	    myDebug = utils.subdebugger(debug, opts.name || me.permalink.slice(0, 6))
	  }
	
	  function findOneByProp (prop, val, cb) {
	    const has = hasCachedBy(prop, val)
	    if (!has) {
	      return findOneByPropInDB(prop, val, cb)
	    }
	
	    indexedDB.onLive(() => {
	      // may have been deleted from cache
	      const cached = getCachedBy(prop, val)
	      if (cached) {
	        // return defensive copy
	        return process.nextTick(() => cb(null, clone(cached)))
	      }
	
	      findOneByPropInDB(prop, val, cb)
	    })
	  }
	
	  function findOneByPropInDB (prop, val, cb) {
	    indexes[prop].findOne({ eq: val, keys: false }, function (err, result) {
	      if (err) return cb(err)
	
	      cacheIdentity(result)
	      cb(null, result)
	    })
	  }
	
	  function close () {
	    closed = true
	  }
	
	  function uncacheIdentity (identityInfo) {
	    updateCache(identityInfo, true)
	  }
	
	  function cacheIdentity (identityInfo) {
	    updateCache(identityInfo)
	  }
	
	  function updateCache (identityInfo, remove) {
	    if (!cache) return
	
	    updateCacheBy('permalink', identityInfo.permalink, identityInfo, remove)
	    updateCacheBy('link', identityInfo.link, identityInfo, remove)
	    // const prevlink = identityInfo.object[PREVLINK]
	    // if (prevlink) {
	    //   updateCacheBy('prevlink', identityInfo.link, identityInfo, remove)
	    // }
	
	    identityInfo.object.pubkeys.forEach(pubKey => {
	      updateCacheBy('pub', pubKey.pub, identityInfo, remove)
	      updateCacheBy('fingerprint', pubKey.fingerprint, identityInfo, remove)
	    })
	  }
	
	  function updateCacheBy (prop, val, identityInfo, remove) {
	    if (cache) {
	      if (remove) cache.del(prop + val)
	      else {
	        // make defensive copy before storing
	        cache.set(prop + val, clone(identityInfo))
	      }
	    }
	  }
	
	  function getCachedBy (prop, val) {
	    return cache && cache.get(prop + val)
	  }
	
	  function hasCachedBy (prop, val) {
	    return cache && cache.has(prop + val)
	  }
	
	  return utils.extend(emitter, {
	    lookupIdentity: lookupIdentity,
	    byFingerprint: findOneByProp.bind(null, 'fingerprint'),
	    byPubKey: function (val, cb) {
	      findOneByProp('pub', utils.pubKeyString(val), cb)
	    },
	    // byPubKey: function (pubKey) {
	    //   findOneByProp('pub', pubKey, function () {
	    //     console.log(arguments)
	    //   })
	    // },
	    byLink: findOneByProp.bind(null, 'link'),
	    // byLink: function (link) {
	    //   findOneByProp('link', link, function () {
	    //     console.log(arguments)
	    //   })
	    // },
	    byPermalink: findOneByProp.bind(null, 'permalink'),
	    createReadStream: function (opts) {
	      opts = opts || {}
	      if (opts.keys !== true) opts.keys = false
	
	      return indexedDB.createReadStream(opts)
	    },
	    setIdentityInfo: setIdentityInfo,
	    setCache: c => cache = c,
	    getCache: TEST ? () => cache : null
	  })
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(294)))

/***/ },

/***/ 1404:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var clone = (function() {
	'use strict';
	
	var nativeMap;
	try {
	  nativeMap = Map;
	} catch(_) {
	  // maybe a reference error because no `Map`. Give it a dummy value that no
	  // value will ever be an instanceof.
	  nativeMap = function() {};
	}
	
	var nativeSet;
	try {
	  nativeSet = Set;
	} catch(_) {
	  nativeSet = function() {};
	}
	
	var nativePromise;
	try {
	  nativePromise = Promise;
	} catch(_) {
	  nativePromise = function() {};
	}
	
	/**
	 * Clones (copies) an Object using deep copying.
	 *
	 * This function supports circular references by default, but if you are certain
	 * there are no circular references in your object, you can save some CPU time
	 * by calling clone(obj, false).
	 *
	 * Caution: if `circular` is false and `parent` contains circular references,
	 * your program may enter an infinite loop and crash.
	 *
	 * @param `parent` - the object to be cloned
	 * @param `circular` - set to true if the object to be cloned may contain
	 *    circular references. (optional - true by default)
	 * @param `depth` - set to a number if the object is only to be cloned to
	 *    a particular depth. (optional - defaults to Infinity)
	 * @param `prototype` - sets the prototype to be used when cloning an object.
	 *    (optional - defaults to parent prototype).
	 * @param `includeNonEnumerable` - set to true if the non-enumerable properties
	 *    should be cloned as well. Non-enumerable properties on the prototype
	 *    chain will be ignored. (optional - false by default)
	*/
	function clone(parent, circular, depth, prototype, includeNonEnumerable) {
	  if (typeof circular === 'object') {
	    depth = circular.depth;
	    prototype = circular.prototype;
	    includeNonEnumerable = circular.includeNonEnumerable;
	    circular = circular.circular;
	  }
	  // maintain two arrays for circular references, where corresponding parents
	  // and children have the same index
	  var allParents = [];
	  var allChildren = [];
	
	  var useBuffer = typeof Buffer != 'undefined';
	
	  if (typeof circular == 'undefined')
	    circular = true;
	
	  if (typeof depth == 'undefined')
	    depth = Infinity;
	
	  // recurse this function so we don't reset allParents and allChildren
	  function _clone(parent, depth) {
	    // cloning null always returns null
	    if (parent === null)
	      return null;
	
	    if (depth === 0)
	      return parent;
	
	    var child;
	    var proto;
	    if (typeof parent != 'object') {
	      return parent;
	    }
	
	    if (parent instanceof nativeMap) {
	      child = new nativeMap();
	    } else if (parent instanceof nativeSet) {
	      child = new nativeSet();
	    } else if (parent instanceof nativePromise) {
	      child = new nativePromise(function (resolve, reject) {
	        parent.then(function(value) {
	          resolve(_clone(value, depth - 1));
	        }, function(err) {
	          reject(_clone(err, depth - 1));
	        });
	      });
	    } else if (clone.__isArray(parent)) {
	      child = [];
	    } else if (clone.__isRegExp(parent)) {
	      child = new RegExp(parent.source, __getRegExpFlags(parent));
	      if (parent.lastIndex) child.lastIndex = parent.lastIndex;
	    } else if (clone.__isDate(parent)) {
	      child = new Date(parent.getTime());
	    } else if (useBuffer && Buffer.isBuffer(parent)) {
	      child = new Buffer(parent.length);
	      parent.copy(child);
	      return child;
	    } else if (parent instanceof Error) {
	      child = Object.create(parent);
	    } else {
	      if (typeof prototype == 'undefined') {
	        proto = Object.getPrototypeOf(parent);
	        child = Object.create(proto);
	      }
	      else {
	        child = Object.create(prototype);
	        proto = prototype;
	      }
	    }
	
	    if (circular) {
	      var index = allParents.indexOf(parent);
	
	      if (index != -1) {
	        return allChildren[index];
	      }
	      allParents.push(parent);
	      allChildren.push(child);
	    }
	
	    if (parent instanceof nativeMap) {
	      var keyIterator = parent.keys();
	      while(true) {
	        var next = keyIterator.next();
	        if (next.done) {
	          break;
	        }
	        var keyChild = _clone(next.value, depth - 1);
	        var valueChild = _clone(parent.get(next.value), depth - 1);
	        child.set(keyChild, valueChild);
	      }
	    }
	    if (parent instanceof nativeSet) {
	      var iterator = parent.keys();
	      while(true) {
	        var next = iterator.next();
	        if (next.done) {
	          break;
	        }
	        var entryChild = _clone(next.value, depth - 1);
	        child.add(entryChild);
	      }
	    }
	
	    for (var i in parent) {
	      var attrs;
	      if (proto) {
	        attrs = Object.getOwnPropertyDescriptor(proto, i);
	      }
	
	      if (attrs && attrs.set == null) {
	        continue;
	      }
	      child[i] = _clone(parent[i], depth - 1);
	    }
	
	    if (Object.getOwnPropertySymbols) {
	      var symbols = Object.getOwnPropertySymbols(parent);
	      for (var i = 0; i < symbols.length; i++) {
	        // Don't need to worry about cloning a symbol because it is a primitive,
	        // like a number or string.
	        var symbol = symbols[i];
	        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);
	        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
	          continue;
	        }
	        child[symbol] = _clone(parent[symbol], depth - 1);
	        if (!descriptor.enumerable) {
	          Object.defineProperty(child, symbol, {
	            enumerable: false
	          });
	        }
	      }
	    }
	
	    if (includeNonEnumerable) {
	      var allPropertyNames = Object.getOwnPropertyNames(parent);
	      for (var i = 0; i < allPropertyNames.length; i++) {
	        var propertyName = allPropertyNames[i];
	        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);
	        if (descriptor && descriptor.enumerable) {
	          continue;
	        }
	        child[propertyName] = _clone(parent[propertyName], depth - 1);
	        Object.defineProperty(child, propertyName, {
	          enumerable: false
	        });
	      }
	    }
	
	    return child;
	  }
	
	  return _clone(parent, depth);
	}
	
	/**
	 * Simple flat clone using prototype, accepts only objects, usefull for property
	 * override on FLAT configuration object (no nested props).
	 *
	 * USE WITH CAUTION! This may not behave as you wish if you do not know how this
	 * works.
	 */
	clone.clonePrototype = function clonePrototype(parent) {
	  if (parent === null)
	    return null;
	
	  var c = function () {};
	  c.prototype = parent;
	  return new c();
	};
	
	// private utility functions
	
	function __objToStr(o) {
	  return Object.prototype.toString.call(o);
	}
	clone.__objToStr = __objToStr;
	
	function __isDate(o) {
	  return typeof o === 'object' && __objToStr(o) === '[object Date]';
	}
	clone.__isDate = __isDate;
	
	function __isArray(o) {
	  return typeof o === 'object' && __objToStr(o) === '[object Array]';
	}
	clone.__isArray = __isArray;
	
	function __isRegExp(o) {
	  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
	}
	clone.__isRegExp = __isRegExp;
	
	function __getRegExpFlags(re) {
	  var flags = '';
	  if (re.global) flags += 'g';
	  if (re.ignoreCase) flags += 'i';
	  if (re.multiline) flags += 'm';
	  return flags;
	}
	clone.__getRegExpFlags = __getRegExpFlags;
	
	return clone;
	})();
	
	if (typeof module === 'object' && module.exports) {
	  module.exports = clone;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(820).Buffer))

/***/ },

/***/ 1405:
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	/** @module simpleCustomDB */
	
	const EventEmitter = __webpack_require__(786).EventEmitter
	const pump = __webpack_require__(1208)
	const through = __webpack_require__(1213)
	const indexer = __webpack_require__(1381)
	const typeforce = __webpack_require__(1207)
	const topics = __webpack_require__(1221)
	const types = __webpack_require__(1223)
	const utils = __webpack_require__(1225)
	const constants = __webpack_require__(1224)
	const TYPE = constants.TYPE
	const MESSAGE_TYPE = constants.MESSAGE_TYPE
	const ENTRY_PROP = constants.ENTRY_PROP
	
	/**
	 * @typedef {Object} simpleCustomDB
	 */
	
	/**
	 * blockchain seals database, bootstrapped from log
	 *
	 * @alias module:simpleCustomDB
	 * @param  {Object} opts
	 * @param  {Object} opts.changes  changes-feed
	 * @param  {Object} opts.keeper   keeper
	 * @param  {Object} opts.db       database to use to track message context
	 */
	module.exports = function simpleCustomDB (opts) {
	  typeforce({
	    changes: types.changes,
	    keeper: types.keeper,
	    db: types.db,
	    props: typeforce.Array,
	    getProps: typeforce.maybe(typeforce.Function),
	    preprocess: typeforce.maybe(typeforce.Function),
	    needBody: typeforce.maybe(typeforce.Boolean),
	    primaryKey: typeforce.maybe(typeforce.String)
	  }, opts)
	
	  let closed
	  opts.db.once('closing', () => closed = true)
	
	  const keeper = opts.keeper
	  const primaryKey = opts.primaryKey || 'link'
	  const props = opts.props
	  const getProps = opts.getProps
	  const indexedDB = indexer({
	    feed: opts.changes,
	    db: opts.db,
	    primaryKey: primaryKey,
	    entryProp: ENTRY_PROP,
	    preprocess: opts.preprocess || function defaultPreprocess (change, cb) {
	      if (needBody) return addBodyToChange(change, cb)
	
	      cb(null, change)
	    },
	    reduce: function (state, change, cb) {
	      const val = change.value
	      const picked = getProps ? getProps(val) : utils.pick(val, props)
	      if (!Object.keys(picked).length) return cb()
	
	      picked[primaryKey] = change.value[primaryKey]
	      cb(null, picked)
	    }
	  })
	
	  const indexes = {}
	  const api = {}
	  props.forEach(p => {
	    indexes[p] = indexedDB.by(p)
	    api[p] = streamer(p)
	  })
	
	  return api
	
	  function streamer (prop) {
	    return function (opts) {
	      if (typeof opts === 'string') opts = { eq: opts, keys: false }
	
	      const pipeline = [
	        indexes[prop].createReadStream(opts),
	        through.obj(function (data, enc, cb) {
	          const value = opts.keys === false ? data : data.value
	          delete value[ENTRY_PROP]
	          cb(null, data)
	        })
	      ]
	
	      if (opts.body) {
	        pipeline.push(addBodyTransform(opts))
	      }
	
	      return pump(pipeline)
	    }
	  }
	
	  function addBodyToChange (change, cb) {
	    const val = change.value
	    keeper.get(val.link, function (err, body) {
	      if (err) return cb()
	
	      val.object = body
	      cb(null, change)
	    })
	  }
	
	  function addBodyToValue (val, cb) {
	    if (closed) return
	
	    keeper.get(val.link, function (err, body) {
	      if (err) return cb(err)
	
	      val.object = body
	      cb(null, val)
	    })
	  }
	
	  function addBodyTransform (opts) {
	    return through.obj(function (data, enc, cb) {
	      const val = opts.keys === false ? data : data.value
	      addBodyToValue(val, function (err) {
	        if (err) return cb(err)
	
	        cb(null, opts.keys === false ? val : data)
	      })
	    })
	  }
	}


/***/ },

/***/ 1406:
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	/** @module msgMetaDB */
	
	const EventEmitter = __webpack_require__(786).EventEmitter
	const pump = __webpack_require__(1208)
	const through = __webpack_require__(1213)
	const indexer = __webpack_require__(1381)
	const typeforce = __webpack_require__(1207)
	const topics = __webpack_require__(1221)
	const types = __webpack_require__(1223)
	const utils = __webpack_require__(1225)
	const constants = __webpack_require__(1224)
	const TYPE = constants.TYPE
	const MESSAGE_TYPE = constants.MESSAGE_TYPE
	const ENTRY_PROP = constants.ENTRY_PROP
	
	/**
	 * @typedef {Object} msgMetaDB
	 */
	
	/**
	 * blockchain seals database, bootstrapped from log
	 *
	 * @alias module:msgMetaDB
	 * @param  {Object} opts
	 * @param  {Object} opts.changes  changes-feed
	 * @param  {Object} opts.keeper   keeper
	 * @param  {Object} opts.db       database to use to track message context
	 */
	module.exports = function createMsgMetaDB (opts) {
	  typeforce({
	    node: typeforce.Object,
	    db: typeforce.String,
	    props: typeforce.Array,
	    getProps: typeforce.maybe(typeforce.Function)
	  }, opts)
	
	  const node = opts.node
	  const props = opts.props
	
	  return node.customIndexes(utils.extend({
	    preprocess: preprocess,
	    getProps: opts.getProps || pickProps
	  }, opts))
	
	  function preprocess (change, cb) {
	    const val = change.value
	    if (val.type !== MESSAGE_TYPE || change.value.topic !== topics.newobj) return cb()
	
	    node.keeper.get(val.permalink, function (err, body) {
	      if (err) return cb(null, change)
	
	      val.object = body
	      cb(null, change)
	    })
	  }
	
	  function pickProps (val) {
	    return utils.pick(val.object, props)
	  }
	}


/***/ },

/***/ 1407:
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	/**
	 * @module validator
	 */
	
	const typeforce = __webpack_require__(1207)
	const async = __webpack_require__(1239)
	const protocol = __webpack_require__(1150)
	const constants = __webpack_require__(1224)
	const utils = __webpack_require__(1225)
	const types = __webpack_require__(1223)
	const errors = __webpack_require__(1327)
	const MESSAGE_TYPE = __webpack_require__(1224).TYPES.MESSAGE
	const PERMALINK = constants.PERMALINK
	const PREVLINK = constants.PREVLINK
	const SIG = constants.SIG
	const TYPE = constants.TYPE
	
	/**
	 * message / object validation
	 * @alias module:validator
	 * @param  {node} node
	 * @return {Object}
	 */
	module.exports = function validator (node) {
	  return {
	    validate,
	    checkExists,
	    checkPrev,
	    checkAuthentic
	  }
	
	  function validate (wrapper, opts, cb) {
	    if (typeof opts === 'function') {
	      cb = opts
	      opts = {}
	    }
	
	    utils.addLinks(wrapper)
	    const tasks = [
	      done => utils.loadBG(node, wrapper, done)
	    ]
	
	    if (opts.unique) {
	      tasks.unshift(done => checkExists(wrapper, done))
	    }
	
	    async.series(tasks, function (err) {
	      if (err) return cb(err)
	
	      try {
	        checkPrev(wrapper)
	      } catch (err) {
	        return cb(err)
	      }
	
	      checkAuthentic(wrapper, cb)
	    })
	  }
	
	  // function validate (wrapper, cb) {
	  //   utils.addLinks(wrapper)
	
	  //   const isMsg = wrapper.object[TYPE] === MESSAGE_TYPE
	  //   node.objects.get(wrapper.link, function (err) {
	  //     if (!err && isMsg) {
	  //       return cb(new errors.ObjectExists({ link: wrapper.link }))
	  //     }
	
	  //     // utils.extend(node, wrapper, opts)
	  //     utils.loadBG(node, wrapper, function (err) {
	  //       if (err) return cb(err)
	
	  //       const object = wrapper.object
	  //       const sig = object[SIG]
	  //       const link = wrapper.link
	  //       let signingKey
	  //       try {
	  //         signingKey = utils.getSigPubKey(object)
	  //       } catch (err) {
	  //       }
	
	  //       if (!signingKey) return cb(new errors.InvalidSignature({ sig }))
	
	  //       if (!utils.hasPubKey(wrapper.author.object, signingKey)) {
	  //         return cb(new errors.Author({
	  //           author: wrapper.author.link,
	  //           sig: sig
	  //         }))
	  //       }
	
	  //       if (isMsg) {
	  //         try {
	  //           // TODO: msg.prev
	  //           protocol.validateMessage({ object })
	  //         } catch (err) {
	  //           return cb(err)
	  //         }
	  //       }
	
	  //       cb()
	  //     })
	  //   })
	  // }
	
	  function checkExists (wrapper, cb) {
	    node.objects.get({ link: wrapper.link, body: false }, function (err) {
	      cb(err ? null : new errors.ObjectExists({ link: wrapper.link }))
	    })
	  }
	
	  function checkPrev (wrapper) {
	    const object = wrapper.object
	    const prev = wrapper.prev
	    // we may not have the previous version in our db
	    if (!object[PREVLINK] || !prev) return
	
	    if (prev.author !== wrapper.author.permalink) {
	      throw new errors.InvalidVersion({
	        error: 'prev version has a different author'
	      })
	    }
	
	    try {
	      protocol.validateVersioning({
	        object,
	        prev: prev.object,
	        orig: object[PERMALINK]
	      })
	    } catch (err) {
	      throw new errors.InvalidVersion({
	        error: err.message
	      })
	    }
	
	    if (prev[PERMALINK] && prev[PERMALINK] !== object[PERMALINK]) {
	      throw new errors.InvalidVersion({
	        error: `prev version has a different ${PERMALINK}`
	      })
	    }
	  }
	
	  function checkAuthentic (wrapper, cb) {
	    const object = wrapper.object
	    const sig = object[SIG]
	    const link = wrapper.link
	    utils.extractSigPubKey(object, function (err, signingKey) {
	      if (err || !signingKey) return cb(new errors.InvalidSignature({ sig }))
	
	      const pubKey = utils.findPubKey(wrapper.author.object, signingKey)
	      if (!pubKey) {
	        return cb(new errors.Author({
	          author: wrapper.author.link,
	          sig: sig
	        }))
	      }
	
	      const expectedPurpose = object[TYPE] === constants.TYPES.IDENTITY ? 'update' : 'sign'
	      if (pubKey.purpose !== expectedPurpose) {
	        return cb(new errors.InvalidSignature({ sig, reason: 'wrong signing key was used' }))
	      }
	
	      cb()
	    })
	  }
	}


/***/ },

/***/ 1408:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, Buffer) {'use strict'
	
	/** @module node */
	
	const util = __webpack_require__(1130)
	const EventEmitter = __webpack_require__(786).EventEmitter
	const path = __webpack_require__(1409)
	const extend = __webpack_require__(1151)
	const clone = __webpack_require__(859)
	const reemit = __webpack_require__(1410)
	const map = __webpack_require__(1411)
	const mutexify = __webpack_require__(1146)
	// const trackchain = require('chain-tracker')
	const async = __webpack_require__(1239)
	const debug = __webpack_require__(787)('tradle:node')
	const protocol = __webpack_require__(1150)
	const changesFeed = __webpack_require__(1412)
	const collect = __webpack_require__(1051)
	const deepEqual = __webpack_require__(711)
	// const subdown = require('subleveldown')
	const tradle = __webpack_require__(1149)
	const typeforce = __webpack_require__(1207)
	const createActions = __webpack_require__(1420)
	const symbols = __webpack_require__(1421)
	const errors = __webpack_require__(1327)
	const statuses = __webpack_require__(1222)
	const DEFAULT_OPTS = __webpack_require__(1422)
	const SealStatus = statuses.seal
	const createValidator = __webpack_require__(1407)
	const constants = __webpack_require__(1224)
	const {
	  MESSAGE_TYPE,
	  TYPES,
	  TYPE,
	  SIG,
	  SEQ,
	  PERMALINK,
	  LINK,
	  PREVLINK
	} = constants
	
	const { PARTIAL } = TYPES
	const utils = tradle.utils
	const createDB = tradle.dbs
	const createSealWatcher = tradle.sealwatch
	const createSealer = tradle.sealer
	const createSender = tradle.sender
	const topics = tradle.constants.topics
	const createLiveQueue = tradle.queue
	// const Status = tradle.constants.status
	const types = tradle.types
	// const MAX_CONFIRMATIONS = 10
	const noop = () => {}
	
	/**
	 * @typedef {Object} node
	 */
	
	/**
	 * main API to tradle engine
	 *
	 * @constructor
	 * @alias module:node
	 * @param {Object} opts
	 * @param {string} opts.dir               directory in which to store data
	 * @param {string} opts.networkName       currently 'testnet' or 'bitcoin'
	 * @param {Object} opts.blockchain        common-blockchain client instance
	 * @param {Object} opts.identity          this node's identity
	 * @param {Object} opts.keeper            object storage (see tradle/keeper)
	 * @param {Array}  opts.keys              keys controlled by this identity
	 * @param {Object} opts.leveldown         leveldown backend to use with internal databases
	 * @param {Object} [opts.transactor]      [see transactor]{@link types#transactor}
	 * @param {Number} [opts.syncInterval]    how often to sync with the blockchain
	 * @param {Number} [opts.confirmedAfter]  how many confirmations till a transaction is deemed confirmed
	 * @param {string} [opts.name]            this node's name (for a more readable log)
	 * @property {AddressBook} addressBook
	 * @property {sealsDB}     seals
	 * @property {objectsDB}   objects
	 * @property {identity}    identity
	 * @property {Array}       keys
	 * @property {sender}      sender
	 * @property {sealer}      sealer
	 */
	function Tradle (opts) {
	  const self = this
	  if (!(this instanceof Tradle)) return new Tradle (opts)
	
	  typeforce({
	    networkName: typeforce.String,
	    dir: typeforce.String,
	    blockchain: typeforce.Object,
	    identity: types.identity,
	    keeper: types.keeper,
	    keys: typeforce.Array,
	    leveldown: types.leveldown,
	    transactor: typeforce.maybe(types.transactor),
	    syncInterval: typeforce.maybe(typeforce.Number),
	    confirmedAfter: typeforce.maybe(typeforce.Number),
	    name: typeforce.maybe(typeforce.String),
	    lockTimeout: typeforce.maybe(typeforce.Number)
	    // merkle: typeforce.maybe(typeforce.compile({
	    //   leaf: typeforce.Function,
	    //   parent: typeforce.Function
	    // }), opts.merkle)
	  }, opts)
	
	  extend(this, DEFAULT_OPTS, opts)
	  utils.bindFunctions(this)
	
	  this.opts = opts
	  this._levelOpts = { db: this.leveldown }
	
	  const logDB = this._logDB = this._createDB('log.db')
	  const changes = this.changes = changesFeed(logDB)
	
	  this.setIdentity(opts)
	  this.actions = createActions({ changes, node: this })
	
	  if (!this.name) this.name = this.permalink
	
	  // init dbs
	  this.dbs = {
	    objects: this._createDB('objects.db'),
	    seals: this._createDB('seals.db'),
	    addressBook: this._createDB('addressBook.db'),
	    watches: this._createDB('watches.db')
	  }
	
	  this.objects = createDB.objects({
	    name: this.name,
	    changes: changes,
	    // db: subdown(ldb, 'o'),
	    db: this.dbs.objects,
	    keeper: this.keeper,
	    identityInfo: this.identityInfo
	  })
	
	  this.seals = createDB.seals({
	    changes: changes,
	    // db: subdown(ldb, 's'),
	    db: this.dbs.seals,
	    keeper: this.keeper
	  })
	
	  this.watches = createDB.watches({
	    changes: changes,
	    db: this.dbs.watches,
	    confirmedAfter: this.confirmedAfter
	    // db: subdown(ldb, 'w')
	  })
	
	  // this.txs = createTxsDB({
	  //   changes: changes,
	  //   db: subdown(ldb, 't'),
	  //   keeper: keeper
	  // })
	
	  this.addressBook = createDB.addressBook({
	    changes: changes,
	    keeper: this.keeper,
	    db: this.dbs.addressBook,
	    identityInfo: this.identityInfo
	    // db: subdown(ldb, 'a')
	  })
	
	  this.sealwatch = createSealWatcher(this)
	  reemit(this.sealwatch, this, ['seal'])
	
	  // init various queues
	  if (this.transactor) {
	    this.sealer = createSealer(this)
	    reemit(this.sealer, this, ['sealed'])
	  }
	
	  this.sender = createSender({
	    name: this.name,
	    objects: this.objects,
	    send: function () {
	      return self._send.apply(self, arguments)
	    },
	    actions: this.actions,
	    addressBook: this.addressBook
	  })
	
	  reemit(this.sender, this, ['sent'])
	
	  // this.setIdentity(this.identity)
	
	  // misc
	
	  this.validator = createValidator(this)
	  this._saving = {}
	
	  ;[
	    { event: 'sent', db: this.objects },
	    { event: 'message', db: this.objects },
	    { event: 'readseal', db: this.seals },
	    { event: 'wroteseal', db: this.seals }
	  ].forEach(conf => {
	    conf.db.on(conf.event, state => {
	      if (this._destroyed) return
	
	      let { event } = conf
	      let { link, prevLink } = state
	      if (event === 'readseal' && !link) {
	        event = 'newversion'
	        link = prevLink
	      }
	
	      this.keeper.get(link, (err, body) => {
	        if (this._destroyed) return
	        if (err) {
	          this._debug(`missing object ${state.link}`)
	          return this.emit('error', err)
	        }
	
	        state.object = body
	        this.emit(event, state)
	      })
	    })
	  })
	
	  this._locks = {}
	  this._init()
	  this._onready(() => {
	    this._exec('start')
	  })
	  // utils.lockify(this, ['createObject', 'addContact'])
	}
	
	module.exports = Tradle
	util.inherits(Tradle, EventEmitter)
	
	/**
	 * Initialize the node
	 * @private
	 */
	Tradle.prototype._init = function init () {
	  // add ourselves to our own addressBook
	  this.addressBook.byLink(this.link, err => {
	    if (this._destroyed) return
	    if (!err) {
	      this._ready = true
	      return this.emit('ready')
	    }
	
	    this.addContact(this.identity, err => {
	      if (this._destroyed) return
	      if (err) return this.emit('error', err)
	
	      this._ready = true
	      this.emit('ready')
	    })
	  })
	
	  const emitters = [
	    this.keeper, this.addressBook, this.objects, this.seals, this.watches,
	    this.sealwatch, this.sealer, this.sender
	  ]
	
	  emitters.forEach(emitter => {
	    if (emitter && emitter.on) {
	      emitter.on('error', err => {
	        if (!this._destroyed) this.emit('error', err)
	        else this._debug(`ignoring error emitted after node was destroyed: ${err.stack}`)
	      })
	    }
	  })
	}
	
	/**
	 * Log with a prefix
	 * @private
	 */
	Tradle.prototype._debug = function () {
	  utils.subdebug(debug, this.name || this.shortlink, arguments)
	}
	
	Tradle.prototype._createDB = function (name) {
	  const dir = name[0] === '/' ? name : path.join(this.dir, name)
	  return utils.levelup(dir, this._levelOpts)
	}
	
	Tradle.prototype.customIndexes = function (opts) {
	  return createDB.simpleCustom({
	    changes: this.changes,
	    keeper: this.keeper,
	    db: this._createDB(opts.db),
	    preprocess: opts.preprocess,
	    props: opts.props,
	    getProps: opts.getProps
	  })
	}
	
	/**
	 * Check if our identity has a blockchain seal
	 * @memberOf class:node
	 * @param  {Function} cb
	 */
	Tradle.prototype.identitySealStatus = function (cb) {
	  this.objectSealStatus(this.identityInfo, cb)
	}
	
	/**
	 * Check if an object has a blockchain seal
	 * @param  {Object}   opts [object/identifier]{@link types#someObjectInfo}
	 * @param  {Function} cb
	 */
	Tradle.prototype.objectSealStatus = function (opts, cb) {
	  const self = this
	  typeforce(types.someObjectInfo, opts)
	
	  const links = utils.getLinks(opts)
	  const status = { permalink: false, prevLink: false, link: false, watches: {} }
	  const props = ['permalink', 'prevLink', 'link'].filter(prop => links[prop])
	  const checkSeals = props.map(prop => {
	    return function (done) {
	      self.seals.findOne('link', links[prop], function (err, seal) {
	        if (!err) status[prop] = seal
	        done()
	      })
	    }
	  })
	
	  const checkWatches = ['permalink', 'prevLink', 'link'].map(prop => {
	    return function (done) {
	      if (!links[prop]) return done()
	      self.watches.findOne('link', links[prop], function (err, watch) {
	        if (!err) status.watches[prop] = watch
	        done()
	      })
	    }
	  })
	
	  async.parallel(checkSeals.concat(checkWatches), err => {
	    if (err) return cb(err)
	
	    cb(null, status)
	  })
	}
	
	/**
	 * Overwrite this node's identity. If you want to version the identity, use updateIdentity
	 * @param {Object}   opts
	 * @param {Array}    opts.keys      keys controlled by this identity
	 * @param {Object}   opts.identity  [see identity]{@link types#identity}
	 * @param {Object}   [opts.link]    this identity's link
	 * @param {Function} cb
	 */
	Tradle.prototype.setIdentity = function (opts, cb) {
	  const self = this
	
	  typeforce({
	    keys: typeforce.Array,
	    identity: types.identity,
	    link: typeforce.maybe(typeforce.String)
	  }, opts)
	
	  cb = utils.asyncify(cb)
	//   if (!this.addressBook) return this._setIdentity(opts, cb)
	
	//   // add own identity to addressBook
	//   this.addContact(opts.identity, err => {
	//     if (err) return cb(err)
	
	//     this._setIdentity(opts, cb)
	//   })
	// }
	
	// Tradle.prototype._setIdentity = function (opts, cb) {
	  // const self = this
	
	  this.keys = opts.keys.map(k => utils.importKey(k))
	  this.identity = opts.identity
	  this.pubKeys = this.identity.pubkeys.map(key => {
	    if (key.type === 'ec') {
	      return utils.toECKeyObj(key)
	    } else {
	      return key
	    }
	  })
	
	  this.chainPubKey = utils.chainPubKey(this.identity)
	  this.sigKey = utils.sigKey(this.keys)
	  this.sigPubKey = utils.toECKeyObj(this.sigKey.toJSON())
	  this.identityVersioningKey = utils.identityVersioningKey(this.keys)
	  this.identityVersioningPubKey = utils.identityVersioningPubKey(this.identity)
	  this.link = opts.link || utils.hexLink(this.identity)
	  this.permalink = this.identity[PERMALINK] || this.link
	  this.shortlink = utils.shortlink(this.permalink)
	  this._authorOpts = {
	    sigPubKey: this.sigPubKey,
	    sign: function (data, cb) {
	      self.sigKey.sign(data, cb)
	    }
	  }
	
	  this._authorIdentityOpts = {
	    sigPubKey: this.identityVersioningPubKey,
	    sign: function (data, cb) {
	      self.identityVersioningKey.sign(data, cb)
	    }
	  }
	
	  this._recipientOpts = {
	    pubKey: this.sigPubKey,
	    permalink: this.permalink
	  }
	
	  this.identityInfo = utils.objectInfo({
	    // would be nice to store/cache this
	    object: this.identity
	  })
	
	  if (this.addressBook) this.addContact(this.identity, cb)
	  else cb()
	}
	
	/**
	 * Update this node's identity. Unlike setIdentity, this performs versioning
	 * against the current identity
	 * @param {Object}   opts
	 * @param {Array}    opts.keys      keys controlled by this identity
	 * @param {Object}   opts.identity  [see identity]{@link types#identity}
	 * @param {Function} cb
	 */
	Tradle.prototype.updateIdentity = function (opts, cb) {
	  const self = this
	
	  typeforce({
	    keys: typeforce.Array,
	    identity: types.identity
	  }, opts)
	
	  // utils.versionIdentity({
	  //   keys: this.keys,
	  //   identity: opts.identity,
	  //   prev: this.identity
	  // }, function (err, nextVersion) {
	  //   if (err) return cb(err)
	
	  //   self.setIdentity({
	  //     keys: opts.keys,
	  //     identity: nextVersion
	  //   }, cb)
	  // })
	
	  const author = this._authorIdentityOpts
	  const object = opts.identity
	  const link = deepEqual(object, this.identity) && this.link
	  object[PREVLINK] = this.link
	  object[PERMALINK] = this.permalink
	  delete object[SIG]
	  this.sign({ object, author }, function (err, result) {
	    if (err) return cb(err)
	
	    const object = result.object
	    const link = protocol.linkString(object)
	    self.keeper.put(link, object, err => {
	      if (err) return cb(err)
	
	      self.setIdentity({
	        keys: opts.keys,
	        identity: object,
	        link: link
	      }, cb)
	    })
	  })
	}
	
	/**
	 * Sign an object
	 * @param  {Object}   opts
	 * @param  {Object}   opts.object   object to be signed
	 * @param  {Function} cb
	 */
	Tradle.prototype.sign = function sign (opts, cb) {
	  const author = opts.author || this._authorOpts
	  const object = utils.clone(opts.object)
	  delete object[SIG]
	
	  // const author = object[TYPE] === constants.TYPES.IDENTITY
	  //   ? this._authorIdentityOpts
	  //   : this._authorOpts
	
	  protocol.sign({ object, author }, cb)
	}
	
	/**
	 * Add an identity to this node's addressBook
	 * @param {Object}  identity          [identity object]{@link types#identity}
	 * @param {Boolean} [overwrite=false] overwite existing mappings if such exist
	 * @param {Function} cb
	 */
	Tradle.prototype.addContactIdentity =
	Tradle.prototype.addContact = function addContact (identity, overwrite, cb) {
	  const self = this
	
	  typeforce(types.identity, identity)
	  if (typeof overwrite === 'function') {
	    cb = overwrite
	    overwrite = false
	  }
	
	  cb = cb || noop
	
	  // if (deepEqual(identity, this.identity)) return cb()
	
	  let objInfo = utils.addLinks({ object: identity })
	  const indexes = identity.pubkeys.map(key => {
	    return { pubKey: key.pub }
	  })
	  .concat(identity.pubkeys.map(key => {
	    return { fingerprint: key.fingerprint }
	  }))
	
	  let havePrevious
	  let haveCurrent
	  let haveCollision
	  async.each(indexes, function (indexVal, done) {
	    self.addressBook.lookupIdentity(indexVal, function (err, match) {
	      if (!match) return done()
	
	      if (identity[PREVLINK] === match.link) {
	        havePrevious = true
	      } else {
	        if (deepEqual(match.object, identity)) {
	          haveCurrent = true
	        } else {
	          haveCollision = true
	        }
	      }
	
	      done()
	    })
	  }, err => {
	    if (err) return cb(err)
	    if (haveCollision && !overwrite) return cb(new Error('collision'))
	    if (haveCurrent) return cb()
	
	    // store contact
	    self.keeper.put(objInfo.link, identity, err => {
	      if (err) return cb(err)
	
	      const tasks = havePrevious
	        ? [saveObject, createAction]
	        // if we don't have a previous version of the identity
	        // we can't validate the authorship, so save to addressBook first
	        : [createAction, saveObject]
	
	      async.series(tasks, err => {
	        if (err) return self.keeper.del(objInfo.link, cb)
	
	        cb()
	      })
	    })
	  })
	
	  function createAction (done) {
	    self.actions.addContact(identity, objInfo.link, done)
	  }
	
	  function saveObject (done) {
	    self.saveObject({
	      object: identity,
	      author: objInfo.permalink,
	      // if we don't have the previous version, we can't validate
	      skipValidation: !havePrevious
	    }, done)
	  }
	}
	
	/**
	 * Save an object. Triggers Action: createObject
	 * (currently not underscore-prefixed, but this method may disappear from the public API)
	 *
	 * @private
	 * @param {Object} wrapper
	 * @param {Object} wrapper.object   signed object
	 * @param {string} wrapper.author   object author
	 */
	Tradle.prototype.saveObject = function saveObject (wrapper, cb) {
	  const self = this
	
	  typeforce({
	    object: types.signedObject,
	    author: typeforce.maybe(typeforce.String)
	  }, wrapper)
	
	  utils.addLinks(wrapper)
	  if (wrapper.permalink !== this.permalink) {
	    // allow saving our own identity
	    if (!this._ready) {
	      return this.once('ready', () => this.saveObject(wrapper, cb))
	    }
	  }
	
	  const object = wrapper.object
	  const link = wrapper.link
	
	  if (this._saving[link]) {
	    return process.nextTick(() => cb()) //new errors.AlreadySaving(wrapper))
	  }
	
	  this._saving[link] = true
	
	  this._debug(`${symbols.save} 1. check existence of [${object[TYPE]}] ${link}`)
	
	  // check if we already have it
	  this.objects.exists(link, function (exists) {
	    if (exists) return finish(new errors.ObjectExists({ link }))
	    // if (exists) return finish()
	
	    async.series([
	      validate,
	      augment,
	      createAction
	    ], finish)
	  })
	
	  function validate (done) {
	    if (wrapper.skipValidation) return done()
	
	    self.validator.validate(wrapper, done)
	  }
	
	  function finish (err) {
	    delete self._saving[link]
	    self._debug(`${symbols.save} queued ${link}`, err || '')
	    if (err) {
	      cb(err)
	    } else {
	      cb(null, utils.pick(wrapper, 'object', 'author', 'recipient', 'link', 'permalink'))
	    }
	  }
	
	  function checkPrev (done) {
	    if (!object[PREVLINK]) return done()
	
	    self.keeper.get(object[PREVLINK], function (err, prev) {
	      if (err) return done(err)
	
	      try {
	        protocol.validateVersioning({
	          object, prev, orig: object[PERMALINK]
	        })
	      } catch (err) {
	        return done(err)
	      }
	
	      // if (prev[PERMALINK] && prev[PERMALINK] !== object[PERMALINK]) {
	      //   return done(new errors.InvalidVersion({
	      //     error: `prev version has a different ${PERMALINK}`
	      //   }))
	      // }
	
	      done()
	    })
	  }
	
	  function augment (done) {
	    async.parallel([
	      save,
	      checkSealed,
	      // checkPartial
	    ], done)
	  }
	
	  function save (done) {
	    self._debug(`${symbols.save} 2a. store ${link}`)
	    self.keeper.put(link, object, done)
	  }
	
	  function checkSealed (done) {
	    self._debug(`${symbols.save} 2a. load seal status for ${link}`)
	    self.seals.findOne('link', link, function (err, seal) {
	      if (err) return done()
	
	      wrapper.sealstatus = SealStatus.sealed
	      wrapper.txId = seal.txId
	      wrapper.confirmations = seal.confirmations
	      wrapper.basePubKey = seal.basePubKey
	      done()
	    })
	  }
	
	  function createAction (done) {
	    self._debug(`${symbols.save} 3. create action "createObject" ${link}`)
	    wrapper.author = wrapper.author.permalink || wrapper.author
	    self.actions.createObject(wrapper, done)
	  }
	}
	
	/**
	 * Signs and saves an object
	 * @param  {Object}   opts
	 * @param  {Object}   opts.object  [unsigned object]{@link types#rawObject}
	 * @param  {Function} cb   [description]
	 */
	Tradle.prototype.createObject = function createObject (opts, cb) {
	  const self = this
	  typeforce({
	    object: types.rawObject
	  }, opts)
	
	  this.sign(opts, function (err, result) {
	    if (err) return cb(err)
	
	    opts.author = self.permalink
	    opts.object = result.object
	    opts.skipValidation = true
	    self.saveObject(opts, cb)
	  })
	}
	
	/**
	 * Sign an object and send it
	 * @param  {Object}   opts see sign and send methods
	 * @param  {Function} cb
	 */
	Tradle.prototype.signAndSend = function (opts, cb) {
	  const self = this
	  this._lock(opts.to, unlock => {
	    this.sign(opts, (err, result) => {
	      if (err) {
	        unlock()
	        return cb(err)
	      }
	
	      // make sure to do this on the same lock
	      opts.object = result.object
	      self._queueSend(opts, function () {
	        unlock()
	        cb.apply(self, arguments)
	      })
	    })
	  })
	}
	
	/**
	 * Send an object to another party
	 * @param  {Object}   opts
	 * @param  {Object}   opts.to         an identifier of another party
	 * @param  {Object}   [opts.object]   the object to send
	 * @param  {string}   [opts.link]     a link to the object to send
	 * @param  {Object}   [opts.other]    custom properties to include in the message
	 * @param  {Boolean}  [opts.seal]     if true, send the seal if it exists
	 * @param  {Function} cb   [description]
	 */
	Tradle.prototype.send = function send (opts, cb) {
	  const self = this
	
	  typeforce({
	    to: types.identifier,
	    object: typeforce.maybe(types.signedObject),
	    link: typeforce.maybe(typeforce.String),
	    other: typeforce.maybe(typeforce.Object),
	    seal: typeforce.maybe(typeforce.Boolean)
	  }, opts)
	
	  this._lock(opts.to, function (unlock) {
	    self._queueSend(opts, function () {
	      unlock()
	      cb.apply(self, arguments)
	    })
	  })
	}
	
	Tradle.prototype._queueSend = function _queueSend (opts, cb) {
	  const self = this
	  let recipientPubKey = opts.to.pubKey
	  let recipientPermalink = opts.to.permalink
	  let object = opts.object
	  let oLink = opts.link
	  if (!(object || oLink)) throw new Error('expected "object" or "link"')
	
	  oLink = oLink || utils.hexLink(object)
	  let wrapper
	  let step = 0
	
	  this._onready(function () {
	    // auto-sequence
	    async.auto({
	      getBody: getBody,
	      lookupRecipient: lookupRecipient,
	      maybeGetSeal: maybeGetSeal,
	      maybeSaveObject: ['getBody', maybeSaveObject],
	      getNextID: ['lookupRecipient', getNextID],
	      createMessage: ['maybeSaveObject', 'getNextID', 'maybeGetSeal', createMessage],
	      saveMessage: ['createMessage', saveMessage]
	    }, function (err) {
	      if (err) return cb(err)
	
	      cb(null, {
	        message: wrapper,
	        object: {
	          link: oLink,
	          permalink: object[PERMALINK] || oLink,
	          object: object
	        }
	      })
	    })
	  })
	
	  function getBody (done) {
	    self._debug(`${symbols.send} ${++step}. get body`)
	    if (object) return done(null, object)
	
	    self.keeper.get(oLink, done)
	  }
	
	  function lookupRecipient (done) {
	    self._debug(`${symbols.send} ${++step}. lookup recipient`)
	    self.addressBook.lookupIdentity(opts.to, done)
	  }
	
	  function maybeGetSeal (done) {
	    if (!opts.seal) return done()
	
	    self.seals.findOne('link', oLink, function (err, seal) {
	      if (!err && seal.txId) {
	        done(null, {
	          network: self.networkName,
	          basePubKey: seal.basePubKey.pub,
	          link: oLink
	        })
	      } else {
	        done()
	      }
	    })
	  }
	
	  function maybeSaveObject (results, done) {
	    self._debug(`${symbols.send} ${++step}. maybe create object`)
	    // already saved, we just looked it up by opts.link
	    object = results.getBody
	    if (!opts.object) return done()
	
	    const author = self.permalink
	    self.saveObject({ object, author, skipValidation: true }, function (err) {
	      if (err && err.type === errors.ObjectExists.type) err = null
	
	      done(err)
	    })
	  }
	
	  // get next `seq` and link to prev message
	  function getNextID (results, done) {
	    self._debug(`${++step}. get next message id`)
	    const identityInfo = results.lookupRecipient
	    utils.addLinks(identityInfo)
	    if (!recipientPubKey) {
	      recipientPubKey = utils.claimedSigPubKey(identityInfo.object)
	      if (!recipientPubKey) {
	        return done(new Error('recipient pubKey not found'))
	      }
	    }
	
	    if (!recipientPermalink) recipientPermalink = identityInfo.permalink
	    self.objects.nextMessageMetadata({ with: recipientPermalink }, done)
	  }
	
	  function createMessage (results, done) {
	    const meta = results.getNextID
	    self._debug(`${symbols.send} ${++step}. create message`)
	    // const author = self._authorOpts
	    const required = { [TYPE]: MESSAGE_TYPE, object, recipientPubKey }
	    const msg = utils.clone(opts.other || {}, meta, required)
	    const seal = results.maybeGetSeal
	    if (seal) msg.seal = seal
	
	    self.sign({ object: msg }, done)
	  }
	
	    // don't need the below, as messages are sequenced per recipient
	    //
	    // function checkExists (result, done) {
	    //   // messages can't have duplicates
	    //   self._debug(`${symbols.send} 5. check if duplicate`)
	    //   const link = protocol.linkString(result.object)
	    //   self.objects.exists(link, function (exists) {
	    //     if (exists) return done(new errors.MessageExists({ link }))
	
	    //     done(null, result)
	    //   })
	    // },
	
	  function saveMessage (results, done) {
	    const msg = results.createMessage
	    self._debug(`${symbols.send} ${++step}. save object`)
	    wrapper = {
	      object: msg.object,
	      author: self.permalink,
	      recipient: recipientPermalink,
	      skipValidation: true
	    }
	
	    self.saveObject(wrapper, done)
	  }
	}
	
	/**
	 * Get 1:1 a conversation history stream. Delegate
	 * @param  {Object} opts see [objects.conversation]{@link objects#conversation}
	 */
	Tradle.prototype.conversation = function (opts) {
	  return this.objects.conversation(opts)
	}
	
	/**
	 * Archive messages with a particular party
	 * @param  {string}   permalink other party's permalink
	 * @param  {Function} cb        [description]
	 */
	Tradle.prototype.forget = function forget (permalink, cb) {
	  const self = this
	
	  this._debug('forgetting correspondence with ' + permalink)
	
	  // let count = 0
	  const stream = this.conversation({
	    with: permalink,
	    body: false
	  })
	  .pipe(map(function (data, done) {
	    // count++
	    self.actions.forgetObject(data.link, err => {
	      if (err) return done(err)
	
	      done(null, data)
	    })
	  }))
	
	  collect(stream, function (err, objects) {
	    if (err) return cb(err)
	
	    self._debug(`forgot ${objects.length} messages`)
	    cb(null, objects)
	  })
	}
	
	/**
	 * Proxy a method call to submodules implementing a particular interface
	 * @private
	 * @param  {string} method
	 */
	Tradle.prototype._exec = function _exec (method) {
	  this._debug(method)
	  if (this.sealer) this.sealer[method]()
	  this.sealwatch[method]()
	  this.sender[method]()
	}
	
	/**
	 * Pause all activity: sending, sealing, syncing
	 * @param  {Object} [opts]
	 * @param  {Number} [opts.timeout] auto-unpause after a timeout
	 */
	Tradle.prototype.pause = function (opts) {
	  if (this._paused) return
	
	  opts = opts || {}
	  if (!this._ready) return this.once('ready', () => this.pause(opts))
	
	  this._paused = true
	  this._exec('pause')
	  if (opts.timeout) {
	    utils.timeout(this.resume, opts.timeout, true)
	  }
	}
	
	/**
	 * Resume activities: sending, sealing, syncing
	 */
	Tradle.prototype.resume = function () {
	  if (!this._paused) return
	
	  if (!this._ready) return this.once('ready', this.resume)
	
	  this._paused = false
	  this._exec('resume')
	}
	
	/**
	 * Process an incoming message
	 * @param  {Buffer|Object}   msg  serialized/unserialized message
	 * @param  {Object}   from   [node identifier]{@link types#identifier}
	 * @param  {Function} cb
	 */
	Tradle.prototype.receive = function receive (msg, from, cb) {
	  const self = this
	
	  typeforce(types.identifier, from)
	  cb = utils.asyncify(cb)
	
	  try {
	    if (Buffer.isBuffer(msg)) {
	      msg = utils.unserializeMessage(msg)
	    }
	  } catch (err) {
	    return cb(err)
	  }
	
	  if (msg[PERMALINK] || msg[PREVLINK]) {
	    return cb(new Error('messages cannot be versioned'))
	  }
	
	  // if (!utils.hasPubKey(this.identity, msg.recipientPubKey)) {
	  //   return cb(new Error('recipientPubKey in message is not in this node\'s identity'))
	  // }
	
	  if (!this._ready) {
	    return this.once('ready', () => this.receive(msg, from, cb))
	  }
	
	  this._lock(from, function (unlock) {
	    self._receive(msg, from, function () {
	      unlock()
	      cb.apply(self, arguments)
	    })
	  })
	}
	
	Tradle.prototype._receive = function _receive (msg, from, cb) {
	  const self = this
	  const object = msg.object
	  const seal = msg.seal
	  const addressBook = this.addressBook
	  const objects = this.objects
	  let sender, msgID, mLink, oLink, sLink
	
	  const wrappers = {
	    object: { object },
	    message: {
	      object: msg,
	      // needs to be verified
	      author: from
	    }
	  };
	
	  // for objects: msg & msg.object
	  //   save objects to keeper
	  //   check if we know the object's author
	  //   check each object follows the rules
	  //   log both objects (object, then message)
	
	  const validator = this.validator
	  this._debug('receive 1. validate message & embedded object')
	  async.each(wrappers, function validate (wrapper, done) {
	    // why series?
	    async.series([
	      taskCB => {
	        // msgs must be unique
	        const unique = wrapper === wrappers.message
	        validator.validate(wrapper, { unique }, taskCB)
	      }
	    ], done)
	  }, function (err) {
	    if (err) return cb(err)
	
	    self._debug('receive 2. store')
	    wrappers.message.objectinfo = {
	      author: wrappers.object.author.permalink,
	      link: wrappers.object.link,
	      permalink: wrappers.object.permalink,
	    }
	
	    wrappers.message.partialinfo = wrappers.object.partialinfo
	    utils.saveToKeeper(self.keeper, utils.values(wrappers), function (err) {
	      if (err) return cb(err)
	
	      async.each(wrappers, function log (wrapper, done) {
	        const slim = utils.clone(wrapper)
	        slim.author = slim.author.permalink
	        slim.recipient = wrapper.recipient ? wrapper.recipient.permalink : self.permalink
	        slim.received = true
	        self.actions.createObject(slim, done)
	      }, err => {
	        if (err) return cb(err)
	        if (seal) {
	          self.watchSeal({
	            link: seal.link,
	            basePubKey: utils.getSealPubKey(seal)
	          })
	        }
	
	        cb(null, wrappers)
	      })
	    })
	  })
	}
	
	/**
	 * Create a blockchain seal for an object
	 * @param  {Object}   opts
	 * @param  {Object}   [opts.object]                      the object to send
	 * @param  {string}   [opts.link]                        a link to the object to send
	 * @param  {Object}   [opts.basePubKey=this.chainPubKey] [sealer's blockchain pubKey]{@link types#chainPubKey}
	 * @param  {Number}   [opts.amount]                      amount to spend on the transaction
	 * @param  {Function} cb   [description]
	 */
	Tradle.prototype.seal = function seal (opts, cb) {
	  const self = this
	
	  typeforce({
	    object: typeforce.maybe(types.signedObject),
	    link: typeforce.maybe(typeforce.String),
	    basePubKey: typeforce.maybe(types.chainPubKey),
	    amount: typeforce.maybe(typeforce.Number)
	  }, opts)
	
	  if (!(opts.object || opts.link)) {
	    throw new Error('expected "object" or "link"')
	  }
	
	  const object = opts.object
	  const link = opts.link || utils.hexLink(object)
	  const basePubKey = opts.basePubKey || this.chainPubKey
	  const sealPubKey = protocol.sealPubKey({
	    link: utils.linkToBuf(link),
	    basePubKey: basePubKey
	  })
	
	  const sealAddress = utils.pubKeyToAddress(sealPubKey, this.networkName)
	  // const uid = utils.sealUID({ link, sealPubKey })
	  this.seals.findOne('sealAddress', sealAddress, function (err, seal) {
	    if (err && !err.notFound) return cb(err)
	    if (seal) return cb(new errors.SealExists(seal))
	
	    // make sure we have this object
	    // if not, require createObject to be called first
	    self.keeper.get(link, function (err, object) {
	      if (err) return cb(err)
	
	      let sealPrevPubKey, sealPrevAddress
	      if (object[PREVLINK]) {
	        sealPrevPubKey = protocol.sealPrevPubKey({
	          basePubKey: basePubKey,
	          prevLink: utils.linkToBuf(object[PREVLINK])
	        })
	
	        sealPrevAddress = utils.pubKeyToAddress(sealPrevPubKey, self.networkName)
	      }
	      // const sealPrevAddress = sealPrevPubKey &&
	      //   utils.sealPrevAddress(basePubKey, link, self.networkName)
	
	      const sealProps = {
	        link,
	        prevLink: object[PREVLINK],
	        basePubKey,
	        sealAddress,
	        sealPrevAddress,
	        sealPubKey,
	        sealPrevPubKey,
	        amount: opts.amount,
	        networkName: self.networkName
	      }
	
	      self.actions.writeSeal(sealProps, err => {
	        if (err) return cb(err)
	
	        cb(null, sealProps)
	      })
	
	      self.watchSeal({ link, basePubKey })
	    })
	  })
	}
	
	/**
	 * Monitor the blockchain for a seal announcing a new version of the object with link `link`
	 * @param  {Object}   opts
	 * @param  {string}   opts.link   link to the object to monitor
	 * @param  {Object}   opts.basePubKey [sealer's blockchain pubKey]{@link types#chainPubKey}
	 * @param  {Function} cb
	 */
	Tradle.prototype.watchNextVersion = function (opts, cb) {
	  typeforce({
	    link: typeforce.String,
	    basePubKey: types.chainPubKey
	  }, opts)
	
	  this._watch({
	    // the next version's previous is the current version
	    // the tx for next version will have a predictable seal based on the current version's link
	    address: utils.sealPrevAddress(opts.basePubKey, opts.link, this.networkName),
	    basePubKey: opts.basePubKey,
	    link: opts.link,
	    watchType: constants.watchType.nextVersion
	  }, cb)
	}
	
	/**
	 * Monitor the blockchain for a seal for the object with link `link`
	 *
	 * @param  {Object}   opts
	 * @param  {string}   opts.link   link to the object to monitor
	 * @param  {Object}   opts.basePubKey [sealer's blockchain pubKey]{@link types#chainPubKey}
	 * @param  {Function} cb
	 */
	Tradle.prototype.watchSeal = function (opts, cb) {
	  typeforce({
	    link: typeforce.String,
	    basePubKey: types.chainPubKey
	  }, opts)
	
	  this._watch({
	    address: utils.sealAddress(opts.basePubKey, opts.link, this.networkName),
	    basePubKey: opts.basePubKey,
	    link: opts.link,
	    watchType: constants.watchType.thisVersion
	  }, cb)
	}
	
	/**
	 * watch an address for a seal for an object's current or next version
	 * @private
	 * @param  {Object}   opts
	 * @param  {string}   opts.link       link to the object to monitor
	 * @param  {Object}   opts.basePubKey [sealer's blockchain pubKey]{@link types#chainPubKey}
	 * @param  {string}   opts.watchType  [watch type]{@link constants#watchType}
	 * @param  {string}   [opts.address]  address at which to expect seal
	 * @param  {Function} cb
	 */
	Tradle.prototype._watch = function (opts, cb) {
	  const self = this
	
	  typeforce({
	    link: typeforce.String,
	    basePubKey: types.chainPubKey,
	    watchType: typeforce.String,
	    address: typeforce.maybe(typeforce.String)
	  }, opts, true)
	
	  async.parallel([
	    function checkExistingWatch (done) {
	      self.watches.get(opts, function (err, watch) {
	        done(watch && new errors.WatchExists(watch))
	      })
	    },
	    function checkExistingSeal (done) {
	      const type = opts.watchType
	      const prop = type === constants.watchType.thisVersion ? 'sealAddress' : 'sealPrevAddress'
	      self.seals.find(prop, opts[prop], function (err, seals) {
	        if (!err) {
	          const sealed = utils.find(seals, seal => seal.status === SealStatus.sealed)
	          if (sealed) {
	            return done(new errors.SealExists({ uid: sealed.uid }))
	          }
	        }
	
	        done()
	
	        // if (seal && seal.status) {
	        //   return done(new errors.SealExists({ uid }))
	        // }
	
	        // done()
	      })
	    }
	  ], function (err) {
	    if (err) return cb(err)
	
	    self.actions.createWatch(opts, cb)
	  })
	}
	
	/**
	 * Override this method to provide delivery of messages
	 * @param  {Buffer}   msg
	 * @param  {Object}   [recipientInfo]{@link types.identityInfo}
	 * @param  {Function} cb
	 */
	Tradle.prototype._send = function _send (msg, recipientInfo, cb) {
	  throw new Error('implement this method yourself')
	}
	
	/**
	 * Execute a function after initialization is complete
	 * @private
	 * @param  {Function} fn
	 */
	Tradle.prototype._onready = function (fn) {
	  if (this._ready) return fn()
	
	  this.once('ready', fn)
	}
	
	/**
	 * Terminate all internal activity and close database handles
	 * @param  {Function} cb
	 */
	Tradle.prototype.destroy = function destroy (cb) {
	  cb = cb || noop
	  if (this._destroyed) throw new Error('already destroying or destroyed')
	  if (!this._ready) return this.once('ready', () => this.destroy())
	
	  this.emit('destroying')
	  this._destroyed = true
	  this._debug('self-destructing')
	  this._exec('stop')
	  const dbs = Object.keys(this.dbs).map(k => this.dbs[k])
	    .concat(this._logDB)
	    .concat(this.keeper)
	
	  async.each(dbs, function iterator (db, done) {
	    db.close(done)
	  }, err => {
	    if (err) return cb(err)
	
	    cb()
	    this.emit('destroy')
	  })
	}
	
	/**
	 * Trigger a sync with the blockchain
	 * @param  {Function} cb
	 */
	Tradle.prototype.sync = function (cb) {
	  this.sealwatch.sync(cb)
	}
	
	Tradle.prototype._lock = function (id, cb) {
	  const self = this
	  if (typeof id === 'object') {
	    id = getLockId(id)
	  }
	
	  typeforce(typeforce.String, id)
	  if (!this._locks[id]) this._locks[id] = mutexify()
	
	  this._locks[id](function (release) {
	    // unlock after timeout
	    const timeout = setTimeout(function () {
	      self._debug('unlock timed out, releasing')
	      release()
	    }, self.lockTimeout)
	
	    cb(function unlock () {
	      clearTimeout(timeout)
	      release.apply(this, arguments)
	    })
	  })
	}
	
	function getLockId (identifier) {
	  const id = identifier.permalink || identifier.link || identifier.fingerprint
	  if (id) return id
	
	  if (identifier.pubKey) {
	    return identifier.pubKey.pub.toString('hex')
	  }
	
	  throw new Error('invalid lock id')
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(294), __webpack_require__(820).Buffer))

/***/ },

/***/ 1412:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, process) {var EventEmitter = __webpack_require__(786).EventEmitter
	var lexint = __webpack_require__(1400)
	var collect = __webpack_require__(1051)
	var through = __webpack_require__(1413)
	var from = __webpack_require__(1419)
	var pump = __webpack_require__(1208)
	var thunky = __webpack_require__(1212)
	
	var noop = function() {}
	
	module.exports = function(db) {
	  var feed = {}
	  var valueEncoding = db.options.valueEncoding || 'binary'
	
	  var ensureCount = thunky(function(cb) {
	    if (feed.change) return cb()
	    collect(db.createKeyStream({reverse:true, limit:1}), function(err, keys) {
	      if (err) return cb(err)
	      if (!keys.length) return cb()
	      feed.change = lexint.unpack(keys[0], 'hex')
	      cb()
	    })
	  })
	
	  feed.change = 0
	  feed.queued = 0
	  feed.notify = []
	  feed.batch = []
	
	  feed.count = function(cb) {
	    ensureCount(function (err) {
	      if (err) return cb(err)
	      cb(null, feed.change)
	    });
	  }
	
	  feed.append = function(value, cb) {
	    feed.queued++
	    if (!cb) cb = noop
	    if (valueEncoding === 'binary' && !Buffer.isBuffer(value)) {
	      value = new Buffer(value)
	    }
	
	    ensureCount(function(err) {
	      if (err) return release(cb, err)
	
	      var batch = feed.batch
	      var change = ++feed.change
	      batch.push({
	        change: change,
	        key: lexint.pack(change, 'hex'),
	        value: value,
	        callback: cb
	      })
	
	      if (batch.length !== 1) return
	
	      // schedule batch commit
	      process.nextTick(function () {
	        batch = batch.slice()
	        feed.batch.length = 0
	
	        db.batch(batch.map(function (item) {
	          return {
	            type: 'put',
	            key: item.key,
	            value: item.value
	          }
	        }), function(err) {
	          var notify = feed.notify
	
	          if (notify.length) {
	            feed.notify = []
	            for (var i = 0; i < notify.length; i++) notify[i][0](1, notify[i][1])
	          }
	
	          batch.forEach(function (item, i) {
	            item.callback(err, { change: batch[i].change, value: value })
	          })
	
	          feed.queued = 0
	        })
	      })
	    })
	  }
	
	  feed.createReadStream = function (opts) {
	    if (typeof opts === 'function') return feed.createReadStream(null, opts)
	    if (!opts) opts = {}
	
	    var since = opts.since || 0
	    var keys = opts.keys !== false
	    var values = opts.values !== false
	    var retOpts = {
	      keys: keys,
	      values: values
	    }
	
	    if (opts.live) {
	      var ls = from.obj(function read(size, cb) {
	        feed.get(since + 1, function(err, value) {
	          if (err && err.notFound) return feed.notify.push([read, cb])
	          if (err) return cb(err)
	          cb(null, toResult(++since, value, retOpts))
	        })
	      })
	
	      db.once('closing', destroy)
	      ls.once('close', function () {
	        db.removeListener('closing', destroy)
	      })
	
	      return ls
	
	      function destroy () {
	        ls.destroy()
	      }
	    }
	
	    var rs = db.createReadStream({
	      gt: lexint.pack(since, 'hex'),
	      limit: opts.limit,
	      keys: keys,
	      values: values,
	      reverse: opts.reverse,
	      valueEncoding: valueEncoding
	    })
	
	    var format = function(data, enc, cb) {
	      var key = keys && lexint.unpack(values ? data.key : data, 'hex')
	      var val = values && keys ? data.value : data
	
	      cb(null, toResult(key, val, retOpts))
	    }
	
	    return pump(rs, through.obj(format))
	  }
	
	  feed.get = function (id, opts, cb) {
	    if (typeof opts === 'function') {
	      cb = opts
	      opts = {}
	    }
	
	    opts.valueEncoding = valueEncoding
	    return db.get(lexint.pack(id, 'hex'), opts, cb)
	  }
	
	  function toResult (key, val, opts) {
	    return !opts.keys ? val :
	      !opts.values ? key :
	      { change: key, value: val }
	  }
	
	  return feed
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(820).Buffer, __webpack_require__(294)))

/***/ },

/***/ 1413:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var Transform = __webpack_require__(1414)
	  , inherits  = __webpack_require__(1130).inherits
	  , xtend     = __webpack_require__(859)
	
	function DestroyableTransform(opts) {
	  Transform.call(this, opts)
	  this._destroyed = false
	}
	
	inherits(DestroyableTransform, Transform)
	
	DestroyableTransform.prototype.destroy = function(err) {
	  if (this._destroyed) return
	  this._destroyed = true
	  
	  var self = this
	  process.nextTick(function() {
	    if (err)
	      self.emit('error', err)
	    self.emit('close')
	  })
	}
	
	// a noop _transform function
	function noop (chunk, enc, callback) {
	  callback(null, chunk)
	}
	
	
	// create a new export function, used by both the main export and
	// the .ctor export, contains common logic for dealing with arguments
	function through2 (construct) {
	  return function (options, transform, flush) {
	    if (typeof options == 'function') {
	      flush     = transform
	      transform = options
	      options   = {}
	    }
	
	    if (typeof transform != 'function')
	      transform = noop
	
	    if (typeof flush != 'function')
	      flush = null
	
	    return construct(options, transform, flush)
	  }
	}
	
	
	// main export, just make me a transform stream!
	module.exports = through2(function (options, transform, flush) {
	  var t2 = new DestroyableTransform(options)
	
	  t2._transform = transform
	
	  if (flush)
	    t2._flush = flush
	
	  return t2
	})
	
	
	// make me a reusable prototype that I can `new`, or implicitly `new`
	// with a constructor call
	module.exports.ctor = through2(function (options, transform, flush) {
	  function Through2 (override) {
	    if (!(this instanceof Through2))
	      return new Through2(override)
	
	    this.options = xtend(options, override)
	
	    DestroyableTransform.call(this, this.options)
	  }
	
	  inherits(Through2, DestroyableTransform)
	
	  Through2.prototype._transform = transform
	
	  if (flush)
	    Through2.prototype._flush = flush
	
	  return Through2
	})
	
	
	module.exports.obj = through2(function (options, transform, flush) {
	  var t2 = new DestroyableTransform(xtend({ objectMode: true, highWaterMark: 16 }, options))
	
	  t2._transform = transform
	
	  if (flush)
	    t2._flush = flush
	
	  return t2
	})
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(294)))

/***/ },

/***/ 1414:
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1415)


/***/ },

/***/ 1415:
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	
	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.
	
	module.exports = Transform;
	
	var Duplex = __webpack_require__(1416);
	
	/*<replacement>*/
	var util = __webpack_require__(832);
	util.inherits = __webpack_require__(828);
	/*</replacement>*/
	
	util.inherits(Transform, Duplex);
	
	
	function TransformState(options, stream) {
	  this.afterTransform = function(er, data) {
	    return afterTransform(stream, er, data);
	  };
	
	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	}
	
	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;
	
	  var cb = ts.writecb;
	
	  if (!cb)
	    return stream.emit('error', new Error('no writecb in Transform class'));
	
	  ts.writechunk = null;
	  ts.writecb = null;
	
	  if (data !== null && data !== undefined)
	    stream.push(data);
	
	  if (cb)
	    cb(er);
	
	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}
	
	
	function Transform(options) {
	  if (!(this instanceof Transform))
	    return new Transform(options);
	
	  Duplex.call(this, options);
	
	  var ts = this._transformState = new TransformState(options, this);
	
	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;
	
	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;
	
	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;
	
	  this.once('finish', function() {
	    if ('function' === typeof this._flush)
	      this._flush(function(er) {
	        done(stream, er);
	      });
	    else
	      done(stream);
	  });
	}
	
	Transform.prototype.push = function(chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};
	
	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function(chunk, encoding, cb) {
	  throw new Error('not implemented');
	};
	
	Transform.prototype._write = function(chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform ||
	        rs.needReadable ||
	        rs.length < rs.highWaterMark)
	      this._read(rs.highWaterMark);
	  }
	};
	
	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function(n) {
	  var ts = this._transformState;
	
	  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};
	
	
	function done(stream, er) {
	  if (er)
	    return stream.emit('error', er);
	
	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var rs = stream._readableState;
	  var ts = stream._transformState;
	
	  if (ws.length)
	    throw new Error('calling transform done when ws.length != 0');
	
	  if (ts.transforming)
	    throw new Error('calling transform done when still transforming');
	
	  return stream.push(null);
	}


/***/ },

/***/ 1416:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.
	
	module.exports = Duplex;
	
	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	/*</replacement>*/
	
	
	/*<replacement>*/
	var util = __webpack_require__(832);
	util.inherits = __webpack_require__(828);
	/*</replacement>*/
	
	var Readable = __webpack_require__(1417);
	var Writable = __webpack_require__(1418);
	
	util.inherits(Duplex, Readable);
	
	forEach(objectKeys(Writable.prototype), function(method) {
	  if (!Duplex.prototype[method])
	    Duplex.prototype[method] = Writable.prototype[method];
	});
	
	function Duplex(options) {
	  if (!(this instanceof Duplex))
	    return new Duplex(options);
	
	  Readable.call(this, options);
	  Writable.call(this, options);
	
	  if (options && options.readable === false)
	    this.readable = false;
	
	  if (options && options.writable === false)
	    this.writable = false;
	
	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false)
	    this.allowHalfOpen = false;
	
	  this.once('end', onend);
	}
	
	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended)
	    return;
	
	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process.nextTick(this.end.bind(this));
	}
	
	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(294)))

/***/ },

/***/ 1417:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	module.exports = Readable;
	
	/*<replacement>*/
	var isArray = __webpack_require__(831);
	/*</replacement>*/
	
	
	/*<replacement>*/
	var Buffer = __webpack_require__(820).Buffer;
	/*</replacement>*/
	
	Readable.ReadableState = ReadableState;
	
	var EE = __webpack_require__(786).EventEmitter;
	
	/*<replacement>*/
	if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/
	
	var Stream = __webpack_require__(827);
	
	/*<replacement>*/
	var util = __webpack_require__(832);
	util.inherits = __webpack_require__(828);
	/*</replacement>*/
	
	var StringDecoder;
	
	util.inherits(Readable, Stream);
	
	function ReadableState(options, stream) {
	  options = options || {};
	
	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;
	
	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;
	
	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = false;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;
	
	  // In streams that never have any data, and do push(null) right away,
	  // the consumer can miss the 'end' event if they do some I/O before
	  // consuming the stream.  So, we don't emit('end') until some reading
	  // happens.
	  this.calledRead = false;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, becuase any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	
	
	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;
	
	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;
	
	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;
	
	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder)
	      StringDecoder = __webpack_require__(836).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}
	
	function Readable(options) {
	  if (!(this instanceof Readable))
	    return new Readable(options);
	
	  this._readableState = new ReadableState(options, this);
	
	  // legacy
	  this.readable = true;
	
	  Stream.call(this);
	}
	
	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function(chunk, encoding) {
	  var state = this._readableState;
	
	  if (typeof chunk === 'string' && !state.objectMode) {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }
	
	  return readableAddChunk(this, state, chunk, encoding, false);
	};
	
	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function(chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};
	
	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (chunk === null || chunk === undefined) {
	    state.reading = false;
	    if (!state.ended)
	      onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      if (state.decoder && !addToFront && !encoding)
	        chunk = state.decoder.write(chunk);
	
	      // update the buffer info.
	      state.length += state.objectMode ? 1 : chunk.length;
	      if (addToFront) {
	        state.buffer.unshift(chunk);
	      } else {
	        state.reading = false;
	        state.buffer.push(chunk);
	      }
	
	      if (state.needReadable)
	        emitReadable(stream);
	
	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }
	
	  return needMoreData(state);
	}
	
	
	
	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended &&
	         (state.needReadable ||
	          state.length < state.highWaterMark ||
	          state.length === 0);
	}
	
	// backwards compatibility.
	Readable.prototype.setEncoding = function(enc) {
	  if (!StringDecoder)
	    StringDecoder = __webpack_require__(836).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	};
	
	// Don't raise the hwm > 128MB
	var MAX_HWM = 0x800000;
	function roundUpToNextPowerOf2(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
	    n++;
	  }
	  return n;
	}
	
	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended)
	    return 0;
	
	  if (state.objectMode)
	    return n === 0 ? 0 : 1;
	
	  if (n === null || isNaN(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length)
	      return state.buffer[0].length;
	    else
	      return state.length;
	  }
	
	  if (n <= 0)
	    return 0;
	
	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark)
	    state.highWaterMark = roundUpToNextPowerOf2(n);
	
	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else
	      return state.length;
	  }
	
	  return n;
	}
	
	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function(n) {
	  var state = this._readableState;
	  state.calledRead = true;
	  var nOrig = n;
	  var ret;
	
	  if (typeof n !== 'number' || n > 0)
	    state.emittedReadable = false;
	
	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 &&
	      state.needReadable &&
	      (state.length >= state.highWaterMark || state.ended)) {
	    emitReadable(this);
	    return null;
	  }
	
	  n = howMuchToRead(n, state);
	
	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    ret = null;
	
	    // In cases where the decoder did not receive enough data
	    // to produce a full chunk, then immediately received an
	    // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].
	    // howMuchToRead will see this and coerce the amount to
	    // read to zero (because it's looking at the length of the
	    // first <Buffer > in state.buffer), and we'll end up here.
	    //
	    // This can only happen via state.decoder -- no other venue
	    // exists for pushing a zero-length chunk into state.buffer
	    // and triggering this behavior. In this case, we return our
	    // remaining data and end the stream, if appropriate.
	    if (state.length > 0 && state.decoder) {
	      ret = fromList(n, state);
	      state.length -= ret.length;
	    }
	
	    if (state.length === 0)
	      endReadable(this);
	
	    return ret;
	  }
	
	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.
	
	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	
	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length - n <= state.highWaterMark)
	    doRead = true;
	
	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading)
	    doRead = false;
	
	  if (doRead) {
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0)
	      state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }
	
	  // If _read called its callback synchronously, then `reading`
	  // will be false, and we need to re-evaluate how much data we
	  // can return to the user.
	  if (doRead && !state.reading)
	    n = howMuchToRead(nOrig, state);
	
	  if (n > 0)
	    ret = fromList(n, state);
	  else
	    ret = null;
	
	  if (ret === null) {
	    state.needReadable = true;
	    n = 0;
	  }
	
	  state.length -= n;
	
	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended)
	    state.needReadable = true;
	
	  // If we happened to read() exactly the remaining amount in the
	  // buffer, and the EOF has been seen at this point, then make sure
	  // that we emit 'end' on the very next tick.
	  if (state.ended && !state.endEmitted && state.length === 0)
	    endReadable(this);
	
	  return ret;
	};
	
	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!Buffer.isBuffer(chunk) &&
	      'string' !== typeof chunk &&
	      chunk !== null &&
	      chunk !== undefined &&
	      !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}
	
	
	function onEofChunk(stream, state) {
	  if (state.decoder && !state.ended) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;
	
	  // if we've ended and we have some data left, then emit
	  // 'readable' now to make sure it gets picked up.
	  if (state.length > 0)
	    emitReadable(stream);
	  else
	    endReadable(stream);
	}
	
	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (state.emittedReadable)
	    return;
	
	  state.emittedReadable = true;
	  if (state.sync)
	    process.nextTick(function() {
	      emitReadable_(stream);
	    });
	  else
	    emitReadable_(stream);
	}
	
	function emitReadable_(stream) {
	  stream.emit('readable');
	}
	
	
	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(function() {
	      maybeReadMore_(stream, state);
	    });
	  }
	}
	
	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended &&
	         state.length < state.highWaterMark) {
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	    else
	      len = state.length;
	  }
	  state.readingMore = false;
	}
	
	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function(n) {
	  this.emit('error', new Error('not implemented'));
	};
	
	Readable.prototype.pipe = function(dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;
	
	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	
	  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
	              dest !== process.stdout &&
	              dest !== process.stderr;
	
	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted)
	    process.nextTick(endFn);
	  else
	    src.once('end', endFn);
	
	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    if (readable !== src) return;
	    cleanup();
	  }
	
	  function onend() {
	    dest.end();
	  }
	
	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);
	
	  function cleanup() {
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	
	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (!dest._writableState || dest._writableState.needDrain)
	      ondrain();
	  }
	
	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EE.listenerCount(dest, 'error') === 0)
	      dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error)
	    dest.on('error', onerror);
	  else if (isArray(dest._events.error))
	    dest._events.error.unshift(onerror);
	  else
	    dest._events.error = [onerror, dest._events.error];
	
	
	
	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);
	
	  function unpipe() {
	    src.unpipe(dest);
	  }
	
	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);
	
	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    // the handler that waits for readable events after all
	    // the data gets sucked out in flow.
	    // This would be easier to follow with a .once() handler
	    // in flow(), but that is too slow.
	    this.on('readable', pipeOnReadable);
	
	    state.flowing = true;
	    process.nextTick(function() {
	      flow(src);
	    });
	  }
	
	  return dest;
	};
	
	function pipeOnDrain(src) {
	  return function() {
	    var dest = this;
	    var state = src._readableState;
	    state.awaitDrain--;
	    if (state.awaitDrain === 0)
	      flow(src);
	  };
	}
	
	function flow(src) {
	  var state = src._readableState;
	  var chunk;
	  state.awaitDrain = 0;
	
	  function write(dest, i, list) {
	    var written = dest.write(chunk);
	    if (false === written) {
	      state.awaitDrain++;
	    }
	  }
	
	  while (state.pipesCount && null !== (chunk = src.read())) {
	
	    if (state.pipesCount === 1)
	      write(state.pipes, 0, null);
	    else
	      forEach(state.pipes, write);
	
	    src.emit('data', chunk);
	
	    // if anyone needs a drain, then we have to wait for that.
	    if (state.awaitDrain > 0)
	      return;
	  }
	
	  // if every destination was unpiped, either before entering this
	  // function, or in the while loop, then stop flowing.
	  //
	  // NB: This is a pretty rare edge case.
	  if (state.pipesCount === 0) {
	    state.flowing = false;
	
	    // if there were data event listeners added, then switch to old mode.
	    if (EE.listenerCount(src, 'data') > 0)
	      emitDataEvents(src);
	    return;
	  }
	
	  // at this point, no one needed a drain, so we just ran out of data
	  // on the next readable event, start it over again.
	  state.ranOut = true;
	}
	
	function pipeOnReadable() {
	  if (this._readableState.ranOut) {
	    this._readableState.ranOut = false;
	    flow(this);
	  }
	}
	
	
	Readable.prototype.unpipe = function(dest) {
	  var state = this._readableState;
	
	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0)
	    return this;
	
	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes)
	      return this;
	
	    if (!dest)
	      dest = state.pipes;
	
	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    this.removeListener('readable', pipeOnReadable);
	    state.flowing = false;
	    if (dest)
	      dest.emit('unpipe', this);
	    return this;
	  }
	
	  // slow case. multiple pipe destinations.
	
	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    this.removeListener('readable', pipeOnReadable);
	    state.flowing = false;
	
	    for (var i = 0; i < len; i++)
	      dests[i].emit('unpipe', this);
	    return this;
	  }
	
	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1)
	    return this;
	
	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1)
	    state.pipes = state.pipes[0];
	
	  dest.emit('unpipe', this);
	
	  return this;
	};
	
	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function(ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);
	
	  if (ev === 'data' && !this._readableState.flowing)
	    emitDataEvents(this);
	
	  if (ev === 'readable' && this.readable) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        this.read(0);
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }
	
	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;
	
	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function() {
	  emitDataEvents(this);
	  this.read(0);
	  this.emit('resume');
	};
	
	Readable.prototype.pause = function() {
	  emitDataEvents(this, true);
	  this.emit('pause');
	};
	
	function emitDataEvents(stream, startPaused) {
	  var state = stream._readableState;
	
	  if (state.flowing) {
	    // https://github.com/isaacs/readable-stream/issues/16
	    throw new Error('Cannot switch to old mode now.');
	  }
	
	  var paused = startPaused || false;
	  var readable = false;
	
	  // convert to an old-style stream.
	  stream.readable = true;
	  stream.pipe = Stream.prototype.pipe;
	  stream.on = stream.addListener = Stream.prototype.on;
	
	  stream.on('readable', function() {
	    readable = true;
	
	    var c;
	    while (!paused && (null !== (c = stream.read())))
	      stream.emit('data', c);
	
	    if (c === null) {
	      readable = false;
	      stream._readableState.needReadable = true;
	    }
	  });
	
	  stream.pause = function() {
	    paused = true;
	    this.emit('pause');
	  };
	
	  stream.resume = function() {
	    paused = false;
	    if (readable)
	      process.nextTick(function() {
	        stream.emit('readable');
	      });
	    else
	      this.read(0);
	    this.emit('resume');
	  };
	
	  // now make it start, just in case it hadn't already.
	  stream.emit('readable');
	}
	
	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function(stream) {
	  var state = this._readableState;
	  var paused = false;
	
	  var self = this;
	  stream.on('end', function() {
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length)
	        self.push(chunk);
	    }
	
	    self.push(null);
	  });
	
	  stream.on('data', function(chunk) {
	    if (state.decoder)
	      chunk = state.decoder.write(chunk);
	
	    // don't skip over falsy values in objectMode
	    //if (state.objectMode && util.isNullOrUndefined(chunk))
	    if (state.objectMode && (chunk === null || chunk === undefined))
	      return;
	    else if (!state.objectMode && (!chunk || !chunk.length))
	      return;
	
	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });
	
	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (typeof stream[i] === 'function' &&
	        typeof this[i] === 'undefined') {
	      this[i] = function(method) { return function() {
	        return stream[method].apply(stream, arguments);
	      }}(i);
	    }
	  }
	
	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function(ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });
	
	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function(n) {
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };
	
	  return self;
	};
	
	
	
	// exposed for testing purposes only.
	Readable._fromList = fromList;
	
	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;
	
	  // nothing in the list, definitely empty.
	  if (list.length === 0)
	    return null;
	
	  if (length === 0)
	    ret = null;
	  else if (objectMode)
	    ret = list.shift();
	  else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode)
	      ret = list.join('');
	    else
	      ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode)
	        ret = '';
	      else
	        ret = new Buffer(n);
	
	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);
	
	        if (stringMode)
	          ret += buf.slice(0, cpy);
	        else
	          buf.copy(ret, c, 0, cpy);
	
	        if (cpy < buf.length)
	          list[0] = buf.slice(cpy);
	        else
	          list.shift();
	
	        c += cpy;
	      }
	    }
	  }
	
	  return ret;
	}
	
	function endReadable(stream) {
	  var state = stream._readableState;
	
	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0)
	    throw new Error('endReadable called on non-empty stream');
	
	  if (!state.endEmitted && state.calledRead) {
	    state.ended = true;
	    process.nextTick(function() {
	      // Check that we didn't get one last unshift.
	      if (!state.endEmitted && state.length === 0) {
	        state.endEmitted = true;
	        stream.readable = false;
	        stream.emit('end');
	      }
	    });
	  }
	}
	
	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}
	
	function indexOf (xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(294)))

/***/ },

/***/ 1418:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, cb), and it'll handle all
	// the drain event emission and buffering.
	
	module.exports = Writable;
	
	/*<replacement>*/
	var Buffer = __webpack_require__(820).Buffer;
	/*</replacement>*/
	
	Writable.WritableState = WritableState;
	
	
	/*<replacement>*/
	var util = __webpack_require__(832);
	util.inherits = __webpack_require__(828);
	/*</replacement>*/
	
	var Stream = __webpack_require__(827);
	
	util.inherits(Writable, Stream);
	
	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	}
	
	function WritableState(options, stream) {
	  options = options || {};
	
	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;
	
	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;
	
	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;
	
	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;
	
	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;
	
	  // a flag to see when we're in the middle of a write.
	  this.writing = false;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, becuase any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;
	
	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function(er) {
	    onwrite(stream, er);
	  };
	
	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;
	
	  // the amount that is being written when _write is called.
	  this.writelen = 0;
	
	  this.buffer = [];
	
	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	}
	
	function Writable(options) {
	  var Duplex = __webpack_require__(1416);
	
	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex))
	    return new Writable(options);
	
	  this._writableState = new WritableState(options, this);
	
	  // legacy.
	  this.writable = true;
	
	  Stream.call(this);
	}
	
	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function() {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};
	
	
	function writeAfterEnd(stream, state, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  process.nextTick(function() {
	    cb(er);
	  });
	}
	
	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  if (!Buffer.isBuffer(chunk) &&
	      'string' !== typeof chunk &&
	      chunk !== null &&
	      chunk !== undefined &&
	      !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    process.nextTick(function() {
	      cb(er);
	    });
	    valid = false;
	  }
	  return valid;
	}
	
	Writable.prototype.write = function(chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;
	
	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (Buffer.isBuffer(chunk))
	    encoding = 'buffer';
	  else if (!encoding)
	    encoding = state.defaultEncoding;
	
	  if (typeof cb !== 'function')
	    cb = function() {};
	
	  if (state.ended)
	    writeAfterEnd(this, state, cb);
	  else if (validChunk(this, state, chunk, cb))
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	
	  return ret;
	};
	
	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode &&
	      state.decodeStrings !== false &&
	      typeof chunk === 'string') {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}
	
	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	  if (Buffer.isBuffer(chunk))
	    encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;
	
	  state.length += len;
	
	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret)
	    state.needDrain = true;
	
	  if (state.writing)
	    state.buffer.push(new WriteReq(chunk, encoding, cb));
	  else
	    doWrite(stream, state, len, chunk, encoding, cb);
	
	  return ret;
	}
	
	function doWrite(stream, state, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}
	
	function onwriteError(stream, state, sync, er, cb) {
	  if (sync)
	    process.nextTick(function() {
	      cb(er);
	    });
	  else
	    cb(er);
	
	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}
	
	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}
	
	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;
	
	  onwriteStateUpdate(state);
	
	  if (er)
	    onwriteError(stream, state, sync, er, cb);
	  else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(stream, state);
	
	    if (!finished && !state.bufferProcessing && state.buffer.length)
	      clearBuffer(stream, state);
	
	    if (sync) {
	      process.nextTick(function() {
	        afterWrite(stream, state, finished, cb);
	      });
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}
	
	function afterWrite(stream, state, finished, cb) {
	  if (!finished)
	    onwriteDrain(stream, state);
	  cb();
	  if (finished)
	    finishMaybe(stream, state);
	}
	
	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}
	
	
	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	
	  for (var c = 0; c < state.buffer.length; c++) {
	    var entry = state.buffer[c];
	    var chunk = entry.chunk;
	    var encoding = entry.encoding;
	    var cb = entry.callback;
	    var len = state.objectMode ? 1 : chunk.length;
	
	    doWrite(stream, state, len, chunk, encoding, cb);
	
	    // if we didn't call the onwrite immediately, then
	    // it means that we need to wait until it does.
	    // also, that means that the chunk and cb are currently
	    // being processed, so move the buffer counter past them.
	    if (state.writing) {
	      c++;
	      break;
	    }
	  }
	
	  state.bufferProcessing = false;
	  if (c < state.buffer.length)
	    state.buffer = state.buffer.slice(c);
	  else
	    state.buffer.length = 0;
	}
	
	Writable.prototype._write = function(chunk, encoding, cb) {
	  cb(new Error('not implemented'));
	};
	
	Writable.prototype.end = function(chunk, encoding, cb) {
	  var state = this._writableState;
	
	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (typeof chunk !== 'undefined' && chunk !== null)
	    this.write(chunk, encoding);
	
	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished)
	    endWritable(this, state, cb);
	};
	
	
	function needFinish(stream, state) {
	  return (state.ending &&
	          state.length === 0 &&
	          !state.finished &&
	          !state.writing);
	}
	
	function finishMaybe(stream, state) {
	  var need = needFinish(stream, state);
	  if (need) {
	    state.finished = true;
	    stream.emit('finish');
	  }
	  return need;
	}
	
	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished)
	      process.nextTick(cb);
	    else
	      stream.once('finish', cb);
	  }
	  state.ended = true;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(294)))

/***/ },

/***/ 1419:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var Readable = __webpack_require__(829).Readable
	var inherits = __webpack_require__(828)
	
	module.exports = from2
	
	from2.ctor = ctor
	from2.obj = obj
	
	var Proto = ctor()
	
	function toFunction(list) {
	  list = list.slice()
	  return function (_, cb) {
	    cb(null, list.length ? list.shift() : null)
	  }
	}
	
	function from2(opts, read) {
	  if (typeof opts !== 'object' || Array.isArray(opts)) {
	    read = opts
	    opts = {}
	  }
	  
	  if (Array.isArray(read)) read = toFunction(read)
	
	  var rs = new Proto(opts)
	  rs._from = read
	  return rs
	}
	
	function ctor(opts, read) {
	  if (typeof opts === 'function') {
	    read = opts
	    opts = {}
	  }
	
	  opts = defaults(opts)
	
	  inherits(Class, Readable)
	  function Class(override) {
	    if (!(this instanceof Class)) return new Class(override)
	    this._reading = false
	    this.destroyed = false
	    Readable.call(this, override || opts)
	  }
	
	  Class.prototype._from = read
	  Class.prototype._read = function(size) {
	    var self = this
	
	    if (this._reading || this.destroyed) return
	    this._reading = true
	    this._from(size, check)
	    function check(err, data) {
	      if (self.destroyed) return
	      if (err) return self.destroy(err)
	      if (data === null) return self.push(null)
	      self._reading = false
	      if (self.push(data)) self._read()
	    }
	  }
	
	  Class.prototype.destroy = function(err) {
	    if (this.destroyed) return
	    this.destroyed = true
	
	    var self = this
	    process.nextTick(function() {
	      if (err) self.emit('error', err)
	      self.emit('close')
	    })
	  }
	
	  return Class
	}
	
	function obj(opts, read) {
	  if (typeof opts === 'function' || Array.isArray(opts)) {
	    read = opts
	    opts = {}
	  }
	
	  opts = defaults(opts)
	  opts.objectMode = true
	  opts.highWaterMark = 16
	
	  return from2(opts, read)
	}
	
	function defaults(opts) {
	  opts = opts || {}
	  return opts
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(294)))

/***/ },

/***/ 1420:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict'
	
	/** @module actions */
	
	const EventEmitter = __webpack_require__(786).EventEmitter
	const debug = __webpack_require__(787)('tradle:actions')
	const protocol = __webpack_require__(1150)
	const typeforce = __webpack_require__(1207)
	const statuses = __webpack_require__(1222)
	const SealStatus = statuses.seal
	const { TYPES, TYPE, SEQ } = __webpack_require__(1224)
	const { PARTIAL, MESSAGE } = TYPES
	const types = __webpack_require__(1223)
	const topics = __webpack_require__(1221)
	const utils = __webpack_require__(1225)
	const noop = function () {}
	
	/**
	 * @typedef {Object} Actions
	 */
	
	/**
	 * actions
	 * @alias module:actions
	 * @param {Object}  opts
	 * @param {changes} opts.changes
	 * @param {node}    [opts.node]
	 */
	module.exports = function (opts) {
	  typeforce({
	    changes: types.changes,
	    node: typeforce.maybe(typeforce.Object)
	    // other env vars like networkName
	  }, opts)
	
	  const node = opts.node
	  const changes = opts.changes
	
	  function wroteSeal (data, tx, cb) {
	    typeforce({
	      link: typeforce.String,
	      sealAddress: typeforce.String,
	      networkName: typeforce.String
	    }, data)
	
	    typeforce({
	      txId: typeforce.String
	    }, tx)
	
	    if ((data.prevLink || data.sealPrevAddress) && !(data.prevLink && data.sealPrevAddress)) {
	      throw new Error('expected either both prevLink and sealPrevAddress or neither')
	    }
	
	    append({
	      topic: topics.wroteseal,
	      // uid: getSealUID(data),
	      link: data.link,
	      prevLink: data.prevLink,
	      sealAddress: data.sealAddress,
	      sealPrevAddress: data.sealPrevAddress,
	      networkName: data.networkName,
	      txId: tx.txId,
	      status: SealStatus.sealed
	    }, cb)
	  }
	
	  function addContact (identity, link, cb) {
	    typeforce(types.identity, identity)
	    typeforce(typeforce.String, link)
	
	    const entry = utils.getLinks({
	      link: link,
	      object: identity
	    })
	
	    entry.topic = topics.addcontact
	    append(entry, cb)
	  }
	
	  function createObject (wrapper, cb) {
	    typeforce({
	      object: types.signedObject,
	      link: typeforce.String,
	      author: typeforce.String,
	      permalink: typeforce.maybe(typeforce.String),
	      prevLink: typeforce.maybe(typeforce.String),
	      objectinfo: typeforce.maybe(typeforce.Object),
	      partialinfo: typeforce.maybe(typeforce.Object)
	    }, wrapper)
	
	    const entry = utils.pick(wrapper, 'link', 'permalink', 'prevLink', 'author', 'recipient', 'objectinfo', 'partialinfo')
	    utils.addLinks(entry)
	    entry.topic = topics.newobj
	    entry.type = wrapper.object[TYPE]
	    if (entry.type === MESSAGE) {
	      entry.seq = wrapper.object[SEQ]
	      typeforce(typeforce.String, entry.recipient)
	      if (!wrapper.received) {
	        entry.sendstatus = statuses.send.pending
	      }
	
	      if (!entry.objectinfo) entry.objectinfo = {}
	      const objinfo = entry.objectinfo
	
	      if (!objinfo.type) objinfo.type = wrapper.object.object[TYPE]
	      if (!objinfo.link || !objinfo.permalink) {
	        const links = utils.getLinks({ object: wrapper.object.object })
	        utils.extend(objinfo, links)
	      }
	    }
	
	    entry.archived = false
	    append(entry, cb)
	  }
	
	  function writeSeal (data, cb) {
	    typeforce({
	      link: typeforce.String,
	      networkName: typeforce.String,
	      basePubKey: types.chainPubKey,
	      sealPubKey: types.chainPubKey,
	      prevLink: typeforce.maybe(typeforce.String),
	      sealPrevPubKey: typeforce.maybe(types.chainPubKey),
	      sealAddress: typeforce.maybe(typeforce.String),
	      sealPrevAddress: typeforce.maybe(typeforce.String),
	      amount: typeforce.maybe(typeforce.Number)
	    }, data, true)
	
	    data.topic = topics.queueseal
	    if (!data.sealAddress) {
	      data.sealAddress = utils.pubKeyToAddress(data.sealPubKey, data.networkName)
	    }
	
	    if (!data.sealPrevAddress && data.sealPrevPubKey) {
	      data.sealPrevAddress = utils.pubKeyToAddress(data.sealPrevPubKey, data.networkName)
	    }
	
	    if ((data.prevLink || data.sealPrevAddress) && !(data.prevLink && data.sealPrevAddress)) {
	      throw new Error('expected either both prevLink and sealPrevAddress or neither')
	    }
	
	    data.status = SealStatus.pending
	    // data.uid = getSealUID(data)
	    data.write = true
	    append(data, cb)
	  }
	
	  function createWatch (watch, cb) {
	    typeforce({
	      address: typeforce.String,
	      link: typeforce.String,
	      basePubKey: types.chainPubKey,
	      watchType: typeforce.String,
	    }, watch, true)
	
	    watch.topic = topics.newwatch
	    append(watch, cb)
	  }
	
	  // function saveTx (txInfo, cb) {
	  //   typeforce({
	  //     txId: typeforce.String,
	  //     txHex: typeforce.String,
	  //     tx: typeforce.Object,
	  //     from: typeforce.Object,
	  //     to: typeforce.Object,
	  //     confirmations: typeforce.Number,
	  //   }, txInfo)
	
	  //   append({
	  //     topic: topics.tx,
	  //     txHex: txInfo.txHex,
	  //     from: txInfo.from,
	  //     to: txInfo.to,
	  //     confirmations: txInfo.confirmations,
	  //   }, cb)
	  // }
	
	  function sentMessage (link, cb) {
	    typeforce(typeforce.String, link)
	
	    append({
	      topic: topics.sent,
	      link: link,
	      sendstatus: statuses.send.sent
	    }, cb)
	  }
	
	  function readSeal (data, cb) {
	    typeforce({
	      link: typeforce.maybe(typeforce.String),
	      prevLink: typeforce.maybe(typeforce.String),
	      basePubKey: types.chainPubKey,
	      txId: typeforce.String,
	      confirmations: typeforce.Number,
	      addresses: typeforce.arrayOf(typeforce.String),
	      // if we know sealAddress, we already know what version we're monitoring
	      sealAddress: typeforce.maybe(typeforce.String),
	      // if we only know sealPrevAddress, we've detected a seal for a version
	      // we do not yet possess
	      sealPrevAddress: typeforce.maybe(typeforce.String),
	    }, data, true)
	
	    if (!(data.sealAddress || data.sealPrevAddress)) {
	      throw new Error('expected "sealAddress" or "sealPrevAddress"')
	    }
	
	    // data.confirmed = data.confirmations >= node.confirmedAfter
	    data.topic = topics.readseal
	    append(data, cb)
	  }
	
	  function forgetObject (link, cb) {
	    append({
	      topic: topics.archiveobj,
	      link: link
	    }, cb)
	  }
	
	  function rememberObject (link, cb) {
	    append({
	      topic: topics.unarchiveobj,
	      link: link
	    }, cb)
	  }
	
	  function append (entry, cb) {
	    cb = cb || noop
	
	    typeforce(typeforce.String, entry.topic)
	
	    entry.timestamp = entry.timestamp || utils.now()
	    changes.append(entry, function (err) {
	      if (err) return cb(err)
	
	      cb()
	      if (node) debug(node.name || node.shortlink, entry.topic)
	
	      process.nextTick(function () {
	        emitter.emit(entry.topic, entry)
	      })
	    })
	  }
	
	  const emitter = new EventEmitter()
	
	  return utils.extend(emitter, {
	    wroteSeal,
	    sentMessage,
	    addContact,
	    createObject,
	    writeSeal,
	    createWatch,
	    // saveTx,
	    readSeal,
	    forgetObject,
	    rememberObject
	  })
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(294)))

/***/ },

/***/ 1421:
/***/ function(module, exports) {

	
	exports.save = '\uD83D\uDCBE'
	exports.send = '\uD83D\uDCE7'


/***/ },

/***/ 1422:
/***/ function(module, exports) {

	/**
	 * default settings
	 * @module defaults
	 */
	
	// sync with blockchain interval
	
	/**
	 * @constant
	 * @type {Number}
	 * @default
	 */
	exports.syncInterval = 60 * 1000 * 1000 // 10 mins
	// confirmations before a tx is taken off the watch list
	
	/**
	 * @constants
	 * @type {Number}
	 * @default
	 */
	exports.confirmedAfter = 10
	
	exports.lockTimeout = 5000


/***/ },

/***/ 1423:
/***/ function(module, exports) {

	
	var DATA_ARG_NAME = 'data'
	
	module.exports = {
	  IDENTITY_PUBLISH_ADDRESS: 'mhKnKtPFCbYpC61buDMgSBB57mqiWvXCUo',
	  DATA_ARG_NAME: DATA_ARG_NAME,
	  JSON_CONTENT_DISP: 'Content-Disposition: form-data; name="' + DATA_ARG_NAME + '"',
	  DEFAULT_BOUNDARY: '--------------------------000000000000000000000000',
	  OP_RETURN_PREFIX: 'tradle',
	  TYPE: '_t',
	  CUR_HASH: '_c',
	  PREV_HASH: '_p',
	  ROOT_HASH: '_r',
	  OWNER: '_o',
	  NEXT_OWNER: '_n',
	  SIG: '_s',
	  SIGNEE: '_i',
	  TYPES: {
	    MODEL: 'tradle.Model',
	    IDENTITY: 'tradle.Identity',
	    PROFILE: 'tradle.Profile',
	    ORGANIZATION: 'tradle.Organization',
	    VERIFICATION: 'tradle.Verification',
	    FORGET_ME: 'tradle.ForgetMe',
	    FORGOT_YOU: 'tradle.ForgotYou',
	    REQUEST_FOR_REPRESENTATIVE: 'tradle.RequestForRepresentative',
	    IDENTITY_PUBLISHING_REQUEST: 'tradle.IdentityPublishRequest',
	    PRODUCT_LIST: 'tradle.ProductList',
	    CUSTOMER_WAITING: 'tradle.CustomerWaiting',
	    MESSAGE: 'tradle.Message',
	    SIMPLE_MESSAGE: 'tradle.SimpleMessage',
	    ADDITIONAL_INFO: 'tradle.AdditionalInfo',
	    MONEY: 'tradle.Money',
	    FINANCIAL_PRODUCT: 'tradle.FinancialProduct',
	    FORM: 'tradle.Form',
	    SETTINGS: 'tradle.Settings',
	    SELF_INTRODUCTION: 'tradle.SelfIntroduction'
	  },
	  NONCE: '_z',
	  afterBlockTimestamp: 1447181514
	}


/***/ },

/***/ 1425:
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(1426)
	exports.dictionaries = lang => {
	  try {
	    return __webpack_require__(1647)("./dictionary_" + lang + '.json')
	  } catch (err) {
	    return __webpack_require__(1648)
	  }
	}
	
	exports.dict = {
	  en: __webpack_require__(1648),
	  nl: __webpack_require__(1649)
	}
	exports.formDefaults = __webpack_require__(1651)
	exports.data = __webpack_require__(1652)
	exports.currencies = __webpack_require__(1657)
	exports.nationalities = __webpack_require__(1656)
	exports.countries = __webpack_require__(1655)


/***/ },

/***/ 1426:
/***/ function(module, exports, __webpack_require__) {

	const models = module.exports = [
	__webpack_require__(1427),
	__webpack_require__(1428),
	__webpack_require__(1429),
	__webpack_require__(1430),
	__webpack_require__(1431),
	__webpack_require__(1432),
	__webpack_require__(1433),
	__webpack_require__(1434),
	__webpack_require__(1435),
	__webpack_require__(1436),
	__webpack_require__(1437),
	__webpack_require__(1438),
	__webpack_require__(1439),
	__webpack_require__(1440),
	__webpack_require__(1441),
	__webpack_require__(1442),
	__webpack_require__(1443),
	__webpack_require__(1444),
	__webpack_require__(1445),
	__webpack_require__(1446),
	__webpack_require__(1447),
	__webpack_require__(1448),
	__webpack_require__(1449),
	__webpack_require__(1450),
	__webpack_require__(1451),
	__webpack_require__(1452),
	__webpack_require__(1453),
	__webpack_require__(1454),
	__webpack_require__(1455),
	__webpack_require__(1456),
	__webpack_require__(1457),
	__webpack_require__(1458),
	__webpack_require__(1459),
	__webpack_require__(1460),
	__webpack_require__(1461),
	__webpack_require__(1462),
	__webpack_require__(1463),
	__webpack_require__(1464),
	__webpack_require__(1465),
	__webpack_require__(1466),
	__webpack_require__(1467),
	__webpack_require__(1468),
	__webpack_require__(1469),
	__webpack_require__(1470),
	__webpack_require__(1471),
	__webpack_require__(1472),
	__webpack_require__(1473),
	__webpack_require__(1474),
	__webpack_require__(1475),
	__webpack_require__(1476),
	__webpack_require__(1477),
	__webpack_require__(1478),
	__webpack_require__(1479),
	__webpack_require__(1480),
	__webpack_require__(1481),
	__webpack_require__(1482),
	__webpack_require__(1483),
	__webpack_require__(1484),
	__webpack_require__(1485),
	__webpack_require__(1486),
	__webpack_require__(1487),
	__webpack_require__(1488),
	__webpack_require__(1489),
	__webpack_require__(1490),
	__webpack_require__(1491),
	__webpack_require__(1492),
	__webpack_require__(1493),
	__webpack_require__(1494),
	__webpack_require__(1495),
	__webpack_require__(1496),
	__webpack_require__(1497),
	__webpack_require__(1498),
	__webpack_require__(1499),
	__webpack_require__(1500),
	__webpack_require__(1501),
	__webpack_require__(1502),
	__webpack_require__(1503),
	__webpack_require__(1504),
	__webpack_require__(1505),
	__webpack_require__(1506),
	__webpack_require__(1507),
	__webpack_require__(1508),
	__webpack_require__(1509),
	__webpack_require__(1510),
	__webpack_require__(1511),
	__webpack_require__(1512),
	__webpack_require__(1513),
	__webpack_require__(1514),
	__webpack_require__(1515),
	__webpack_require__(1516),
	__webpack_require__(1517),
	__webpack_require__(1518),
	__webpack_require__(1519),
	__webpack_require__(1520),
	__webpack_require__(1521),
	__webpack_require__(1522),
	__webpack_require__(1523),
	__webpack_require__(1524),
	__webpack_require__(1525),
	__webpack_require__(1526),
	__webpack_require__(1527),
	__webpack_require__(1528),
	__webpack_require__(1529),
	__webpack_require__(1530),
	__webpack_require__(1531),
	__webpack_require__(1532),
	__webpack_require__(1533),
	__webpack_require__(1534),
	__webpack_require__(1535),
	__webpack_require__(1536),
	__webpack_require__(1537),
	__webpack_require__(1538),
	__webpack_require__(1539),
	__webpack_require__(1540),
	__webpack_require__(1541),
	__webpack_require__(1542),
	__webpack_require__(1543),
	__webpack_require__(1544),
	__webpack_require__(1545),
	__webpack_require__(1546),
	__webpack_require__(1547),
	__webpack_require__(1548),
	__webpack_require__(1549),
	__webpack_require__(1550),
	__webpack_require__(1551),
	__webpack_require__(1552),
	__webpack_require__(1553),
	__webpack_require__(1554),
	__webpack_require__(1555),
	__webpack_require__(1556),
	__webpack_require__(1557),
	__webpack_require__(1558),
	__webpack_require__(1559),
	__webpack_require__(1560),
	__webpack_require__(1561),
	__webpack_require__(1562),
	__webpack_require__(1563),
	__webpack_require__(1564),
	__webpack_require__(1565),
	__webpack_require__(1566),
	__webpack_require__(1567),
	__webpack_require__(1568),
	__webpack_require__(1569),
	__webpack_require__(1570),
	__webpack_require__(1571),
	__webpack_require__(1572),
	__webpack_require__(1573),
	__webpack_require__(1574),
	__webpack_require__(1575),
	__webpack_require__(1576),
	__webpack_require__(1577),
	__webpack_require__(1578),
	__webpack_require__(1579),
	__webpack_require__(1580),
	__webpack_require__(1581),
	__webpack_require__(1582),
	__webpack_require__(1583),
	__webpack_require__(1584),
	__webpack_require__(1585),
	__webpack_require__(1586),
	__webpack_require__(1587),
	__webpack_require__(1588),
	__webpack_require__(1589),
	__webpack_require__(1590),
	__webpack_require__(1591),
	__webpack_require__(1592),
	__webpack_require__(1593),
	__webpack_require__(1594),
	__webpack_require__(1595),
	__webpack_require__(1596),
	__webpack_require__(1597),
	__webpack_require__(1598),
	__webpack_require__(1599),
	__webpack_require__(1600),
	__webpack_require__(1601),
	__webpack_require__(1602),
	__webpack_require__(1603),
	__webpack_require__(1604),
	__webpack_require__(1605),
	__webpack_require__(1606),
	__webpack_require__(1607),
	__webpack_require__(1608),
	__webpack_require__(1609),
	__webpack_require__(1610),
	__webpack_require__(1611),
	__webpack_require__(1612),
	__webpack_require__(1613),
	__webpack_require__(1614),
	__webpack_require__(1615),
	__webpack_require__(1616),
	__webpack_require__(1617),
	__webpack_require__(1618),
	__webpack_require__(1619),
	__webpack_require__(1620),
	__webpack_require__(1621),
	__webpack_require__(1622),
	__webpack_require__(1623),
	__webpack_require__(1624),
	__webpack_require__(1625),
	__webpack_require__(1626),
	__webpack_require__(1627),
	__webpack_require__(1628),
	__webpack_require__(1629),
	__webpack_require__(1630),
	__webpack_require__(1631),
	__webpack_require__(1632),
	__webpack_require__(1633),
	__webpack_require__(1634),
	__webpack_require__(1635),
	__webpack_require__(1636),
	__webpack_require__(1637),
	__webpack_require__(1638),
	__webpack_require__(1639),
	__webpack_require__(1640),
	__webpack_require__(1641),
	__webpack_require__(1642),
	__webpack_require__(1643),
	__webpack_require__(1644),
	__webpack_require__(1645),
	__webpack_require__(1646)]
	models.forEach(function (m) {
	  models[m.id] = m
	})


/***/ },

/***/ 1427:
/***/ function(module, exports) {

	module.exports = {
		"id": "nl.tradle.BusinessAccount",
		"title": "Business Account",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.FinancialProduct",
		"type": "tradle.Model",
		"forms": [
			"nl.tradle.MyDigitalPassport",
			"nl.tradle.MyCompanyRegistration"
		],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			}
		}
	};

/***/ },

/***/ 1428:
/***/ function(module, exports) {

	module.exports = {
		"id": "nl.tradle.CompanyInformation",
		"title": "Company Information",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"companyName": {
				"type": "string"
			},
			"natureOfCompany": {
				"type": "string"
			},
			"dateOfFormation": {
				"type": "date"
			},
			"address1": {
				"type": "string",
				"title": "Address line 1"
			},
			"address2": {
				"type": "string",
				"title": "Address line 2"
			},
			"city": {
				"type": "string"
			},
			"region": {
				"type": "string",
				"title": "State/Province"
			},
			"postalCode": {
				"type": "string"
			},
			"country": {
				"type": "object",
				"ref": "tradle.Country"
			},
			"address": {
				"type": "string",
				"displayAs": "{1} {2} {3}, {4}, {5} {6}, {7}",
				"group": [
					"address1",
					"address2",
					"city",
					"region",
					"postalCode",
					"country"
				],
				"title": "Company Address",
				"readOnly": true
			}
		},
		"editCols": [
			"companyName",
			"natureOfCompany",
			"dateOfFormation",
			"address1",
			"address2",
			"city",
			"region",
			"postalCode",
			"country"
		],
		"viewCols": [
			"companyName",
			"natureOfCompany",
			"dateOfFormation"
		],
		"required": [
			"companyName",
			"address1",
			"city",
			"region",
			"postalCode",
			"country",
			"natureOfCompany",
			"dateOfFormation"
		]
	};

/***/ },

/***/ 1429:
/***/ function(module, exports) {

	module.exports = {
		"id": "nl.tradle.CompanyRegistration",
		"title": "Company Registration",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.FinancialProduct",
		"type": "tradle.Model",
		"forms": [
			"nl.tradle.MyDigitalPassport",
			"nl.tradle.CompanyInformation"
		],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			}
		}
	};

/***/ },

/***/ 1430:
/***/ function(module, exports) {

	module.exports = {
		"id": "nl.tradle.DigitalPassport",
		"title": "Digital Passport",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.FinancialProduct",
		"type": "tradle.Model",
		"forms": [
			"tradle.PhotoID",
			"tradle.Selfie"
		],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			}
		}
	};

/***/ },

/***/ 1431:
/***/ function(module, exports) {

	module.exports = {
		"id": "nl.tradle.MyBusinessAccount",
		"title": "My Business Account",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.MyProduct",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"myProductId": {
				"title": "Account ID",
				"type": "string"
			}
		},
		"viewCols": [
			"myProductId"
		]
	};

/***/ },

/***/ 1432:
/***/ function(module, exports) {

	module.exports = {
		"id": "nl.tradle.MyCompanyRegistration",
		"title": "My Company Registration",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.MyProduct",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"myProductId": {
				"title": "Company ID",
				"type": "string"
			},
			"companyName": {
				"type": "string"
			},
			"natureOfCompany": {
				"type": "string"
			},
			"dateOfFormation": {
				"type": "date"
			},
			"address1": {
				"type": "string",
				"title": "Address line 1"
			},
			"address2": {
				"type": "string",
				"title": "Address line 2"
			},
			"city": {
				"type": "string"
			},
			"region": {
				"type": "string",
				"title": "State/Province"
			},
			"postalCode": {
				"type": "string"
			},
			"country": {
				"type": "object",
				"ref": "tradle.Country"
			},
			"address": {
				"type": "string",
				"displayAs": "{1} {2} {3}, {4}, {5} {6}, {7}",
				"group": [
					"address1",
					"address2",
					"city",
					"region",
					"postalCode",
					"country"
				],
				"title": "Company Address",
				"readOnly": true
			}
		},
		"viewCols": [
			"companyName",
			"dateOfFormation"
		]
	};

/***/ },

/***/ 1433:
/***/ function(module, exports) {

	module.exports = {
		"id": "nl.tradle.MyDigitalPassport",
		"title": "My Digital Passport",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.MyProduct",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"myProductId": {
				"title": "Digital Passport ID",
				"type": "string"
			},
			"country": {
				"type": "object",
				"ref": "tradle.Country"
			}
		},
		"viewCols": [
			"myProductId",
			"country"
		]
	};

/***/ },

/***/ 1434:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.APIBasedVerificationMethod",
		"type": "tradle.Model",
		"title": "API based verification",
		"subClassOf": "tradle.Method",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"api": {
				"type": "object",
				"ref": "tradle.API",
				"inlined": true
			},
			"reference": {
				"skipLabel": true,
				"type": "array",
				"items": {
					"properties": {
						"queryId": {
							"type": "string"
						}
					}
				}
			},
			"title": {
				"type": "string",
				"readOnly": true,
				"displayName": true,
				"displayAs": "based on {1} checked by {2} automatically (via API)",
				"group": [
					"aspect",
					"api"
				]
			},
			"confidence": {
				"type": "number",
				"min": "0",
				"max": "1"
			},
			"aspect": {
				"type": "string"
			},
			"rawData": {
				"type": "object",
				"skipLabel": true,
				"title": "Raw data",
				"range": "json",
				"readOnly": true
			}
		},
		"required": [
			"aspect",
			"api",
			"reference"
		],
		"viewCols": [
			"aspect",
			"api",
			"reference",
			"confidence",
			"rawData"
		]
	};

/***/ },

/***/ 1435:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.API",
		"type": "tradle.Model",
		"title": "API",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"name": {
				"displayName": true,
				"type": "string"
			},
			"provider": {
				"type": "object",
				"ref": "tradle.Organization"
			}
		},
		"required": [
			"name",
			"provider"
		]
	};

/***/ },

/***/ 1436:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.AboutYou",
		"title": "About You",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"residentialStatus": {
				"type": "object",
				"ref": "tradle.ResidentialStatus"
			},
			"maritalStatus": {
				"type": "object",
				"ref": "tradle.MaritalStatus"
			},
			"dependants": {
				"type": "number",
				"description": "How many people who live with you depend on you financially?"
			},
			"nationality": {
				"type": "object",
				"ref": "tradle.Nationality"
			},
			"countryOfBirth": {
				"type": "object",
				"ref": "tradle.Country"
			},
			"taxResidency": {
				"type": "object",
				"description": "Country/countries in which you have tax residency (or been resident of for the past 2 years):",
				"ref": "tradle.Country"
			},
			"fundAccount": {
				"type": "object",
				"description": "How will you fund your account?",
				"ref": "tradle.HowToFund"
			},
			"purposeOfTheAccount": {
				"type": "object",
				"ref": "tradle.PurposeOfTheAccount"
			},
			"phones": {
				"type": "array",
				"icon": "ios-call-outline",
				"items": {
					"type": "object",
					"properties": {
						"phoneType": {
							"type": "object",
							"ref": "tradle.PhoneTypes"
						},
						"number": {
							"type": "string",
							"range": "phone",
							"keyboard": "phone-pad"
						},
						"myPhones": {
							"type": "string",
							"displayAs": "{1} : {2}",
							"group": [
								"phoneType",
								"number"
							],
							"readOnly": true,
							"skipLabel": true
						}
					}
				},
				"required": [
					"phoneType",
					"number"
				],
				"viewCols": [
					"myPhones"
				]
			},
			"emailAddress": {
				"type": "string",
				"pattern": "^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$",
				"keyboard": "email-address"
			},
			"photos": {
				"type": "array",
				"title": "Photo ID snapshots",
				"items": {
					"type": "object",
					"properties": {
						"tags": {
							"type": "string",
							"skipLabel": true
						},
						"url": {
							"type": "string",
							"readOnly": true
						},
						"width": {
							"type": "number",
							"readOnly": true
						},
						"height": {
							"type": "number",
							"readOnly": true
						}
					}
				},
				"required": [
					"title",
					"url"
				]
			}
		},
		"viewCols": [
			"residentialStatus",
			"maritalStatus",
			"countryOfBirth",
			"taxResidency",
			"fundAccount",
			"purposeOfTheAccount",
			"phones",
			"emailAddress",
			"photos"
		]
	};

/***/ },

/***/ 1437:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Ack",
		"type": "tradle.Model",
		"title": "Item Received",
		"interfaces": [
			"tradle.Message"
		],
		"properties": {
			"message": {
				"skipLabel": true,
				"type": "string"
			},
			"item": {
				"type": "object",
				"ref": "tradle.Message",
				"readOnly": true
			}
		},
		"required": [
			"item",
			"message"
		],
		"viewCols": [
			"message"
		]
	};

/***/ },

/***/ 1438:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.ActivityLicense",
		"type": "tradle.Model",
		"title": "Activity license",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.FinancialProduct",
		"forms": [],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"productType": {
				"type": "string",
				"readOnly": true,
				"displayName": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			}
		}
	};

/***/ },

/***/ 1439:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.AdditionalInfo",
		"type": "tradle.Model",
		"title": "Additional Information",
		"interfaces": [
			"tradle.Message"
		],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"message": {
				"type": "string",
				"displayName": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"ref": "tradle.Identity",
				"readOnly": true
			},
			"time": {
				"type": "date",
				"readOnly": true,
				"displayName": true
			},
			"document": {
				"ref": "tradle.Message",
				"readOnly": true,
				"type": "object"
			},
			"confirmed": {
				"type": "boolean",
				"readOnly": true
			}
		},
		"required": [
			"to",
			"from",
			"message"
		],
		"viewCols": [
			"message"
		]
	};

/***/ },

/***/ 1440:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.AddressType",
		"title": "Address Type",
		"type": "tradle.Model",
		"subClassOf": "tradle.Enum",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"addressType": {
				"displayName": true,
				"type": "string"
			}
		}
	};

/***/ },

/***/ 1441:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Address",
		"type": "tradle.Model",
		"title": "Address",
		"subClassOf": "tradle.Form",
		"interfaces": [
			"tradle.Message"
		],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"streetAddress": {
				"type": "string"
			},
			"city": {
				"type": "string"
			},
			"postalCode": {
				"type": "string"
			},
			"region": {
				"type": "string"
			},
			"country": {
				"type": "object",
				"ref": "tradle.Country"
			},
			"formattedAddress": {
				"type": "string",
				"displayAs": "{1}, {2}, {3} {4}",
				"group": [
					"streetAddress",
					"city",
					"region",
					"postalCode"
				],
				"title": "Address",
				"readOnly": true
			},
			"address_group": {
				"type": "string",
				"title": "Address",
				"list": [
					"streetAddress",
					"city",
					"country",
					"postalCode",
					"region"
				]
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"ref": "tradle.Identity",
				"displayName": true,
				"readOnly": true
			}
		},
		"required": [
			"streetAddress",
			"city",
			"country",
			"postalCode",
			"region"
		],
		"editCols": [
			"address_group"
		],
		"viewCols": [
			"address_group"
		]
	};

/***/ },

/***/ 1442:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.AllowanceAppForNonProfit",
		"type": "tradle.Model",
		"title": "Allowance application for nonprofit organization",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.FinancialProduct",
		"forms": [],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"productType": {
				"type": "string",
				"readOnly": true,
				"displayName": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			}
		}
	};

/***/ },

/***/ 1443:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.AppState",
		"title": "App State",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"state": {
				"displayName": true,
				"type": "string"
			}
		}
	};

/***/ },

/***/ 1444:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.ApplicationForEResidency",
		"title": "Application for e-Residency",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"firstName": {
				"type": "string"
			},
			"lastName": {
				"type": "string"
			},
			"countryOfBirth": {
				"type": "object",
				"ref": "tradle.Country"
			},
			"name": {
				"type": "string",
				"displayAs": "{2} {1}",
				"group": [
					"lastName",
					"firstName"
				],
				"readOnly": true,
				"displayName": true
			},
			"citizenship": {
				"type": "object",
				"ref": "tradle.Country"
			},
			"dateOfBirth": {
				"type": "date",
				"maxDate": "18 years before",
				"minDate": "110 years before"
			},
			"sex": {
				"type": "object",
				"ref": "tradle.Sex"
			}
		},
		"editCols": [
			"firstName",
			"lastName",
			"countryOfBirth",
			"citizenship",
			"dateOfBirth",
			"sex"
		],
		"required": [
			"firstName",
			"lastName",
			"countryOfBirth",
			"citizenship",
			"dateOfBirth",
			"sex"
		],
		"viewCols": [
			"firstName",
			"lastName",
			"countryOfBirth",
			"citizenship",
			"dateOfBirth",
			"sex"
		]
	};

/***/ },

/***/ 1445:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.ApplicationSubmitted",
		"type": "tradle.Model",
		"title": "Application Submitted",
		"interfaces": [
			"tradle.Message"
		],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"message": {
				"type": "string"
			},
			"application": {
				"type": "object",
				"ref": "tradle.ProductApplication"
			},
			"forms": {
				"type": "array",
				"items": {
					"type": "object",
					"ref": "tradle.Form"
				}
			}
		}
	};

/***/ },

/***/ 1446:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.ArtworkInfo",
		"title": "Artwork Info",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"artist": {
				"type": "string"
			},
			"artworkTitle": {
				"type": "string"
			},
			"medium": {
				"type": "string"
			},
			"partOfCollection": {
				"type": "string"
			},
			"locationOfArtwork": {
				"type": "string"
			},
			"currentMarketValue": {
				"type": "object",
				"ref": "tradle.Money"
			},
			"areYouTheSoleOwner": {
				"type": "boolean"
			},
			"photos": {
				"type": "array",
				"inlined": true,
				"items": {
					"ref": "tradle.Photo"
				}
			}
		},
		"required": [
			"artist",
			"medium",
			"artworkTitle",
			"currentMarketValue",
			"areYouTheSoleOwner"
		],
		"viewCols": [
			"artist",
			"medium",
			"artworkTitle",
			"currentMarketValue",
			"areYouTheSoleOwner",
			"locationOfArtwork",
			"partOfCollection",
			"photos"
		]
	};

/***/ },

/***/ 1447:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Aspect",
		"type": "tradle.Model",
		"title": "Aspect",
		"properties": {
			"_t": {
				"type": "string"
			},
			"name": {
				"type": "string"
			},
			"methods": {
				"type": "array",
				"items": {
					"ref": "tradle.Method"
				}
			}
		},
		"required": [
			"name",
			"methods"
		],
		"viewCols": [
			"name",
			"methods"
		]
	};

/***/ },

/***/ 1448:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.BasicContactInfo",
		"title": "Basic Contact Info",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"firstName": {
				"type": "string"
			},
			"lastName": {
				"type": "string"
			},
			"email": {
				"type": "string",
				"pattern": "^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$",
				"keyboard": "email-address"
			},
			"formattedName": {
				"type": "string",
				"displayAs": "{1} {2}",
				"group": [
					"firstName",
					"lastName"
				],
				"readOnly": true,
				"displayName": true
			},
			"photos": {
				"type": "array",
				"range": "photo",
				"inlined": true,
				"items": {
					"ref": "tradle.Photo"
				}
			}
		},
		"required": [
			"firstName",
			"lastName",
			"email"
		],
		"viewCols": [
			"firstName",
			"lastName",
			"photos"
		]
	};

/***/ },

/***/ 1449:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.BetaTesterContactInfo",
		"title": "Beta Tester Contact Info",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"firstName": {
				"type": "string"
			},
			"lastName": {
				"type": "string"
			},
			"email": {
				"type": "string",
				"pattern": "^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$",
				"keyboard": "email-address",
				"title": "Email with which you registered your Apple ID"
			},
			"dockerhub": {
				"type": "string",
				"title": "Docker Hub username"
			},
			"github": {
				"type": "string",
				"title": "Github username"
			},
			"formattedName": {
				"type": "string",
				"displayAs": "{1} {2}",
				"group": [
					"firstName",
					"lastName"
				],
				"readOnly": true,
				"displayName": true
			},
			"photos": {
				"type": "array",
				"range": "photo",
				"inlined": true,
				"items": {
					"ref": "tradle.Photo"
				}
			}
		},
		"required": [
			"firstName",
			"lastName",
			"email",
			"dockerhub"
		],
		"viewCols": [
			"firstName",
			"lastName",
			"email",
			"dockerhub",
			"github"
		]
	};

/***/ },

/***/ 1450:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.BusinessAccount",
		"title": "Business Account",
		"interfaces": [
			"tradle.Message"
		],
		"type": "tradle.Model",
		"forms": [
			"tradle.BusinessInformation",
			"tradle.SalesData"
		],
		"subClassOf": "tradle.FinancialProduct",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			}
		}
	};

/***/ },

/***/ 1451:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.BusinessInformation",
		"title": "Business Information",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"companyName": {
				"type": "string"
			},
			"DBAName": {
				"type": "string",
				"title": "DBA Name"
			},
			"registrationNumber": {
				"type": "string"
			},
			"registrationDate": {
				"type": "date"
			},
			"taxIdNumber": {
				"type": "string",
				"title": "Tax ID Number"
			},
			"officialAddress": {
				"type": "string"
			},
			"actualAddress": {
				"type": "string"
			},
			"country": {
				"type": "object",
				"ref": "tradle.Country"
			},
			"companyPhone": {
				"type": "string",
				"range": "phone",
				"keyboard": "phone-pad"
			},
			"companyFax": {
				"type": "string",
				"keyboard": "phone-pad"
			},
			"companyEmail": {
				"type": "string",
				"pattern": "^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$",
				"keyboard": "email-address"
			},
			"numberOfEmployees": {
				"type": "number"
			},
			"photos": {
				"type": "array",
				"items": {
					"type": "object",
					"properties": {
						"tags": {
							"type": "string",
							"skipLabel": true
						},
						"url": {
							"type": "string",
							"readOnly": true
						},
						"width": {
							"type": "number",
							"readOnly": true
						},
						"height": {
							"type": "number",
							"readOnly": true
						}
					}
				},
				"required": [
					"title",
					"url"
				]
			}
		},
		"viewCols": [
			"companyName",
			"registrationNumber",
			"officialAddress",
			"companyEmail"
		],
		"required": [
			"companyName",
			"registrationNumber",
			"registrationDate",
			"taxIdNumber",
			"officialAddress",
			"actualAddress",
			"companyPhone",
			"companyFax",
			"companyEmail",
			"numberOfEmployees",
			"photos"
		]
	};

/***/ },

/***/ 1452:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.CVItem",
		"title": "Wealth item",
		"interfaces": [
			"tradle.Message",
			"tradle.Verifiable",
			"tradle.Item"
		],
		"verifiableAspects": {
			"authenticity": {
				"methods": [
					"tradle.VisualVerificationMethod"
				]
			},
			"ownership": {
				"methods": [
					"tradle.VisualVerificationMethod"
				]
			},
			"validity": {
				"methods": [
					"tradle.VisualVerificationMethod"
				]
			}
		},
		"subClassOf": "tradle.Form",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"narrative": {
				"type": "string",
				"displayName": true
			},
			"date": {
				"type": "date"
			},
			"wealthCV": {
				"type": "object",
				"title": "Wealth CV",
				"readOnly": true,
				"ref": "tradle.WealthCV"
			},
			"photos": {
				"type": "array",
				"inlined": true,
				"items": {
					"ref": "tradle.Photo"
				}
			},
			"amount": {
				"type": "object",
				"ref": "tradle.Money"
			},
			"itemType": {
				"type": "object",
				"ref": "tradle.WealthItemType"
			},
			"verifications": {
				"type": "array",
				"readOnly": true,
				"items": {
					"backlink": "document",
					"ref": "tradle.Verification"
				}
			}
		},
		"required": [
			"narrative",
			"date",
			"itemType",
			"amount"
		],
		"editCols": [
			"narrative",
			"date",
			"itemType",
			"amount",
			"photos"
		],
		"viewCols": [
			"narrative",
			"date",
			"itemType",
			"amount",
			"photos"
		]
	};

/***/ },

/***/ 1453:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.CancelAccount",
		"title": "Cancel e-Residency",
		"type": "tradle.Model",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.FinancialProduct",
		"forms": [],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"productType": {
				"type": "string",
				"readOnly": true,
				"displayName": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			}
		}
	};

/***/ },

/***/ 1454:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Collateral",
		"title": "Collateral/House",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"street": {
				"type": "string"
			},
			"houseNumber": {
				"type": "number"
			},
			"city": {
				"type": "string"
			},
			"region": {
				"type": "string"
			},
			"postalCode": {
				"type": "string"
			},
			"country": {
				"type": "object",
				"ref": "tradle.Country"
			},
			"formattedAddress": {
				"type": "string",
				"displayAs": "{1} {2}, {3}, {4} {5}",
				"group": [
					"houseNumber",
					"street",
					"city",
					"region",
					"postalCode"
				],
				"title": "Address",
				"readOnly": true
			},
			"houseValue": {
				"type": "object",
				"ref": "tradle.Money"
			},
			"kindOfConstruction": {
				"type": "object",
				"ref": "tradle.KindOfConstruction"
			},
			"kindOfHouse": {
				"type": "object",
				"ref": "tradle.KindOfHouse"
			},
			"additionalCosts": {
				"type": "object",
				"ref": "tradle.Money"
			},
			"restructuringCosts": {
				"type": "object",
				"ref": "tradle.Money"
			},
			"leaseholdKind": {
				"type": "object",
				"ref": "tradle.PaymentPeriod"
			},
			"leaseholdAmount": {
				"type": "object",
				"ref": "tradle.Money"
			},
			"yearTheHouseWasBuilt": {
				"type": "number",
				"min": "1800"
			},
			"rented": {
				"type": "boolean",
				"title": "Rented?"
			},
			"purchasePrice": {
				"type": "object",
				"ref": "tradle.Money"
			},
			"valuedPrice": {
				"type": "object",
				"ref": "tradle.Money"
			},
			"foreclosureValue": {
				"type": "object",
				"ref": "tradle.Money"
			},
			"badMaintenanceAmount": {
				"type": "object",
				"ref": "tradle.Money"
			},
			"energyLabel": {
				"type": "object",
				"ref": "tradle.EnergyLabel"
			}
		},
		"required": [
			"street",
			"houseNumber",
			"city",
			"region",
			"country",
			"postalCode",
			"houseValue",
			"kindOfConstruction",
			"kindOfHouse",
			"restructuringCosts",
			"yearTheHouseWasBuilt",
			"purchasePrice",
			"valuedPrice",
			"energyLabel"
		],
		"viewCols": [
			"formattedAddress",
			"houseValue",
			"kindOfConstruction",
			"kindOfHouse",
			"restructuringCosts",
			"yearTheHouseWasBuilt",
			"rented",
			"purchasePrice",
			"valuedPrice",
			"foreclosureValue",
			"badMaintenanceAmount",
			"energyLabel"
		],
		"hidden": [
			"leaseholdKind",
			"leaseholdAmount"
		]
	};

/***/ },

/***/ 1455:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.CollaterizedLoan",
		"title": "Collaterized Loan",
		"interfaces": [
			"tradle.Message"
		],
		"type": "tradle.Model",
		"forms": [
			"tradle.PersonalInfo",
			"tradle.Residence",
			"tradle.LoanDetail",
			"tradle.PropertyOwnership"
		],
		"subClassOf": "tradle.FinancialProduct",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			}
		}
	};

/***/ },

/***/ 1456:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.CommercialProduct",
		"title": "Commercial Product",
		"type": "tradle.Model",
		"subClassOf": "tradle.Enum",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"productType": {
				"displayName": true,
				"type": "string"
			}
		}
	};

/***/ },

/***/ 1457:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.CompanyInformation",
		"type": "tradle.Model",
		"title": "Company Information",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"legalName": {
				"type": "string",
				"displayName": true
			},
			"tradingName": {
				"type": "string"
			},
			"registeredAddress_group": {
				"type": "string",
				"title": "Registered address",
				"list": [
					"r_street",
					"r_city",
					"r_country",
					"r_postalCode",
					"r_region"
				]
			},
			"registeredAddress": {
				"type": "string",
				"displayAs": "{1}, {2}, {3} {4}, {5}",
				"group": [
					"r_street",
					"r_city",
					"r_region",
					"r_postalCode",
					"r_country"
				],
				"title": "Registered address",
				"readOnly": true
			},
			"r_street": {
				"type": "string",
				"title": "Street"
			},
			"r_city": {
				"type": "string",
				"title": "City"
			},
			"r_region": {
				"type": "string",
				"title": "Region"
			},
			"r_postalCode": {
				"type": "string",
				"title": "Postal code"
			},
			"r_country": {
				"type": "object",
				"ref": "tradle.Country",
				"title": "Country"
			},
			"tradingAddress_group": {
				"type": "string",
				"title": "Trading address",
				"list": [
					"t_street",
					"t_city",
					"t_country",
					"t_postalCode",
					"t_region"
				]
			},
			"tradingAddress": {
				"type": "string",
				"displayAs": "{1}, {2}, {3} {4}, {5}",
				"group": [
					"t_street",
					"t_city",
					"t_region",
					"t_postalCode",
					"t_country"
				],
				"title": "Trading address",
				"readOnly": true
			},
			"t_street": {
				"type": "string",
				"title": "Street"
			},
			"t_city": {
				"type": "string",
				"title": "City"
			},
			"t_region": {
				"type": "string",
				"title": "Region"
			},
			"t_postalCode": {
				"type": "string",
				"title": "Postal code"
			},
			"t_country": {
				"type": "object",
				"ref": "tradle.Country",
				"title": "Country"
			},
			"postalAddress_group": {
				"type": "string",
				"title": "Postal address",
				"list": [
					"p_street",
					"p_city",
					"p_country",
					"p_postalCode",
					"p_region"
				]
			},
			"postalAddress": {
				"type": "string",
				"displayAs": "{1}, {2}, {3} {4}, {5}",
				"group": [
					"p_street",
					"p_city",
					"p_region",
					"p_postalCode",
					"p_country"
				],
				"title": "Postal address",
				"readOnly": true
			},
			"p_street": {
				"type": "string",
				"title": "Street"
			},
			"p_city": {
				"type": "string",
				"title": "City"
			},
			"p_region": {
				"type": "string",
				"title": "Region"
			},
			"p_postalCode": {
				"type": "string",
				"title": "Postal code"
			},
			"p_country": {
				"type": "object",
				"ref": "tradle.Country",
				"title": "Country"
			},
			"coverHolderContactInformation": {
				"type": "string"
			},
			"webSite": {
				"type": "string"
			},
			"photos": {
				"type": "array",
				"title": "Document snapshots",
				"items": {
					"type": "object",
					"properties": {
						"tags": {
							"type": "string",
							"skipLabel": true
						},
						"url": {
							"type": "string",
							"readOnly": true
						},
						"width": {
							"type": "number",
							"readOnly": true
						},
						"height": {
							"type": "number",
							"readOnly": true
						}
					}
				},
				"required": [
					"title",
					"url"
				]
			}
		},
		"editCols": [
			"legalName",
			"tradingName",
			"registeredAddress_group",
			"tradingAddress_group",
			"postalAddress_group",
			"coverHolderContactInformation",
			"webSite",
			"photos"
		],
		"required": [
			"legalName",
			"tradingName"
		],
		"viewCols": [
			"legalName",
			"tradingName",
			"registeredAddress_group",
			"registeredAddress",
			"tradingAddress_group",
			"tradingAddress",
			"postalAddress_group",
			"postalAddress",
			"coverHolderContactInformation",
			"webSite",
			"photos"
		]
	};

/***/ },

/***/ 1458:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.CompanyOwners",
		"type": "tradle.Model",
		"title": "Company Owners",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"companyOwners": {
				"type": "string"
			},
			"photos": {
				"type": "array",
				"title": "Document snapshots",
				"items": {
					"type": "object",
					"properties": {
						"tags": {
							"type": "string",
							"skipLabel": true
						},
						"url": {
							"type": "string",
							"readOnly": true
						},
						"width": {
							"type": "number",
							"readOnly": true
						},
						"height": {
							"type": "number",
							"readOnly": true
						}
					}
				},
				"required": [
					"title",
					"url"
				]
			}
		},
		"required": [
			"companyOwners"
		],
		"viewCols": [
			"companyOwners",
			"photos"
		]
	};

/***/ },

/***/ 1459:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.CompanyRegistration",
		"type": "tradle.Model",
		"title": "Company registration",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.FinancialProduct",
		"forms": [
			"tradle.CustomerInfo",
			"tradle.CustomerProfile",
			"tradle.CustomerEntity",
			"tradle.CustomerOwnership"
		],
		"multiEntryForms": [
			"tradle.CustomerEntity"
		],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"productType": {
				"type": "string",
				"readOnly": true,
				"displayName": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			}
		}
	};

/***/ },

/***/ 1460:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.ConfirmPackageRequest",
		"type": "tradle.Model",
		"title": "Confirm Package Request",
		"interfaces": [
			"tradle.Message"
		],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"message": {
				"type": "string",
				"displayName": true
			},
			"form": {
				"type": "string",
				"readOnly": true
			},
			"time": {
				"type": "date",
				"readOnly": true
			},
			"items": {
				"type": "array",
				"readOnly": true,
				"items": {
					"ref": "tradle.Form"
				}
			}
		},
		"required": [
			"message",
			"form"
		],
		"viewCols": [
			"message",
			"form",
			"time"
		]
	};

/***/ },

/***/ 1461:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Confirmation",
		"type": "tradle.Model",
		"title": "Confirmation",
		"interfaces": [
			"tradle.Message"
		],
		"notEditable": true,
		"properties": {
			"message": {
				"type": "string",
				"readOnly": true,
				"skipLabel": true,
				"displayName": true
			},
			"confirmationFor": {
				"type": "object",
				"ref": "tradle.ProductApplication",
				"readOnly": true
			},
			"forms": {
				"type": "array",
				"items": {
					"type": "object",
					"ref": "tradle.Form"
				}
			}
		},
		"required": [
			"message"
		],
		"viewCols": [
			"message"
		]
	};

/***/ },

/***/ 1462:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.ContactInformation",
		"title": "Contact Information",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"country": {
				"type": "object",
				"ref": "tradle.Country"
			},
			"streetAddress": {
				"type": "string"
			},
			"city": {
				"type": "string"
			},
			"postalCode": {
				"type": "string"
			},
			"county": {
				"type": "string"
			},
			"email": {
				"type": "string",
				"title": "E-mail",
				"pattern": "^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$",
				"keyboard": "email-address",
				"range": "email"
			},
			"confirmEmail": {
				"type": "string",
				"pattern": "^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$",
				"keyboard": "email-address",
				"range": "email",
				"title": "Confirm e-mail"
			},
			"telephone": {
				"type": "string",
				"range": "phone",
				"keyboard": "phone-pad"
			},
			"pickupLocation": {
				"type": "object",
				"ref": "tradle.Location"
			}
		},
		"editCols": [
			"country",
			"streetAddress",
			"city",
			"county",
			"postalCode",
			"email",
			"confirmEmail",
			"telephone",
			"pickupLocation"
		],
		"required": [
			"country",
			"streetAddress",
			"city",
			"postalCode",
			"email",
			"confirmEmail",
			"telephone",
			"pickupLocation"
		],
		"viewCols": [
			"country",
			"streetAddress",
			"city",
			"county",
			"postalCode",
			"email",
			"telephone",
			"pickupLocation"
		]
	};

/***/ },

/***/ 1463:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.ContractType",
		"title": "Contract Type",
		"subClassOf": "tradle.Enum",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"contractType": {
				"displayName": true,
				"type": "string"
			}
		}
	};

/***/ },

/***/ 1464:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.CorporateAccount",
		"type": "tradle.Model",
		"title": "Corporate Account",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.FinancialProduct",
		"forms": [
			"tradle.CustomerInfo",
			"tradle.CustomerProfile",
			"tradle.CustomerEntity",
			"tradle.CustomerOwnership"
		],
		"multiEntryForms": [
			"tradle.CustomerEntity"
		],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"productType": {
				"type": "string",
				"readOnly": true,
				"displayName": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			}
		}
	};

/***/ },

/***/ 1465:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Country",
		"subClassOf": "tradle.Enum",
		"title": "Country",
		"sort": "country",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"country": {
				"displayName": true,
				"type": "string"
			},
			"code": {
				"type": "string"
			}
		},
		"required": [
			"country"
		]
	};

/***/ },

/***/ 1466:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.CoverholderApproval",
		"interfaces": [
			"tradle.Message"
		],
		"title": "Coverholder Application",
		"type": "tradle.Model",
		"subClassOf": "tradle.FinancialProduct",
		"customerCanHaveMultiple": true,
		"forms": [
			"tradle.CompanyInformation",
			"tradle.ProfessionalIndemnity",
			"tradle.Licences",
			"tradle.KeyStaff",
			"tradle.Financials",
			"tradle.CompanyOwners",
			"tradle.IndividualOwners"
		],
		"multiEntryForms": [
			"tradle.KeyStaff"
		],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			}
		}
	};

/***/ },

/***/ 1467:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.CreditCards",
		"type": "tradle.Model",
		"title": "Credit Cards",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			}
		}
	};

/***/ },

/***/ 1468:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Currency",
		"type": "tradle.Model",
		"title": "Currency",
		"subClassOf": "tradle.Enum",
		"sort": "code",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"currencyName": {
				"type": "string"
			},
			"code": {
				"type": "string"
			},
			"symbol": {
				"type": "string"
			},
			"currency": {
				"type": "string",
				"displayAs": "{1} - {2}",
				"group": [
					"code",
					"currencyName"
				]
			}
		},
		"required": [
			"currencyName",
			"code"
		],
		"viewCols": [
			"currency"
		]
	};

/***/ },

/***/ 1469:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.CurrentAccount",
		"type": "tradle.Model",
		"title": "Current Account",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.FinancialProduct",
		"forms": [
			"tradle.PersonalInfo",
			"tradle.Residence"
		],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"productType": {
				"type": "string",
				"readOnly": true,
				"displayName": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"accountWith": {
				"type": "object",
				"readOnly": true,
				"displayName": true,
				"ref": "tradle.Organization"
			},
			"residentialStatus": {
				"type": "object",
				"ref": "tradle.ResidentialStatus"
			},
			"maritalStatus": {
				"type": "object",
				"ref": "tradle.MaritalStatus"
			},
			"dependants": {
				"type": "number",
				"description": "How many people who live with you depend on you financially?"
			},
			"nationality": {
				"type": "object",
				"ref": "tradle.Nationality"
			},
			"inUKFrom": {
				"type": "date",
				"description": "When did you arrive in the UK?",
				"title": "In UK from"
			},
			"countryOfBirth": {
				"type": "object",
				"ref": "tradle.Country"
			},
			"taxResidency": {
				"type": "object",
				"description": "Country/countries in which you have tax residency (or been resident of for the past 2 years):",
				"ref": "tradle.Country"
			},
			"fundAccount": {
				"type": "object",
				"description": "How will you fund your account?",
				"ref": "tradle.HowToFund"
			},
			"purposeOfTheAccount": {
				"type": "object",
				"ref": "tradle.PurposeOfTheAccount"
			},
			"phones": {
				"type": "array",
				"items": {
					"type": "string",
					"properties": {
						"phoneType": {
							"type": "string",
							"ref": "tradle.PhoneTypes"
						},
						"number": {
							"type": "string",
							"keyboard": "phone-pad"
						}
					}
				},
				"required": [
					"phoneType",
					"number"
				]
			},
			"emailAddress": {
				"type": "string",
				"keyboard": "email-address"
			},
			"employer": {
				"type": "object",
				"ref": "tradle.Organization"
			},
			"howLongHaveYouWorkedHere": {
				"type": "number",
				"units": "years"
			},
			"monthlyIncome": {
				"type": "object",
				"ref": "tradle.Money"
			}
		}
	};

/***/ },

/***/ 1470:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.CustomerEntity",
		"title": "Corporate Entity",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"entityRole": {
				"type": "string"
			},
			"entityType": {
				"type": "string"
			},
			"position": {
				"type": "string",
				"title": "Position/Rank/Title"
			},
			"other": {
				"type": "string",
				"description": "e.g. VP Treasurer"
			},
			"lastName": {
				"type": "string"
			},
			"firstName": {
				"type": "string"
			},
			"middleName": {
				"type": "string"
			},
			"suffix": {
				"type": "string"
			},
			"dateOfBirth": {
				"maxDate": "18 years before",
				"minDate": "110 years before",
				"type": "date"
			},
			"citizenshipCountry": {
				"type": "object",
				"ref": "tradle.Country"
			},
			"residenceCountry": {
				"type": "object",
				"ref": "tradle.Country"
			},
			"ownershipNature": {
				"type": "string"
			},
			"ownershipPercentage": {
				"type": "number",
				"units": "%"
			},
			"email": {
				"type": "string",
				"pattern": "^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$",
				"keyboard": "email-address",
				"range": "email"
			},
			"phone": {
				"type": "string",
				"range": "phone",
				"keyboard": "phone-pad"
			}
		},
		"viewCols": [
			"entityRole",
			"entityType",
			"position",
			"other",
			"lastName",
			"firstName",
			"middleName",
			"suffix",
			"dateOfBirth",
			"citizenshipCountry",
			"residenceCountry",
			"ownershipNature",
			"ownershipPercentage",
			"email",
			"phone"
		],
		"required": [
			"entityRole",
			"entityType",
			"lastName",
			"firstName",
			"dateOfBirth",
			"citizenshipCountry",
			"residenceCountry",
			"ownershipNature",
			"ownershipPercentage",
			"email",
			"phone"
		]
	};

/***/ },

/***/ 1471:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.CustomerInfo",
		"title": "Corporate Info",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"customerName": {
				"type": "string",
				"description": "e.g. del monte fresh produce, North America, inc"
			},
			"customerOf": {
				"type": "string"
			},
			"secondaryName": {
				"type": "string"
			},
			"middle": {
				"type": "string"
			},
			"suffix": {
				"type": "string"
			},
			"formType": {
				"type": "object",
				"ref": "tradle.FormationType",
				"title": "Formation type",
				"description": "e.g. Corporation, LLC, etc"
			}
		},
		"viewCols": [
			"customerName",
			"customerOf",
			"secondaryName",
			"middle",
			"suffix",
			"formType"
		],
		"required": [
			"customerName",
			"customerOf",
			"formType"
		]
	};

/***/ },

/***/ 1472:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.CustomerOwnership",
		"title": "Corporate Ownership",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"ownershipStructure": {
				"type": "object",
				"ref": "tradle.OwnershipStructure",
				"title": "Ownership Structure"
			},
			"ownershipStructureOther": {
				"type": "string",
				"title": "Ownership Structure Other"
			},
			"bearerShareEntity": {
				"type": "string",
				"title": "Bearer-share Entity"
			},
			"ownerName": {
				"type": "string"
			},
			"ownerCountry": {
				"type": "object",
				"ref": "tradle.Country"
			},
			"ownerRegulator": {
				"type": "string"
			},
			"ownerRegulatorOther": {
				"type": "string"
			},
			"ownerExchange": {
				"type": "string"
			},
			"ownerExchangeOther": {
				"type": "string"
			},
			"ownerStockSymbol": {
				"type": "string",
				"title": "Owner Stock Symbol/Ticker"
			},
			"pacOwnership": {
				"title": "PAC Ownership",
				"type": "string"
			},
			"cipExemptStatus": {
				"type": "object",
				"ref": "tradle.ExemptStatus"
			},
			"cipExemptReason": {
				"type": "string"
			},
			"internetGambling": {
				"type": "string"
			}
		},
		"viewCols": [
			"ownershipStructure",
			"ownershipStructureOther",
			"bearerShareEntity",
			"ownerName",
			"ownerCountry",
			"ownerRegulator",
			"ownerRegulatorOther",
			"ownerExchange",
			"ownerExchangeOther",
			"ownerStockSymbol",
			"pacOwnership",
			"cipExemptStatus",
			"cipExemptReason",
			"internetGambling"
		],
		"required": [
			"ownershipStructure",
			"ownerName",
			"ownerCountry",
			"cipExemptStatus"
		]
	};

/***/ },

/***/ 1473:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.CustomerProfile",
		"title": "Corporate Profile",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"addressType": {
				"type": "object",
				"ref": "tradle.AddressType"
			},
			"address1": {
				"type": "string"
			},
			"address2": {
				"type": "string"
			},
			"address3": {
				"type": "string"
			},
			"city": {
				"type": "string"
			},
			"region": {
				"type": "string",
				"title": "State/Province"
			},
			"zipCode": {
				"type": "string"
			},
			"country": {
				"type": "object",
				"ref": "tradle.Country"
			},
			"address": {
				"type": "string",
				"displayAs": "{1} {2} {3}, {4}, {5} {6}, {7}",
				"group": [
					"address1",
					"address2",
					"address3",
					"city",
					"region",
					"zipCode",
					"country"
				],
				"title": "CIP Address",
				"readOnly": true
			},
			"natureOfCompany": {
				"type": "string"
			},
			"natureOfCompanyOther": {
				"type": "string"
			},
			"dateOfFormation": {
				"type": "date"
			},
			"formedLessThenTwoYears": {
				"type": "boolean",
				"title": "Was the customer set within the last 2 years?"
			},
			"patriotActCertification": {
				"type": "date",
				"title": "PATRIOT Act Certification"
			},
			"businessOrIndustryType": {
				"type": "string",
				"title": "Business/Industry Type"
			},
			"naics": {
				"type": "string",
				"title": "NAICS"
			},
			"duns": {
				"type": "number",
				"title": "DUNS",
				"keyboard": "numbers-and-punctuation",
				"maxLength": 9
			},
			"wwid": {
				"type": "string",
				"title": "WWID"
			},
			"govIdType": {
				"type": "object",
				"ref": "tradle.GovernmentIdType",
				"title": "Gov. ID Type"
			},
			"govIssuedIdNumber": {
				"type": "string",
				"title": "Gov. Issued ID Number"
			},
			"govIdIssuingCountry": {
				"type": "object",
				"ref": "tradle.Country",
				"title": "Gov. ID Issuing Country"
			},
			"regulator": {
				"type": "object",
				"ref": "tradle.Regulator"
			},
			"regulatorOther": {
				"type": "string"
			},
			"exchange": {
				"type": "object",
				"ref": "tradle.Exchange"
			},
			"exchangeOther": {
				"type": "string"
			},
			"stockSymbol": {
				"type": "string",
				"title": "Stock Symbol/Ticker"
			}
		},
		"viewCols": [
			"addressType",
			"address",
			"natureOfCompany",
			"natureOfCompanyOther",
			"dateOfFormation",
			"formedLessThenTwoYears",
			"patriotActCertification",
			"businessOrIndustryType",
			"naics",
			"duns",
			"wwid",
			"govIdType",
			"govIssuedIdNumber",
			"govIdIssuingCountry",
			"regulator",
			"regulatorOther",
			"exchange",
			"exchangeOther",
			"stockSymbol"
		],
		"required": [
			"addressType",
			"address1",
			"city",
			"region",
			"zipCode",
			"country",
			"natureOfCompany",
			"dateOfFormation",
			"patriotActCertification",
			"businessOrIndustryType",
			"naics",
			"duns",
			"wwid",
			"govIdType",
			"govIssuedIdNumber",
			"govIdIssuingCountry",
			"regulator"
		]
	};

/***/ },

/***/ 1474:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.CustomerWaiting",
		"title": "Customer waiting",
		"interfaces": [
			"tradle.Message"
		],
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"message": {
				"type": "string"
			},
			"time": {
				"type": "date",
				"readOnly": true
			},
			"welcome": {
				"type": "boolean",
				"readOnly": true
			}
		},
		"viewCols": [
			"message"
		],
		"required": []
	};

/***/ },

/***/ 1475:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.DebtKind",
		"title": "Debt Kind",
		"type": "tradle.Model",
		"subClassOf": "tradle.Enum",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"debtKind": {
				"displayName": true,
				"type": "string"
			}
		},
		"required": [
			"debtKind"
		]
	};

/***/ },

/***/ 1476:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Document",
		"type": "tradle.Model",
		"title": "Document",
		"isInterface": true,
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"ref": "tradle.Identity",
				"displayName": true
			},
			"container": {
				"type": "object",
				"ref": "tradle.Form"
			},
			"photo": {
				"type": "array",
				"inlined": true,
				"items": {
					"ref": "tradle.Photo"
				}
			}
		}
	};

/***/ },

/***/ 1477:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.DriverLicense",
		"type": "tradle.Model",
		"title": "Driver License",
		"subClassOf": "tradle.Form",
		"interfaces": [
			"tradle.Message",
			"tradle.Verifiable"
		],
		"verifiableAspects": {
			"authenticity": {
				"methods": [
					"tradle.VisualVerificationMethod",
					"tradle.APIBasedVerificationMethod"
				]
			},
			"ownership": {
				"methods": [
					"tradle.VisualVerificationMethod"
				]
			},
			"validity": {
				"methods": [
					"tradle.VisualVerificationMethod"
				]
			}
		},
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"licenseNumber": {
				"type": "number",
				"maxLength": 8,
				"displayName": true
			},
			"surname": {
				"type": "string"
			},
			"givenName": {
				"type": "string"
			},
			"dateOfBirth": {
				"type": "date"
			},
			"dateOfIssue": {
				"type": "date"
			},
			"dateOfExpiry": {
				"type": "date",
				"displayName": true
			},
			"issuingAuthority": {
				"type": "string"
			},
			"holderAddress": {
				"type": "string"
			},
			"entitlementCategories": {
				"type": "string"
			},
			"time": {
				"type": "date",
				"readOnly": true
			},
			"photos": {
				"type": "array",
				"title": "Document Snapshots",
				"range": "photo",
				"inlined": true,
				"items": {
					"ref": "tradle.Photo"
				}
			},
			"verifications": {
				"type": "array",
				"readOnly": true,
				"items": {
					"backlink": "document",
					"ref": "tradle.Verification"
				}
			}
		},
		"required": [
			"photos",
			"licenseNumber",
			"surname",
			"givenName",
			"dateOfBirth",
			"dateOfIssue",
			"dateOfExpiry",
			"issuingAuthority",
			"holderAddress",
			"entitlementCategories"
		],
		"gridCols": [
			"licenseNumber",
			"dateOfExpiry",
			"time"
		],
		"viewCols": [
			"photos",
			"licenseNumber",
			"surname",
			"givenName",
			"dateOfBirth",
			"dateOfIssue",
			"dateOfExpiry",
			"issuingAuthority",
			"holderAddress",
			"entitlementCategories",
			"verifications"
		]
	};

/***/ },

/***/ 1478:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.EResidencyApplicationType",
		"title": "e-Residency application type",
		"subClassOf": "tradle.Enum",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"eResidencyApplicationType": {
				"displayName": true,
				"title": "e-Resincy motivation",
				"type": "string"
			}
		},
		"required": [
			"eResidencyApplicationType"
		]
	};

/***/ },

/***/ 1479:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.EResidency",
		"type": "tradle.Model",
		"title": "e-Residency Application",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.FinancialProduct",
		"forms": [
			"tradle.ApplicationForEResidency",
			"tradle.ContactInformation",
			"tradle.IdentificationDetail",
			"tradle.ReasonForApplication"
		],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"productType": {
				"type": "string",
				"readOnly": true,
				"displayName": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			}
		}
	};

/***/ },

/***/ 1480:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.EResidencyMotivation",
		"title": "e-Residency motivation",
		"subClassOf": "tradle.Enum",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"eResidencyMotivation": {
				"displayName": true,
				"title": "e-Resincy motivation",
				"type": "string"
			}
		},
		"required": [
			"eResidencyMotivation"
		]
	};

/***/ },

/***/ 1481:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.EarthworkApplication",
		"type": "tradle.Model",
		"title": "Earthwork application",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.FinancialProduct",
		"forms": [],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"productType": {
				"type": "string",
				"readOnly": true,
				"displayName": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			}
		}
	};

/***/ },

/***/ 1482:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Education",
		"title": "Education",
		"type": "tradle.Model",
		"subClassOf": "tradle.Form",
		"interfaces": [
			"tradle.Message",
			"tradle.Document",
			"tradle.Verifiable"
		],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"highestDegree": {
				"type": "object",
				"ref": "tradle.EducationDegree"
			},
			"major": {
				"type": "object",
				"ref": "tradle.Major"
			},
			"diploma": {
				"type": "object",
				"allowPicturesFromLibrary": true,
				"ref": "tradle.Photo"
			}
		},
		"required": [
			"highestDegree",
			"major",
			"diploma"
		],
		"viewCols": [
			"highestDegree",
			"major",
			"diploma"
		]
	};

/***/ },

/***/ 1483:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.EducationDegree",
		"title": "Degree of education",
		"type": "tradle.Model",
		"subClassOf": "tradle.Enum",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"educationDegree": {
				"displayName": true,
				"type": "string"
			}
		},
		"required": [
			"educationDegree"
		]
	};

/***/ },

/***/ 1484:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.EducationNL",
		"title": "Education",
		"subClassOf": "tradle.Enum",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"education": {
				"displayName": true,
				"type": "string"
			}
		},
		"required": [
			"education"
		]
	};

/***/ },

/***/ 1485:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.EmailAddress",
		"title": "Email Address",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"type": "tradle.Model",
		"properties": {
			"email": {
				"type": "string",
				"range": "email",
				"keyboard": "email-address"
			}
		},
		"required": [
			"email"
		],
		"viewCols": [
			"email"
		]
	};

/***/ },

/***/ 1486:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.EmployeeOnboarding",
		"type": "tradle.Model",
		"title": "Employee Onboarding",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.FinancialProduct",
		"forms": [
			"tradle.PersonalInfo",
			"tradle.Residence"
		],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"productType": {
				"type": "string",
				"readOnly": true,
				"displayName": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			}
		}
	};

/***/ },

/***/ 1487:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.EnergyLabel",
		"title": "Energy Label",
		"subClassOf": "tradle.Enum",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"energyLabel": {
				"displayName": true,
				"type": "string"
			}
		}
	};

/***/ },

/***/ 1488:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Enum",
		"title": "Enum",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			}
		}
	};

/***/ },

/***/ 1489:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Exchange",
		"title": "Exchange",
		"type": "tradle.Model",
		"subClassOf": "tradle.Enum",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"exchange": {
				"displayName": true,
				"type": "string"
			}
		}
	};

/***/ },

/***/ 1490:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.ExemptStatus",
		"title": "Exempt Status",
		"type": "tradle.Model",
		"subClassOf": "tradle.Enum",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"exemptStatus": {
				"displayName": true,
				"type": "string"
			}
		}
	};

/***/ },

/***/ 1491:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.File",
		"type": "tradle.Model",
		"title": "File",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"url": {
				"type": "string",
				"readOnly": true
			},
			"size": {
				"type": "number",
				"readOnly": true
			},
			"name": {
				"type": "string",
				"readOnly": true
			},
			"mimeType": {
				"type": "string",
				"readOnly": true
			}
		},
		"required": [
			"name",
			"mimeType",
			"url",
			"size"
		]
	};

/***/ },

/***/ 1492:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.FinancialProduct",
		"type": "tradle.Model",
		"title": "Financial Product",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"organization": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Organization"
			}
		},
		"viewCols": [
			"_t",
			"organization"
		]
	};

/***/ },

/***/ 1493:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Financials",
		"type": "tradle.Model",
		"title": "Financials",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"accountingPeriodFrom": {
				"type": "date"
			},
			"accountingPeriodTo": {
				"type": "date"
			},
			"theseAccountsAre": {
				"type": "string"
			},
			"currency": {
				"type": "object",
				"ref": "tradle.Currency"
			},
			"companyLegalStatus": {
				"type": "string"
			},
			"photos": {
				"type": "array",
				"title": "Document snapshots",
				"items": {
					"type": "object",
					"properties": {
						"tags": {
							"type": "string",
							"skipLabel": true
						},
						"url": {
							"type": "string",
							"readOnly": true
						},
						"width": {
							"type": "number",
							"readOnly": true
						},
						"height": {
							"type": "number",
							"readOnly": true
						}
					}
				},
				"required": [
					"title",
					"url"
				]
			}
		},
		"required": [
			"theseAccountsAre"
		],
		"viewCols": [
			"theseAccountsAre",
			"accountingPeriodFrom",
			"accountingPeriodTo",
			"currency",
			"companyLegalStatus",
			"photos"
		]
	};

/***/ },

/***/ 1494:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.FineArtInsurance",
		"type": "tradle.Model",
		"title": "Fine Art Insurance",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.FinancialProduct",
		"forms": [
			"tradle.PersonalInfo",
			"tradle.ArtworkInfo"
		],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			}
		}
	};

/***/ },

/***/ 1495:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.ForestNotice",
		"type": "tradle.Model",
		"title": "Forest Notice",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.FinancialProduct",
		"forms": [],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"productType": {
				"type": "string",
				"readOnly": true,
				"displayName": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			}
		}
	};

/***/ },

/***/ 1496:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.ForgetMe",
		"title": "Forget Me",
		"interfaces": [
			"tradle.Message"
		],
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"time": {
				"type": "date",
				"readOnly": true
			},
			"message": {
				"type": "string"
			}
		},
		"viewCols": [
			"message"
		],
		"required": []
	};

/***/ },

/***/ 1497:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.ForgotYou",
		"title": "Forgot You",
		"interfaces": [
			"tradle.Message"
		],
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"time": {
				"type": "date",
				"readOnly": true
			},
			"message": {
				"type": "string"
			}
		},
		"viewCols": [
			"message"
		],
		"required": []
	};

/***/ },

/***/ 1498:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Form",
		"title": "Form",
		"abstract": true,
		"type": "tradle.Model",
		"interfaces": [
			"tradle.Message"
		],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			}
		}
	};

/***/ },

/***/ 1499:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.FormError",
		"title": "Form Error",
		"interfaces": [
			"tradle.Message"
		],
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"time": {
				"type": "date",
				"readOnly": true
			},
			"message": {
				"type": "string"
			},
			"prefill": {
				"type": "object",
				"ref": "tradle.Form",
				"readOnly": true
			},
			"prefilled": {
				"type": "object",
				"range": "json"
			},
			"errors": {
				"type": "array",
				"items": {
					"type": "object",
					"properties": {
						"name": {
							"type": "string"
						},
						"error": {
							"type": "string"
						}
					}
				}
			}
		},
		"viewCols": [
			"message",
			"errors"
		],
		"required": [
			"prefill",
			"errors",
			"message"
		]
	};

/***/ },

/***/ 1500:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.FormRequest",
		"type": "tradle.Model",
		"title": "Form Request",
		"autoCreate": true,
		"interfaces": [
			"tradle.Message"
		],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"ref": "tradle.Identity",
				"displayName": true,
				"readOnly": true
			},
			"message": {
				"type": "string",
				"displayName": true
			},
			"product": {
				"type": "string",
				"readOnly": true
			},
			"form": {
				"type": "string",
				"readOnly": true
			},
			"time": {
				"type": "date",
				"readOnly": true
			},
			"welcome": {
				"type": "boolean",
				"readOnly": true
			},
			"verifiers": {
				"type": "array",
				"inlined": true,
				"items": {
					"ref": "tradle.ServiceProvider"
				}
			},
			"prefill": {
				"type": "object",
				"ref": "tradle.Form",
				"readOnly": true
			},
			"requireRawData": {
				"type": "boolean"
			}
		},
		"required": [
			"to",
			"message",
			"form"
		],
		"viewCols": [
			"message",
			"form",
			"product",
			"time"
		]
	};

/***/ },

/***/ 1501:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.FormationType",
		"title": "Formation Type",
		"type": "tradle.Model",
		"subClassOf": "tradle.Enum",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"formationType": {
				"displayName": true,
				"type": "string"
			}
		}
	};

/***/ },

/***/ 1502:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Funds",
		"title": "Funds",
		"type": "tradle.Model",
		"subClassOf": "tradle.Form",
		"interfaces": [
			"tradle.Message",
			"tradle.Document",
			"tradle.Verifiable"
		],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"statement": {
				"type": "string"
			},
			"confirmation": {
				"type": "boolean"
			}
		},
		"required": [
			"statement",
			"confirmation"
		],
		"viewCols": [
			"statement",
			"confirmation"
		]
	};

/***/ },

/***/ 1503:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.GovernmentIdType",
		"type": "tradle.Model",
		"subClassOf": "tradle.Enum",
		"title": "Government Id Type",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"governmentIdType": {
				"displayName": true,
				"type": "string"
			}
		}
	};

/***/ },

/***/ 1504:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.GuestSessionProof",
		"title": "Guest Session Proof",
		"interfaces": [
			"tradle.Message"
		],
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"time": {
				"type": "date",
				"readOnly": true
			},
			"session": {
				"type": "string"
			}
		},
		"viewCols": [
			"session"
		],
		"required": [
			"session"
		]
	};

/***/ },

/***/ 1505:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.HealthInsurance",
		"title": "Health Insurance",
		"interfaces": [
			"tradle.Message"
		],
		"type": "tradle.Model",
		"forms": [
			"tradle.AboutYou",
			"tradle.YourMoney"
		],
		"subClassOf": "tradle.FinancialProduct",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			}
		}
	};

/***/ },

/***/ 1506:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.HomeImprovement",
		"title": "Home Improvement",
		"interfaces": [
			"tradle.Message"
		],
		"type": "tradle.Model",
		"forms": [
			"tradle.AboutYou",
			"tradle.YourMoney",
			"tradle.MortgageLoanDetail"
		],
		"subClassOf": "tradle.FinancialProduct",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			}
		}
	};

/***/ },

/***/ 1507:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.HomeInsurance",
		"title": "Home Insurance",
		"type": "tradle.Model",
		"subClassOf": "tradle.FinancialProduct",
		"interfaces": [
			"tradle.Message"
		],
		"forms": [
			"tradle.AboutYou",
			"tradle.PropertyInformation"
		],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"verifications": {
				"type": "array",
				"readOnly": true,
				"items": {
					"backlink": "document",
					"ref": "tradle.Verification"
				}
			},
			"referencedBy": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.SimpleMessage"
			}
		}
	};

/***/ },

/***/ 1508:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.HowToFund",
		"title": "How To Fund",
		"subClassOf": "tradle.Enum",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"howToFund": {
				"displayName": true,
				"type": "string"
			}
		},
		"required": [
			"howToFund"
		]
	};

/***/ },

/***/ 1509:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.IDCardType",
		"title": "ID Card Type",
		"subClassOf": "tradle.Enum",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"idCardType": {
				"displayName": true,
				"type": "string"
			}
		}
	};

/***/ },

/***/ 1510:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.ISAs",
		"title": "ISAs",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			}
		}
	};

/***/ },

/***/ 1511:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.IdentificationDetail",
		"type": "tradle.Model",
		"title": "Identification Detail",
		"subClassOf": "tradle.Form",
		"interfaces": [
			"tradle.Message"
		],
		"style": {
			"backgroundColor": "#EBE1FA"
		},
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"typeOfIdentityDocument": {
				"type": "object",
				"ref": "tradle.IdentityDocumentType"
			},
			"documentNumber": {
				"type": "number",
				"displayName": true
			},
			"dateOfIssue": {
				"type": "date",
				"maxDate": "today",
				"minDate": "10 years before"
			},
			"dateOfExpiry": {
				"type": "date",
				"maxDate": "10 years after",
				"minDate": "tomorrow",
				"displayName": true
			},
			"issuingAuthority": {
				"type": "string"
			},
			"issuingCountry": {
				"type": "object",
				"ref": "tradle.Country"
			},
			"photos": {
				"type": "array",
				"range": "photo",
				"title": "Document Snapshots",
				"inlined": true,
				"items": {
					"ref": "tradle.Photo"
				}
			}
		},
		"editCols": [
			"typeOfIdentityDocument",
			"documentNumber",
			"issuingAuthority",
			"dateOfIssue",
			"dateOfExpiry",
			"issuingCountry",
			"photos"
		],
		"required": [
			"typeOfIdentityDocument",
			"documentNumber",
			"issuingAuthority",
			"dateOfIssue",
			"dateOfExpiry",
			"issuingCountry",
			"photos"
		],
		"viewCols": [
			"typeOfIdentityDocument",
			"documentNumber",
			"issuingAuthority",
			"dateOfIssue",
			"dateOfExpiry",
			"issuingCountry",
			"photos"
		]
	};

/***/ },

/***/ 1512:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Identity",
		"type": "tradle.Model",
		"title": "Identity",
		"plural": "Identities",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"pubkeys": {
				"type": "array",
				"readOnly": true,
				"items": {
					"type": "object",
					"properties": {
						"curve": {
							"type": "string"
						},
						"fingerprint": {
							"type": "string"
						},
						"label": {
							"type": "string"
						},
						"networkName": {
							"type": "string"
						},
						"purpose": {
							"type": "string"
						},
						"type": {
							"type": "string"
						},
						"value": {
							"type": "string"
						}
					},
					"required": [
						"type",
						"fingerprint",
						"value"
					]
				}
			}
		},
		"required": [
			"pubkeys"
		]
	};

/***/ },

/***/ 1513:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.IdentityDocumentType",
		"title": "Identity document type",
		"subClassOf": "tradle.Enum",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"documentType": {
				"displayName": true,
				"type": "string"
			}
		},
		"required": [
			"documentType"
		]
	};

/***/ },

/***/ 1514:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.IdentityPublishRequest",
		"title": "Identity Publish Request",
		"interfaces": [
			"tradle.Message"
		],
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"identity": {
				"type": "object",
				"ref": "tradle.Identity"
			},
			"name": {
				"type": "string"
			}
		},
		"viewCols": [
			"identity"
		]
	};

/***/ },

/***/ 1515:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.IncomeProtectionInsurance",
		"title": "Income Protection Insurance",
		"interfaces": [
			"tradle.Message"
		],
		"type": "tradle.Model",
		"forms": [
			"tradle.AboutYou",
			"tradle.YourMoney"
		],
		"subClassOf": "tradle.FinancialProduct",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			}
		}
	};

/***/ },

/***/ 1516:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Income",
		"title": "Income",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"sourceOfIncome": {
				"type": "object",
				"ref": "tradle.SourceOfIncome"
			},
			"nameOfEmployer": {
				"type": "string"
			},
			"residenceOfEmployer": {
				"type": "string"
			},
			"occupation": {
				"type": "string"
			},
			"kindOfEngagement": {
				"type": "object",
				"ref": "tradle.KindOfEngagement"
			},
			"startDate": {
				"type": "date"
			},
			"yearsOfSelfEmployment": {
				"type": "number"
			},
			"grossYearlyIncome": {
				"type": "object",
				"ref": "tradle.Money"
			},
			"holidayMoney": {
				"type": "object",
				"ref": "tradle.Money"
			},
			"provisionalIncome": {
				"type": "object",
				"ref": "tradle.Money"
			},
			"additionalMonthOfPayment": {
				"type": "object",
				"ref": "tradle.Money"
			},
			"irregularityCompensation": {
				"type": "object",
				"ref": "tradle.Money"
			},
			"overtimeCompensation": {
				"type": "object",
				"ref": "tradle.Money"
			},
			"bonus": {
				"type": "object",
				"ref": "tradle.Money"
			},
			"totalIncome": {
				"type": "object",
				"ref": "tradle.Money"
			}
		},
		"required": [
			"sourceOfIncome",
			"nameOfEmployer",
			"residenceOfEmployer",
			"startDate",
			"kindOfEngagement",
			"grossYearlyIncome"
		],
		"viewCols": [
			"sourceOfIncome",
			"nameOfEmployer",
			"residenceOfEmployer",
			"startDate",
			"kindOfEngagement",
			"grossYearlyIncome",
			"holidayMoney",
			"provisionalIncome",
			"additionalMonthOfPayment",
			"overtimeCompensation",
			"bonus",
			"totalIncome"
		]
	};

/***/ },

/***/ 1517:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.IndividualOwners",
		"type": "tradle.Model",
		"title": "Individual Owners",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"firstName": {
				"type": "string"
			},
			"lastName": {
				"type": "string"
			},
			"dateOfBirth": {
				"type": "date"
			},
			"nationality": {
				"type": "object",
				"ref": "tradle.Nationality"
			},
			"shareholding": {
				"type": "number",
				"units": "%"
			},
			"startDate": {
				"type": "date"
			},
			"photos": {
				"type": "array",
				"title": "Document snapshots",
				"items": {
					"type": "object",
					"properties": {
						"tags": {
							"type": "string",
							"skipLabel": true
						},
						"url": {
							"type": "string",
							"readOnly": true
						},
						"width": {
							"type": "number",
							"readOnly": true
						},
						"height": {
							"type": "number",
							"readOnly": true
						}
					}
				},
				"required": [
					"title",
					"url"
				]
			}
		},
		"required": [
			"firstName",
			"lastName",
			"shareholding"
		],
		"viewCols": [
			"firstName",
			"lastName",
			"nationality",
			"startDate",
			"shareholding",
			"photos"
		]
	};

/***/ },

/***/ 1518:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.InsuranceInfo",
		"title": "Insurance Information",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"insuredAmount": {
				"type": "object",
				"ref": "tradle.Money"
			},
			"typeOfCoverage": {
				"type": "object",
				"ref": "tradle.TypeOfCoverage"
			},
			"insuranceFee": {
				"type": "object",
				"ref": "tradle.Money"
			},
			"startDate": {
				"type": "date"
			},
			"endDate": {
				"type": "date"
			},
			"insurancePolicyNumber": {
				"type": "string",
				"maxLength": 11
			},
			"policyHolder": {
				"type": "object",
				"ref": "tradle.Identity"
			},
			"insured": {
				"type": "string",
				"title": "Insured person or object"
			},
			"beneficiary": {
				"type": "boolean"
			},
			"pledge": {
				"type": "boolean"
			},
			"pledgedTo": {
				"type": "string"
			}
		}
	};

/***/ },

/***/ 1519:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.InterestType",
		"title": "Interest Type",
		"type": "tradle.Model",
		"subClassOf": "tradle.Enum",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"interestType": {
				"displayName": true,
				"type": "string"
			}
		},
		"required": [
			"interestType"
		]
	};

/***/ },

/***/ 1520:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.InternalInfo",
		"title": "Internal Info",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"CIF": {
				"title": "CIF",
				"type": "string"
			},
			"trueCustomer": {
				"type": "boolean"
			},
			"customerOfWhatBranch": {
				"type": "string"
			},
			"customerType": {
				"type": "string",
				"title": "Customer type #"
			}
		},
		"viewCols": [
			"trueCustomer",
			"customerOfWhatBranch"
		],
		"required": [
			"trueCustomer",
			"customerOfWhatBranch"
		]
	};

/***/ },

/***/ 1521:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Introduction",
		"title": "Introduction",
		"interfaces": [
			"tradle.Message"
		],
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"identity": {
				"type": "object",
				"ref": "tradle.Identity"
			},
			"name": {
				"type": "string"
			},
			"message": {
				"type": "string"
			}
		},
		"viewCols": [
			"message",
			"identity"
		],
		"required": [
			"identity"
		]
	};

/***/ },

/***/ 1522:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.InvestingExperience",
		"title": "Investing Experience",
		"type": "tradle.Model",
		"subClassOf": "tradle.Form",
		"interfaces": [
			"tradle.Message",
			"tradle.Document",
			"tradle.Verifiable"
		],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"investingType": {
				"type": "object",
				"ref": "tradle.InvestingType"
			},
			"evidentiaryDocuments": {
				"type": "object",
				"allowPicturesFromLibrary": true,
				"ref": "tradle.Photo"
			}
		},
		"required": [
			"investingType",
			"evidentiaryDocuments"
		],
		"viewCols": [
			"investingType",
			"evidentiaryDocuments"
		]
	};

/***/ },

/***/ 1523:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.InvestingType",
		"title": "Investing Type",
		"type": "tradle.Model",
		"subClassOf": "tradle.Enum",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"investingType": {
				"displayName": true,
				"type": "string"
			}
		},
		"required": [
			"investingType"
		]
	};

/***/ },

/***/ 1524:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Item",
		"type": "tradle.Model",
		"title": "Item",
		"isInterface": true,
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"container": {
				"type": "object",
				"ref": "tradle.Form"
			}
		}
	};

/***/ },

/***/ 1525:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.KeyStaff",
		"type": "tradle.Model",
		"title": "Key Staff",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"title": {
				"type": "string"
			},
			"firstName": {
				"type": "string"
			},
			"lastName": {
				"type": "string"
			},
			"role": {
				"type": "string"
			},
			"name": {
				"type": "string",
				"displayAs": "{1} {2} {3}",
				"group": [
					"title",
					"firstName",
					"lastName"
				],
				"readOnly": true,
				"displayName": true
			},
			"photos": {
				"type": "array",
				"range": "photo",
				"inlined": true,
				"items": {
					"ref": "tradle.Photo"
				}
			}
		},
		"required": [
			"title",
			"firstName",
			"lastName"
		],
		"viewCols": [
			"name",
			"role",
			"photos"
		]
	};

/***/ },

/***/ 1526:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.KindOfConstruction",
		"title": "Kind Of Construction",
		"type": "tradle.Model",
		"subClassOf": "tradle.Enum",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"kindOfConstruction": {
				"displayName": true,
				"type": "string"
			}
		}
	};

/***/ },

/***/ 1527:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.KindOfEngagement",
		"title": "Kind Of Engagement",
		"type": "tradle.Model",
		"subClassOf": "tradle.Enum",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"kindOfEngagement": {
				"displayName": true,
				"type": "string"
			}
		}
	};

/***/ },

/***/ 1528:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.KindOfHouse",
		"title": "Kind Of House",
		"type": "tradle.Model",
		"subClassOf": "tradle.Enum",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"kindOfHouse": {
				"displayName": true,
				"type": "string"
			}
		}
	};

/***/ },

/***/ 1529:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.KindOfInsurance",
		"title": "Kind Of Insurance",
		"type": "tradle.Model",
		"subClassOf": "tradle.Enum",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"kindOfInsurance": {
				"displayName": true,
				"type": "string"
			}
		}
	};

/***/ },

/***/ 1530:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.KindOfObligation",
		"title": "Kind of Obligation",
		"type": "tradle.Model",
		"subClassOf": "tradle.Enum",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"kindOfObligation": {
				"displayName": true,
				"type": "string"
			}
		}
	};

/***/ },

/***/ 1531:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Language",
		"subClassOf": "tradle.Enum",
		"title": "Language",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"language": {
				"displayName": true,
				"type": "string"
			}
		},
		"required": [
			"language"
		]
	};

/***/ },

/***/ 1532:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Licences",
		"type": "tradle.Model",
		"title": "Licences",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"name": {
				"type": "string"
			},
			"territory": {
				"type": "string"
			},
			"regulator": {
				"type": "string"
			},
			"licenceName": {
				"type": "string"
			},
			"licenceNumber": {
				"type": "string"
			},
			"nameOfLicence": {
				"type": "string",
				"title": "Name on Licence"
			},
			"expiryDate": {
				"type": "date"
			},
			"photos": {
				"type": "array",
				"title": "Document snapshots",
				"items": {
					"type": "object",
					"properties": {
						"tags": {
							"type": "string",
							"skipLabel": true
						},
						"url": {
							"type": "string",
							"readOnly": true
						},
						"width": {
							"type": "number",
							"readOnly": true
						},
						"height": {
							"type": "number",
							"readOnly": true
						}
					}
				},
				"required": [
					"title",
					"url"
				]
			}
		},
		"required": [
			"name",
			"licenceNumber",
			"expiryDate"
		],
		"viewCols": [
			"name",
			"licenceNumber",
			"expiryDate"
		]
	};

/***/ },

/***/ 1533:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.LifeInsurance",
		"interfaces": [
			"tradle.Message"
		],
		"title": "Life Insurance",
		"type": "tradle.Model",
		"subClassOf": "tradle.FinancialProduct",
		"forms": [
			"tradle.PersonalInfo",
			"tradle.Residence",
			"tradle.ORV"
		],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			}
		}
	};

/***/ },

/***/ 1534:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.ORV",
		"title": "Life Insurance",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"startDate": {
				"type": "date"
			},
			"endDate": {
				"type": "date"
			},
			"insuredAmount": {
				"type": "object",
				"ref": "tradle.Money",
				"description": "Insured amount at date insurance starts"
			},
			"typeOfCoverage": {
				"type": "object",
				"ref": "tradle.TypeOfCoverage"
			},
			"policyHolder": {
				"type": "object",
				"ref": "tradle.PersonalInfo",
				"allowToAdd": true
			},
			"insuredPersons": {
				"type": "array",
				"allowToAdd": true,
				"items": {
					"type": "object",
					"ref": "tradle.PersonalInfo"
				}
			},
			"beneficiary": {
				"type": "string",
				"defaultValue": "Standard"
			},
			"nonSmokersTariff": {
				"type": "boolean",
				"description": "Non-smokers tariff (did not smoke for more than 2 years)",
				"title": "Non-smokers tariff"
			},
			"bankAccountNumber": {
				"type": "string"
			}
		},
		"required": [
			"startDate",
			"endDate",
			"insuredAmount",
			"policyHolder",
			"insuredPersons",
			"beneficiary",
			"nonSmokersTariff",
			"bankAccountNumber"
		],
		"viewCols": [
			"startDate",
			"endDate",
			"insuredAmount",
			"policyHolder",
			"insuredPersons",
			"beneficiary",
			"nonSmokersTariff",
			"bankAccountNumber"
		]
	};

/***/ },

/***/ 1535:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.LoanDetail",
		"title": "Loan Detail",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"amount": {
				"type": "object",
				"ref": "tradle.Money"
			},
			"duration": {
				"type": "number",
				"units": "months"
			}
		},
		"required": [
			"amount",
			"duration"
		],
		"viewCols": [
			"amount",
			"duration"
		]
	};

/***/ },

/***/ 1536:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.LoanPart",
		"title": "Loan Part",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"amount": {
				"type": "object",
				"ref": "tradle.Money"
			},
			"interestType": {
				"type": "object",
				"ref": "tradle.InterestType"
			},
			"interestPercentage": {
				"type": "number",
				"units": "%",
				"min": "0",
				"max": "100"
			},
			"monthlyPayment": {
				"type": "object",
				"ref": "tradle.Money",
				"description": "Amount paid for saving/insurance part in loan construction"
			},
			"monthlyPremium": {
				"type": "object",
				"ref": "tradle.Money"
			},
			"repaymentType": {
				"type": "object",
				"ref": "tradle.RepaymentType"
			},
			"loanPartID": {
				"type": "string",
				"title": "Loan Part ID"
			},
			"duration": {
				"type": "number",
				"units": "years"
			}
		},
		"required": [
			"amount",
			"repaymentType",
			"interestType",
			"interestPercentage",
			"monthlyPremium",
			"monthlyPayment",
			"duration"
		],
		"viewCols": [
			"amount",
			"repaymentType",
			"interestType",
			"interestPercentage",
			"monthlyPayment",
			"monthlyPremium",
			"duration"
		],
		"hidden": [
			"loanPartID"
		]
	};

/***/ },

/***/ 1537:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.LoanTypes",
		"title": "Loan Types",
		"type": "tradle.Model",
		"subClassOf": "tradle.Enum",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"loanType": {
				"displayName": true,
				"type": "string"
			}
		}
	};

/***/ },

/***/ 1538:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Location",
		"title": "Location",
		"subClassOf": "tradle.Enum",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"location": {
				"displayName": true,
				"type": "string"
			}
		},
		"required": [
			"location"
		]
	};

/***/ },

/***/ 1539:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Major",
		"title": "Major",
		"type": "tradle.Model",
		"subClassOf": "tradle.Enum",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"major": {
				"displayName": true,
				"type": "string"
			}
		},
		"required": [
			"major"
		]
	};

/***/ },

/***/ 1540:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.MaritalStatus",
		"title": "Marital Status",
		"type": "tradle.Model",
		"subClassOf": "tradle.Enum",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"status": {
				"displayName": true,
				"type": "string"
			}
		},
		"required": [
			"status"
		]
	};

/***/ },

/***/ 1541:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.MediaSnippet",
		"type": "tradle.Model",
		"title": "Media Snippet",
		"subClassOf": "tradle.Form",
		"interfaces": [
			"tradle.Message",
			"tradle.Verifiable",
			"tradle.Document"
		],
		"verifiableAspects": {
			"authenticity": {
				"methods": [
					"tradle.VisualVerificationMethod"
				]
			}
		},
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"headline": {
				"type": "string"
			},
			"summary": {
				"type": "string"
			},
			"url": {
				"type": "string",
				"range": "url"
			},
			"publisher": {
				"type": "string"
			},
			"datePublished": {
				"type": "date"
			},
			"photos": {
				"type": "array",
				"range": "photo",
				"inlined": true,
				"items": {
					"ref": "tradle.Photo"
				}
			}
		},
		"required": [
			"summary",
			"publisher",
			"datePublished"
		],
		"gridCols": [
			"headline",
			"publisher",
			"datePublished"
		],
		"viewCols": [
			"headline",
			"summary",
			"publisher",
			"datePublished",
			"photos"
		]
	};

/***/ },

/***/ 1542:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.MerkleLeaf",
		"type": "tradle.Model",
		"title": "Merkle Leaf",
		"properties": {
			"index": {
				"type": "number"
			},
			"data": {
				"type": "string"
			}
		},
		"required": [
			"index",
			"data"
		]
	};

/***/ },

/***/ 1543:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.MerkleNode",
		"type": "tradle.Model",
		"title": "Merkle Node",
		"properties": {
			"index": {
				"type": "number"
			},
			"hash": {
				"type": "string"
			}
		},
		"required": [
			"index",
			"hash"
		]
	};

/***/ },

/***/ 1544:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Message",
		"type": "tradle.Model",
		"title": "Message",
		"isInterface": true,
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"message": {
				"type": "string",
				"displayName": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"ref": "tradle.Identity",
				"displayName": true
			},
			"time": {
				"type": "date",
				"readOnly": true,
				"displayName": true
			},
			"photos": {
				"type": "array",
				"items": {
					"type": "object",
					"properties": {
						"tags": {
							"type": "string",
							"skipLabel": true
						},
						"url": {
							"type": "string",
							"readOnly": true
						}
					}
				},
				"required": [
					"title",
					"url"
				]
			},
			"relatedTo": {
				"type": "object",
				"ref": "tradle.Message"
			}
		},
		"viewCols": [
			"message"
		]
	};

/***/ },

/***/ 1545:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Method",
		"type": "tradle.Model",
		"title": "Method",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"aspect": {
				"type": "string",
				"readOnly": true
			}
		},
		"required": [
			"aspect"
		]
	};

/***/ },

/***/ 1546:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.ModelsPack",
		"title": "Models Pack",
		"interfaces": [
			"tradle.Message"
		],
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"models": {
				"type": "array",
				"readOnly": true,
				"items": {
					"type": "object",
					"ref": "tradle.Model"
				}
			}
		}
	};

/***/ },

/***/ 1547:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Money",
		"type": "tradle.Model",
		"title": "Money",
		"inlined": true,
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"value": {
				"type": "number"
			},
			"currency": {
				"type": "enum",
				"oneOf": [
					{
						"USD": "$"
					},
					{
						"GBP": "£"
					},
					{
						"EUR": "€"
					},
					{
						"KWD": "د.ك"
					},
					{
						"ANG": "ƒ"
					},
					{
						"HNL": "L"
					},
					{
						"MYR": "RM"
					},
					{
						"COP": "$"
					},
					{
						"PHP": "₱"
					},
					{
						"MDL": "L"
					},
					{
						"MRO": "UM"
					},
					{
						"INR": "₨"
					},
					{
						"CRC": "₡"
					},
					{
						"ISK": "kr"
					},
					{
						"MXN": "$"
					},
					{
						"DZD": "د.ج"
					},
					{
						"CLP": "$"
					},
					{
						"JMD": "$"
					},
					{
						"QAR": "ر.ق"
					},
					{
						"LRD": "$"
					},
					{
						"LVL": "Ls"
					},
					{
						"GIP": "£"
					},
					{
						"GEL": "ლ"
					},
					{
						"AMD": "դր."
					},
					{
						"MGA": "MGA"
					},
					{
						"MUR": "₨"
					},
					{
						"CAD": "$"
					},
					{
						"BMD": "$"
					},
					{
						"ZMK": "ZK"
					},
					{
						"IRR": "﷼"
					},
					{
						"BZD": "$"
					},
					{
						"SBD": "$"
					},
					{
						"MNT": "₮"
					},
					{
						"TOP": "T$"
					},
					{
						"TTD": "$"
					},
					{
						"GMD": "D"
					},
					{
						"KYD": "$"
					},
					{
						"SYP": "£"
					},
					{
						"PGK": "K"
					},
					{
						"XOF": "Fr"
					},
					{
						"THB": "฿"
					},
					{
						"LAK": "₭"
					},
					{
						"EGP": "£"
					},
					{
						"BGN": "лв"
					},
					{
						"SRD": "$"
					},
					{
						"SHP": "£"
					},
					{
						"UAH": "₴"
					},
					{
						"VUV": "Vt"
					},
					{
						"JOD": "د.ا"
					},
					{
						"KRW": "₩"
					},
					{
						"MMK": "K"
					},
					{
						"PYG": "₲"
					},
					{
						"TMM": "m"
					},
					{
						"TJS": "ЅМ"
					},
					{
						"PLN": "zł"
					},
					{
						"BBD": "$"
					},
					{
						"HRK": "kn"
					},
					{
						"NIO": "C$"
					},
					{
						"BYR": "Br"
					},
					{
						"RUB": "р."
					},
					{
						"GYD": "$"
					},
					{
						"ARS": "$"
					},
					{
						"RWF": "Fr"
					},
					{
						"CHF": "Fr"
					},
					{
						"AED": "د.إ"
					},
					{
						"MWK": "MK"
					},
					{
						"LBP": "ل.ل"
					},
					{
						"TWD": "$"
					},
					{
						"HTG": "G"
					},
					{
						"NPR": "₨"
					},
					{
						"CDF": "Fr"
					},
					{
						"LSL": "L"
					},
					{
						"LKR": "ரூ"
					},
					{
						"UZS": "UZS"
					},
					{
						"IQD": "ع.د"
					},
					{
						"PKR": "₨"
					},
					{
						"ILS": "₪"
					},
					{
						"BHD": "ب.د"
					},
					{
						"BOB": "Bs."
					},
					{
						"MAD": "د.م."
					},
					{
						"MKD": "ден"
					},
					{
						"JPY": "¥"
					},
					{
						"SCR": "₨"
					},
					{
						"BTN": "BTN"
					},
					{
						"UYU": "$"
					},
					{
						"SZL": "L"
					},
					{
						"CZK": "Kč"
					},
					{
						"STD": "Db"
					},
					{
						"BSD": "$"
					},
					{
						"FJD": "$"
					},
					{
						"ALL": "L"
					},
					{
						"KES": "Sh"
					},
					{
						"SAR": "ر.س"
					},
					{
						"OMR": "ر.ع."
					},
					{
						"KPW": "₩"
					},
					{
						"SOS": "Sh"
					},
					{
						"NZD": "$"
					},
					{
						"SGD": "$"
					},
					{
						"KZT": "Т"
					},
					{
						"BND": "$"
					},
					{
						"LTL": "Lt"
					},
					{
						"CUP": "$"
					},
					{
						"GTQ": "Q"
					},
					{
						"TND": "د.ت"
					},
					{
						"BAM": "KM"
					},
					{
						"ZAR": "R"
					},
					{
						"AOA": "Kz"
					},
					{
						"HUF": "Ft"
					},
					{
						"PAB": "B/."
					},
					{
						"RON": "RON"
					},
					{
						"AFN": "؋"
					},
					{
						"EEK": "KR"
					},
					{
						"BIF": "Fr"
					},
					{
						"WST": "T"
					},
					{
						"DJF": "Fr"
					},
					{
						"MOP": "P"
					},
					{
						"KMF": "Fr"
					},
					{
						"BRL": "R$"
					},
					{
						"TZS": "Sh"
					},
					{
						"SEK": "kr"
					},
					{
						"HKD": "$"
					},
					{
						"XAF": "Fr"
					},
					{
						"GNF": "Fr"
					},
					{
						"MTL": "₤"
					},
					{
						"CVE": "$"
					},
					{
						"NOK": "kr"
					},
					{
						"ETB": "ETB"
					},
					{
						"IDR": "Rp"
					},
					{
						"SLL": "Le"
					},
					{
						"BWP": "P"
					},
					{
						"DKK": "kr"
					},
					{
						"CNY": "¥"
					},
					{
						"CSD": "CSD"
					},
					{
						"NGN": "₦"
					},
					{
						"VND": "₫"
					},
					{
						"VEB": "Bs"
					},
					{
						"MZN": "MZN"
					},
					{
						"BDT": "৳"
					},
					{
						"CYP": "£"
					},
					{
						"ERN": "ERN"
					},
					{
						"YER": "﷼"
					},
					{
						"GPD": "£"
					},
					{
						"AUD": "$"
					},
					{
						"FKP": "£"
					},
					{
						"SDD": "SDD"
					},
					{
						"NAD": "$"
					},
					{
						"KGS": "KGS"
					},
					{
						"XCD": "$"
					},
					{
						"SKK": "Sk"
					},
					{
						"GHC": "₵"
					},
					{
						"XPF": "Fr"
					},
					{
						"MVR": "ރ."
					},
					{
						"KHR": "៛"
					},
					{
						"LYD": "ل.د"
					},
					{
						"AWG": "ƒ"
					},
					{
						"AZN": "AZN"
					},
					{
						"ZWD": "$"
					},
					{
						"PEN": "S/."
					},
					{
						"DOP": "$"
					},
					{
						"UGX": "Sh"
					},
					{
						"TRY": "₤"
					}
				]
			}
		},
		"required": [
			"value",
			"currency"
		]
	};

/***/ },

/***/ 1548:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Mortgage",
		"title": "Mortgage",
		"interfaces": [
			"tradle.Message"
		],
		"type": "tradle.Model",
		"forms": [
			"tradle.AboutYou",
			"tradle.YourMoney",
			"tradle.MortgageLoanDetail"
		],
		"subClassOf": "tradle.FinancialProduct",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			}
		}
	};

/***/ },

/***/ 1549:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.MortgageDetail",
		"title": "Mortgage Detail",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"loanType": {
				"type": "object",
				"ref": "tradle.LoanTypes"
			},
			"applicationDate": {
				"type": "date"
			},
			"startMortgageDate": {
				"type": "date"
			},
			"commercialProduct": {
				"type": "object",
				"title": "Product",
				"ref": "tradle.CommercialProduct"
			},
			"mortgageGuarantee": {
				"type": "object",
				"ref": "tradle.MortgageGuarantee"
			},
			"totalAmount": {
				"type": "object",
				"ref": "tradle.Money"
			},
			"intermediary": {
				"type": "string"
			},
			"notary": {
				"type": "string"
			},
			"duration": {
				"type": "number",
				"units": "years"
			}
		},
		"required": [
			"loanType",
			"startMortgageDate",
			"mortgageGuarantee",
			"totalAmount",
			"intermediary",
			"commercialProduct",
			"notary",
			"duration"
		],
		"viewCols": [
			"loanType",
			"startMortgageDate",
			"mortgageGuarantee",
			"totalAmount",
			"applicationDate",
			"commercialProduct",
			"notary",
			"intermediary",
			"duration"
		],
		"hidden": [
			"applicationDate"
		]
	};

/***/ },

/***/ 1550:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.MortgageGuarantee",
		"title": "Mortgage Guarantee",
		"type": "tradle.Model",
		"subClassOf": "tradle.Enum",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"mortgageGuarantee": {
				"displayName": true,
				"type": "string"
			}
		}
	};

/***/ },

/***/ 1551:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.MortgageLoanDetail",
		"title": "Mortgage Loan Details",
		"interfaces": [
			"tradle.Message"
		],
		"type": "tradle.Model",
		"subClassOf": "tradle.Form",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"purposeOfMortgageLoan": {
				"type": "object",
				"ref": "tradle.PurposeOfMortgageLoan"
			},
			"totalAmountRequired": {
				"type": "object",
				"ref": "tradle.Money"
			},
			"totalValueOfProperty": {
				"type": "object",
				"ref": "tradle.Money"
			},
			"propertyStreetAddress": {
				"type": "string"
			},
			"region": {
				"type": "string"
			},
			"city": {
				"type": "string"
			},
			"postalCode": {
				"type": "string"
			},
			"country": {
				"type": "object",
				"ref": "tradle.Country"
			},
			"formattedAddress": {
				"type": "string",
				"displayAs": "{1}, {2}, {3} {4}, {5}",
				"group": [
					"propertyStreetAddress",
					"city",
					"region",
					"postalCode",
					"country"
				],
				"title": "Property Address",
				"readOnly": true
			},
			"propertyType": {
				"type": "object",
				"ref": "tradle.PropertyType"
			},
			"sizeOfProperty": {
				"type": "string"
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			}
		},
		"viewCols": [
			"formattedAddress",
			"purposeOfMortgageLoan",
			"totalAmountRequired",
			"totalValueOfProperty",
			"propertyType",
			"sizeOfProperty"
		]
	};

/***/ },

/***/ 1552:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.MortgageProduct",
		"title": "Mortgage",
		"interfaces": [
			"tradle.Message"
		],
		"type": "tradle.Model",
		"forms": [
			"tradle.PersonalInfo",
			"tradle.Residence",
			"tradle.SocialSecurityNumber",
			"tradle.Collateral",
			"tradle.Income",
			"tradle.ObligationsDebts",
			"tradle.Posessions",
			"tradle.MortgageDetail",
			"tradle.LoanPart",
			"tradle.OtherCollaterals",
			"tradle.MyLifeInsurance"
		],
		"subClassOf": "tradle.FinancialProduct",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			}
		}
	};

/***/ },

/***/ 1553:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.MyCoverholderApproval",
		"title": "My Coverholder Approval",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.MyProduct",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"legalName": {
				"type": "string"
			},
			"piInsurerName": {
				"title": "PI Insurer Name",
				"type": "string"
			},
			"expiryDateOfCover": {
				"type": "date"
			},
			"licenceNumber": {
				"type": "string"
			}
		},
		"required": [
			"legalName",
			"piInsurerName",
			"expiryDateOfCover",
			"licenceNumber"
		],
		"viewCols": []
	};

/***/ },

/***/ 1554:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.MyEmployeeOnboarding",
		"title": "My Employee Pass",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.MyProduct",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"entityRole": {
				"type": "string"
			},
			"myProductId": {
				"title": "Employee ID",
				"type": "string"
			},
			"firstName": {
				"type": "string"
			},
			"lastName": {
				"type": "string"
			}
		},
		"required": [
			"entityRole",
			"myProductId"
		],
		"viewCols": [
			"entityRole",
			"myProductId"
		]
	};

/***/ },

/***/ 1555:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.MyFineArtInsurance",
		"title": "My Fine Art Insurance",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.MyProduct",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"myProductId": {
				"title": "Confirmation number",
				"type": "string"
			},
			"policyHolder": {
				"type": "object",
				"ref": "tradle.Identity"
			},
			"artworkName": {
				"type": "string"
			}
		},
		"required": [
			"myProductId",
			"policyHolder",
			"artworkName"
		],
		"viewCols": [
			"myProductId",
			"policyHolder",
			"artworkName"
		]
	};

/***/ },

/***/ 1556:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.MyIdentities",
		"type": "tradle.Model",
		"title": "My Identities",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"currentIdentity": {
				"type": "object",
				"ref": "tradle.Identity",
				"readOnly": true
			},
			"allIdentities": {
				"type": "array",
				"items": {
					"type": "object",
					"ref": "tradle.Identity"
				}
			}
		}
	};

/***/ },

/***/ 1557:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.MyLifeInsurance",
		"title": "My Life Insurance",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.MyProduct",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"myProductId": {
				"title": "Policy number",
				"type": "string"
			},
			"policyHolder": {
				"type": "object",
				"ref": "tradle.Identity"
			},
			"typeOfCoverage": {
				"type": "object",
				"ref": "tradle.TypeOfCoverage"
			},
			"insuredAmount": {
				"type": "object",
				"ref": "tradle.Money",
				"description": "Insured amount at date insurance starts"
			},
			"startDate": {
				"type": "date"
			},
			"endDate": {
				"type": "date"
			}
		},
		"required": [
			"myProductId",
			"policyHolder",
			"typeOfCoverage",
			"insuredAmount",
			"startDate",
			"endDate"
		],
		"viewCols": [
			"myProductId",
			"policyHolder",
			"typeOfCoverage",
			"insuredAmount",
			"startDate",
			"endDate"
		]
	};

/***/ },

/***/ 1558:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.MyMortgageProduct",
		"title": "My Mortgage",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.MyProduct",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"loanType": {
				"type": "object",
				"ref": "tradle.LoanTypes"
			},
			"startMortgageDate": {
				"type": "date"
			},
			"commercialProduct": {
				"type": "object",
				"title": "Product",
				"ref": "tradle.CommercialProduct"
			},
			"totalAmount": {
				"type": "object",
				"ref": "tradle.Money"
			},
			"myProductId": {
				"title": "Mortgage number",
				"type": "string"
			},
			"duration": {
				"type": "number",
				"units": "years"
			}
		},
		"required": [
			"loanType",
			"startMortgageDate",
			"totalAmount",
			"commercialProduct",
			"myProductId",
			"duration"
		],
		"viewCols": [
			"loanType",
			"startMortgageDate",
			"totalAmount",
			"commercialProduct",
			"myProductId",
			"duration"
		]
	};

/***/ },

/***/ 1559:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.MyProduct",
		"title": "My Product",
		"type": "tradle.Model",
		"interfaces": [
			"tradle.Message"
		],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"myProductId": {
				"type": "string"
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			}
		}
	};

/***/ },

/***/ 1560:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.MyTaxesFiledConfirmation",
		"title": "My Taxes Filed Confirmation",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.MyProduct",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"myProductId": {
				"title": "Confirmation number",
				"type": "string"
			},
			"policyHolder": {
				"type": "object",
				"ref": "tradle.Identity"
			},
			"startDate": {
				"type": "date"
			},
			"endDate": {
				"type": "date"
			}
		},
		"required": [
			"myProductId",
			"policyHolder",
			"startDate",
			"endDate"
		],
		"viewCols": [
			"myProductId",
			"policyHolder",
			"startDate",
			"endDate"
		]
	};

/***/ },

/***/ 1561:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.MyWealthManagementAccount",
		"title": "My Wealth Management Account",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.MyProduct",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"myProductId": {
				"title": "Account number",
				"type": "string"
			},
			"policyHolder": {
				"type": "object",
				"ref": "tradle.Identity"
			}
		},
		"required": [
			"myProductId",
			"policyHolder"
		],
		"viewCols": [
			"myProductId",
			"policyHolder"
		]
	};

/***/ },

/***/ 1562:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Name",
		"title": "Name",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"type": "tradle.Model",
		"properties": {
			"givenName": {
				"title": "Given name(s)",
				"type": "string"
			},
			"surname": {
				"type": "string"
			}
		},
		"required": [
			"givenName",
			"surname"
		],
		"viewCols": [
			"givenName",
			"surname"
		]
	};

/***/ },

/***/ 1563:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Nationality",
		"title": "Nationality",
		"subClassOf": "tradle.Enum",
		"type": "tradle.Model",
		"sort": "nationality",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"nationality": {
				"displayName": true,
				"type": "string"
			}
		},
		"required": [
			"nationality"
		]
	};

/***/ },

/***/ 1564:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.NewMessageModel",
		"type": "tradle.Model",
		"title": "New message model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"url": {
				"type": "string",
				"displayName": true
			}
		}
	};

/***/ },

/***/ 1565:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.NextFormRequest",
		"title": "NextFormRequest",
		"interfaces": [
			"tradle.Message"
		],
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"after": {
				"type": "string"
			}
		},
		"viewCols": [
			"after"
		],
		"required": [
			"after"
		]
	};

/***/ },

/***/ 1566:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.NotarizePowerOfAttorney",
		"title": "Notarize Power of Attorney",
		"interfaces": [
			"tradle.Message"
		],
		"type": "tradle.Model",
		"forms": [],
		"subClassOf": "tradle.FinancialProduct",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			}
		}
	};

/***/ },

/***/ 1567:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.NotarizePropertyOwnership",
		"title": "Notarize Property Ownership",
		"interfaces": [
			"tradle.Message"
		],
		"type": "tradle.Model",
		"forms": [
			"tradle.PersonalInfo",
			"tradle.Residence",
			"tradle.PropertyOwnership"
		],
		"subClassOf": "tradle.FinancialProduct",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			}
		}
	};

/***/ },

/***/ 1568:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.ObligationsDebts",
		"title": "Obligations / Debts",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"kindOfObligation": {
				"type": "object",
				"displayName": true,
				"ref": "tradle.KindOfObligation"
			},
			"creditLimit": {
				"type": "object",
				"ref": "tradle.Money"
			},
			"payment": {
				"type": "object",
				"ref": "tradle.Money"
			},
			"paymentPeriod": {
				"type": "object",
				"ref": "tradle.PaymentPeriod"
			},
			"endDate": {
				"type": "date"
			}
		},
		"required": [
			"kindOfObligation",
			"creditLimit",
			"paymentPeriod"
		],
		"viewCols": [
			"kindOfObligation",
			"creditLimit",
			"paymentPeriod",
			"endDate"
		]
	};

/***/ },

/***/ 1569:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Organization",
		"type": "tradle.Model",
		"title": "Organization",
		"sort": "lastMessageTime",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"name": {
				"type": "string",
				"displayName": true
			},
			"email": {
				"type": "string",
				"pattern": "^(([^<>()\\[\\]\\.,;:\\s@\"\\]+(\\.[^<>()\\[\\]\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$",
				"keyboard": "email-address"
			},
			"city": {
				"type": "string"
			},
			"country": {
				"type": "object",
				"ref": "tradle.Country"
			},
			"postalCode": {
				"type": "string"
			},
			"region": {
				"type": "string"
			},
			"street": {
				"type": "string"
			},
			"formattedAddress": {
				"type": "string",
				"displayAs": "{1}, {2}, {3}, {4}",
				"group": [
					"street",
					"city",
					"region",
					"postalCode"
				],
				"title": "Address",
				"readOnly": true
			},
			"contacts": {
				"type": "array",
				"items": {
					"type": "object",
					"ref": "tradle.Profile",
					"backlink": "organization"
				}
			},
			"lastMessage": {
				"type": "string"
			},
			"lastMessageTime": {
				"type": "date"
			},
			"inactive": {
				"type": "boolean"
			},
			"photos": {
				"type": "array",
				"range": "photo",
				"inlined": true,
				"items": {
					"ref": "tradle.Photo"
				}
			},
			"securityCodes": {
				"type": "array",
				"readOnly": true,
				"items": {
					"type": "object",
					"ref": "tradle.SecurityCode",
					"backlink": "organization"
				}
			}
		},
		"required": [
			"name"
		],
		"viewCols": [
			"name",
			"photos"
		],
		"gridCols": [
			"name",
			"lastMessage",
			"lastMessageTime"
		],
		"editCols": [
			"name",
			"street",
			"city",
			"region",
			"country"
		]
	};

/***/ },

/***/ 1570:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.OtherCollaterals",
		"title": "Other Collaterals",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"insuranceCompany": {
				"type": "string"
			},
			"statusOfInsurance": {
				"type": "object",
				"ref": "tradle.StatusOfInsurance"
			},
			"typeOfCoverage": {
				"type": "object",
				"ref": "tradle.TypeOfCoverage"
			},
			"startDate": {
				"type": "date"
			},
			"yearsOfInsurance": {
				"type": "number"
			},
			"amountToTransfer": {
				"type": "object",
				"ref": "tradle.Money",
				"description": "Amount to be transferred by the insurance company when insurance stops earlier"
			},
			"insuredPersons": {
				"type": "array",
				"allowToAdd": true,
				"items": {
					"type": "object",
					"ref": "tradle.PersonalInfo"
				}
			},
			"policyHolder": {
				"type": "array",
				"allowToAdd": true,
				"items": {
					"type": "object",
					"ref": "tradle.PersonalInfo"
				}
			},
			"policyNumber": {
				"type": "string"
			},
			"insuredAmount": {
				"type": "object",
				"ref": "tradle.Money"
			},
			"endDate": {
				"type": "date"
			}
		},
		"required": [
			"insuranceCompany",
			"statusOfInsurance",
			"typeOfCoverage",
			"startDate",
			"endDate",
			"yearsOfInsurance",
			"amountToTransfer",
			"insuredPersons",
			"policyHolder",
			"policyNumber",
			"insuredAmount"
		],
		"viewCols": [
			"insuranceCompany",
			"statusOfInsurance",
			"typeOfCoverage",
			"startDate",
			"yearsOfInsurance",
			"amountToTransfer",
			"insuredPersons",
			"policyHolder",
			"policyNumber",
			"endDate",
			"insuredAmount"
		]
	};

/***/ },

/***/ 1571:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.OwnershipStructure",
		"title": "Ownership Structure",
		"type": "tradle.Model",
		"subClassOf": "tradle.Enum",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"ownershipStructure": {
				"displayName": true,
				"type": "string"
			}
		}
	};

/***/ },

/***/ 1572:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.PairingData",
		"title": "Pairing Data",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"identity": {
				"type": "object",
				"ref": "tradle.Identity"
			},
			"nonce": {
				"type": "string"
			},
			"rendezvous": {
				"type": "object",
				"properties": {
					"url": {
						"type": "string"
					}
				}
			}
		},
		"required": [
			"identity",
			"nonce",
			"rendezvous"
		]
	};

/***/ },

/***/ 1573:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.PairingRequest",
		"title": "Pairing Request",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"identity": {
				"type": "object",
				"ref": "tradle.Identity"
			},
			"auth": {
				"type": "string"
			}
		},
		"required": [
			"identity",
			"auth"
		]
	};

/***/ },

/***/ 1574:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.PairingResponse",
		"title": "Pairing Response",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"identity": {
				"type": "object",
				"ref": "tradle.Identity"
			},
			"prev": {
				"type": "object",
				"ref": "tradle.Identity"
			}
		},
		"required": [
			"identity",
			"prev"
		]
	};

/***/ },

/***/ 1575:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Partial",
		"type": "tradle.Model",
		"title": "Partial",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"resource": {
				"type": "object",
				"ref": "tradle.Message"
			},
			"to": {
				"type": "object",
				"title": "Owner",
				"ref": "tradle.Identity",
				"displayName": true,
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity",
				"displayName": true
			},
			"provider": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Organization",
				"displayName": true
			},
			"root": {
				"type": "object",
				"readOnly": true,
				"inlined": true,
				"ref": "tradle.MerkleNode"
			},
			"proof": {
				"type": "array",
				"readOnly": true,
				"inlined": true,
				"items": {
					"ref": "tradle.MerkleNode"
				}
			},
			"leaves": {
				"type": "array",
				"readOnly": true,
				"inlined": true,
				"items": {
					"ref": "tradle.MerkleLeaf"
				}
			},
			"sig": {
				"type": "string",
				"readOnly": true
			},
			"type": {
				"type": "string",
				"readOnly": true
			},
			"context": {
				"type": "string",
				"readOnly": true
			}
		}
	};

/***/ },

/***/ 1576:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Passport",
		"type": "tradle.Model",
		"title": "Passport",
		"interfaces": [
			"tradle.Message",
			"tradle.Verifiable"
		],
		"verifiableAspects": {
			"authenticity": {
				"methods": [
					"tradle.VisualVerificationMethod",
					"tradle.APIBasedVerificationMethod"
				]
			},
			"ownership": {
				"methods": [
					"tradle.VisualVerificationMethod"
				]
			},
			"validity": {
				"methods": [
					"tradle.VisualVerificationMethod"
				]
			}
		},
		"subClassOf": "tradle.Form",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"issuingCountry": {
				"type": "object",
				"ref": "tradle.Country"
			},
			"passportNumber": {
				"type": "number",
				"maxLength": 9,
				"minLength": 9,
				"displayName": true
			},
			"surname": {
				"type": "string"
			},
			"givenName": {
				"type": "string"
			},
			"nationality": {
				"type": "object",
				"ref": "tradle.Nationality"
			},
			"dateOfBirth": {
				"type": "date"
			},
			"sex": {
				"type": "object",
				"ref": "tradle.Sex"
			},
			"placeOfBirth": {
				"type": "string"
			},
			"dateOfIssue": {
				"type": "date"
			},
			"authority": {
				"type": "string",
				"displayName": true
			},
			"dateOfExpiry": {
				"type": "date",
				"displayName": true
			},
			"country": {
				"type": "object",
				"ref": "tradle.Country"
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity",
				"displayName": true
			},
			"to": {
				"type": "object",
				"ref": "tradle.Identity",
				"readOnly": true
			},
			"time": {
				"type": "date",
				"readOnly": true
			},
			"photos": {
				"type": "array",
				"inlined": true,
				"items": {
					"ref": "tradle.Photo"
				}
			}
		},
		"required": [
			"country",
			"photos",
			"issuingCountry",
			"passportNumber",
			"surname",
			"givenName",
			"nationality",
			"dateOfBirth",
			"sex",
			"placeOfBirth",
			"dateOfIssue",
			"authority",
			"dateOfExpiry"
		],
		"viewCols": [
			"country",
			"issuingCountry",
			"passportNumber",
			"surname",
			"givenName",
			"nationality",
			"dateOfBirth",
			"sex",
			"placeOfBirth",
			"dateOfIssue",
			"authority",
			"dateOfExpiry"
		]
	};

/***/ },

/***/ 1577:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.PassportVerification",
		"type": "tradle.Model",
		"title": "Passport Verification",
		"interfaces": [
			"tradle.Message",
			"tradle.Verifiable"
		],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"codeOfIssuing": {
				"type": "string"
			},
			"passportNumber": {
				"type": "number",
				"maxLength": 9,
				"minLength": 9,
				"displayName": true
			},
			"surname": {
				"type": "string"
			},
			"givenName": {
				"type": "string"
			},
			"nationality": {
				"type": "string"
			},
			"dateOfBirth": {
				"type": "date"
			},
			"sex": {
				"type": "object",
				"ref": "tradle.Sex"
			},
			"placeOfBirth": {
				"type": "string"
			},
			"dateOfIssue": {
				"type": "date"
			},
			"authority": {
				"type": "string",
				"displayName": true
			},
			"dateOfExpiry": {
				"type": "date",
				"displayName": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity",
				"displayName": true
			},
			"to": {
				"type": "object",
				"ref": "tradle.Identity",
				"readOnly": true
			},
			"time": {
				"type": "date",
				"readOnly": true
			},
			"photos": {
				"type": "array",
				"inlined": true,
				"items": {
					"ref": "tradle.Photo"
				}
			},
			"country": {
				"type": "object",
				"ref": "tradle.Country"
			},
			"verifications": {
				"type": "array",
				"readOnly": true,
				"items": {
					"backlink": "document",
					"ref": "tradle.Verification"
				}
			}
		},
		"required": [
			"to",
			"from",
			"photos",
			"codeOfIssuing",
			"passportNumber",
			"surname",
			"givenName",
			"nationality",
			"dateOfBirth",
			"sex",
			"placeOfBirth",
			"dateOfIssue",
			"authority",
			"dateOfExpiry"
		],
		"gridCols": [
			"from",
			"passportNumber",
			"dateOfExpiry",
			"time"
		],
		"viewCols": [
			"codeOfIssuing",
			"passportNumber",
			"surname",
			"givenName",
			"nationality",
			"dateOfBirth",
			"sex",
			"placeOfBirth",
			"dateOfIssue",
			"authority",
			"dateOfExpiry"
		]
	};

/***/ },

/***/ 1578:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.PaymentPeriod",
		"title": "Payment Period",
		"type": "tradle.Model",
		"subClassOf": "tradle.Enum",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"paymentPeriod": {
				"displayName": true,
				"type": "string"
			}
		}
	};

/***/ },

/***/ 1579:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Pension",
		"title": "Pension",
		"interfaces": [
			"tradle.Message"
		],
		"type": "tradle.Model",
		"forms": [
			"tradle.AboutYou",
			"tradle.YourMoney"
		],
		"subClassOf": "tradle.FinancialProduct",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			}
		}
	};

/***/ },

/***/ 1580:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.PersonalInfo",
		"title": "Personal Info",
		"interfaces": [
			"tradle.Message",
			"tradle.Verifiable"
		],
		"evidentiaryDocuments": [
			"tradle.Passport",
			"tradle.Visa",
			"tradle.DriverLicense",
			"tradle.IdentificationDetail"
		],
		"subClassOf": "tradle.Form",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"firstName": {
				"type": "string"
			},
			"lastName": {
				"type": "string"
			},
			"name": {
				"type": "string",
				"displayAs": "{2} {1}",
				"group": [
					"lastName",
					"firstName"
				],
				"readOnly": true,
				"displayName": true
			},
			"dateOfBirth": {
				"type": "date",
				"maxDate": "18 years before",
				"minDate": "110 years before"
			},
			"name_group": {
				"type": "string",
				"title": "Personal detail",
				"list": [
					"firstName",
					"lastName",
					"emailAddress",
					"dateOfBirth",
					"placeOfBirth",
					"maritalStatus",
					"education",
					"nationality"
				]
			},
			"placeOfBirth": {
				"type": "string"
			},
			"street": {
				"type": "string"
			},
			"houseNumber": {
				"type": "string",
				"pattern": "^[a-zA-Z0-9.-]*$"
			},
			"city": {
				"type": "string"
			},
			"region": {
				"type": "string"
			},
			"postalCode": {
				"type": "string"
			},
			"country": {
				"type": "object",
				"ref": "tradle.Country"
			},
			"nationality": {
				"type": "object",
				"ref": "tradle.Nationality"
			},
			"phones": {
				"type": "array",
				"inlined": true,
				"items": {
					"ref": "tradle.Phone"
				}
			},
			"emailAddress": {
				"type": "string",
				"pattern": "^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$",
				"keyboard": "email-address",
				"range": "email"
			},
			"maritalStatus": {
				"type": "object",
				"ref": "tradle.MaritalStatus"
			},
			"education": {
				"type": "object",
				"ref": "tradle.EducationNL"
			}
		},
		"editCols": [
			"name_group",
			"phones"
		],
		"required": [
			"firstName",
			"lastName",
			"dateOfBirth",
			"placeOfBirth",
			"emailAddress",
			"maritalStatus",
			"education",
			"nationality",
			"phones"
		],
		"viewCols": [
			"name_group",
			"name",
			"dateOfBirth",
			"placeOfBirth",
			"nationality",
			"maritalStatus",
			"education",
			"emailAddress",
			"phones"
		]
	};

/***/ },

/***/ 1581:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Phone",
		"type": "tradle.Model",
		"title": "Phone",
		"icon": "ios-call-outline",
		"inlined": true,
		"properties": {
			"phoneType": {
				"type": "object",
				"ref": "tradle.PhoneTypes"
			},
			"number": {
				"type": "string",
				"range": "phone",
				"keyboard": "phone-pad"
			},
			"myPhones": {
				"type": "string",
				"displayAs": "{2} {1}",
				"group": [
					"phoneType",
					"number"
				],
				"readOnly": true,
				"skipLabel": true
			}
		},
		"required": [
			"phoneType",
			"number"
		],
		"viewCols": [
			"myPhones"
		]
	};

/***/ },

/***/ 1582:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.PhoneBill",
		"type": "tradle.Model",
		"title": "Phone Bill",
		"subClassOf": "tradle.Form",
		"interfaces": [
			"tradle.Message",
			"tradle.Verifiable",
			"tradle.Document"
		],
		"verifiableAspects": {
			"authenticity": {
				"methods": [
					"tradle.VisualVerificationMethod"
				]
			},
			"ownership": {
				"methods": [
					"tradle.VisualVerificationMethod"
				]
			},
			"validity": {
				"methods": [
					"tradle.VisualVerificationMethod"
				]
			}
		},
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"billDate": {
				"type": "date",
				"displayName": true
			},
			"issuedBy": {
				"type": "string",
				"displayName": true
			},
			"firstName": {
				"type": "string"
			},
			"lastName": {
				"type": "string"
			},
			"city": {
				"type": "string"
			},
			"country": {
				"type": "object",
				"ref": "tradle.Country"
			},
			"postalCode": {
				"type": "string"
			},
			"region": {
				"type": "string"
			},
			"streetAddress": {
				"type": "string"
			},
			"phoneNumbers": {
				"type": "array",
				"inlined": true,
				"items": {
					"ref": "tradle.Phone"
				}
			},
			"formattedAddress": {
				"type": "string",
				"displayAs": "{1} {2}, {3}, {4}",
				"group": [
					"streetAddress",
					"city",
					"region",
					"postalCode"
				],
				"title": "Address",
				"readOnly": true
			},
			"photos": {
				"type": "array",
				"range": "photo",
				"inlined": true,
				"items": {
					"ref": "tradle.Photo"
				}
			}
		},
		"required": [
			"photos",
			"billDate",
			"issuedBy",
			"firstName",
			"lastName",
			"city",
			"streetAddress",
			"postalCode",
			"region"
		],
		"gridCols": [
			"issuedBy",
			"billDate"
		],
		"viewCols": [
			"issuedBy",
			"formattedAddress",
			"billDate",
			"photos"
		]
	};

/***/ },

/***/ 1583:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.PhoneTypes",
		"title": "Phone Types",
		"subClassOf": "tradle.Enum",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"phoneType": {
				"displayName": true,
				"type": "string"
			}
		},
		"required": [
			"phoneType"
		]
	};

/***/ },

/***/ 1584:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Photo",
		"type": "tradle.Model",
		"title": "Photo",
		"inlined": true,
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"url": {
				"type": "string",
				"readOnly": true
			},
			"width": {
				"type": "number",
				"readOnly": true
			},
			"height": {
				"type": "number",
				"readOnly": true
			}
		},
		"required": [
			"url"
		]
	};

/***/ },

/***/ 1585:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.PhotoID",
		"type": "tradle.Model",
		"title": "Photo ID",
		"subClassOf": "tradle.Form",
		"interfaces": [
			"tradle.Message",
			"tradle.Verifiable",
			"tradle.Document"
		],
		"verifiableAspects": {
			"authenticity": {
				"methods": [
					"tradle.VisualVerificationMethod"
				]
			},
			"ownership": {
				"methods": [
					"tradle.VisualVerificationMethod"
				]
			},
			"validity": {
				"methods": [
					"tradle.VisualVerificationMethod"
				]
			}
		},
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"documentType": {
				"type": "object",
				"displayName": true,
				"ref": "tradle.IDCardType"
			},
			"country": {
				"type": "object",
				"title": "Country of Issue",
				"displayName": true,
				"ref": "tradle.Country"
			},
			"scan": {
				"type": "object",
				"range": "photo",
				"mainPhoto": true,
				"component": "BlinkID",
				"ref": "tradle.Photo"
			},
			"scanJson": {
				"type": "object",
				"title": "Extracted fields",
				"range": "json",
				"readOnly": true
			},
			"verifications": {
				"type": "array",
				"readOnly": true,
				"items": {
					"backlink": "document",
					"ref": "tradle.Verification"
				}
			}
		},
		"required": [
			"documentType",
			"country",
			"scan"
		],
		"viewCols": [
			"documentType",
			"country",
			"scan",
			"scanJson"
		]
	};

/***/ },

/***/ 1586:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Posessions",
		"title": "Posessions",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"downPayment": {
				"type": "object",
				"displayName": true,
				"ref": "tradle.Money"
			},
			"photos": {
				"type": "array",
				"title": "Snapshot of the document",
				"items": {
					"type": "object",
					"properties": {
						"tags": {
							"type": "string",
							"skipLabel": true
						},
						"url": {
							"type": "string",
							"readOnly": true
						},
						"width": {
							"type": "number",
							"readOnly": true
						},
						"height": {
							"type": "number",
							"readOnly": true
						}
					}
				},
				"required": [
					"title",
					"url"
				]
			}
		},
		"required": [
			"downPayment"
		],
		"viewCols": [
			"downPayment",
			"photos"
		]
	};

/***/ },

/***/ 1587:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.ProductApplication",
		"title": "ProductApplication",
		"interfaces": [
			"tradle.Message"
		],
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"product": {
				"type": "string",
				"displayName": true
			},
			"time": {
				"type": "date",
				"readOnly": true
			},
			"session": {
				"type": "string"
			},
			"welcome": {
				"type": "boolean",
				"readOnly": true
			}
		},
		"viewCols": [
			"product"
		],
		"required": [
			"product"
		]
	};

/***/ },

/***/ 1588:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.ProductList",
		"title": "Product List",
		"type": "tradle.Model",
		"interfaces": [
			"tradle.Message"
		],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"message": {
				"type": "string"
			},
			"list": {
				"type": "array",
				"readOnly": true,
				"items": {
					"type": "object",
					"ref": "tradle.Model"
				}
			}
		},
		"viewCols": [
			"message"
		],
		"required": [
			"message",
			"list"
		]
	};

/***/ },

/***/ 1589:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.ProfessionalIndemnity",
		"type": "tradle.Model",
		"title": "Professional Indemnity",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"name": {
				"type": "string"
			},
			"periodOfCover": {
				"type": "string"
			},
			"coverBinding": {
				"type": "boolean",
				"title": "Does your professional indemnity cover Lloyd's binding authorities?"
			},
			"piInsurerName": {
				"title": "PI Insurer Name",
				"type": "string"
			},
			"startDateOfCover": {
				"type": "date"
			},
			"expiryDateOfCover": {
				"type": "date"
			},
			"currency": {
				"type": "object",
				"ref": "tradle.Currency"
			},
			"limitIL": {
				"type": "object",
				"ref": "tradle.Money",
				"title": "Limit – Individual loss"
			},
			"limitAL": {
				"type": "object",
				"ref": "tradle.Money",
				"title": "Limit – Aggregate loss"
			},
			"deductible": {
				"type": "object",
				"ref": "tradle.Money",
				"title": "Deductible – Individual loss"
			},
			"policyCoverActsOfDishonestyByEmployees": {
				"type": "boolean",
				"title": "Policy cover acts of dishonesty by employees"
			},
			"fidelityInsurancePolicy": {
				"type": "boolean",
				"title": "Fidelity insurance policy"
			},
			"additionalLinesOfPIcover": {
				"type": "boolean",
				"title": "Additional lines of PI cover"
			},
			"detailsOfAdditionalLinesOfPIcover": {
				"title": "Details of additional lines of cover",
				"type": "string"
			},
			"numberOfPIclaims": {
				"type": "number",
				"title": "Number of PI claims in the last five years"
			},
			"photos": {
				"type": "array",
				"title": "Document snapshots",
				"items": {
					"type": "object",
					"properties": {
						"tags": {
							"type": "string",
							"skipLabel": true
						},
						"url": {
							"type": "string",
							"readOnly": true
						},
						"width": {
							"type": "number",
							"readOnly": true
						},
						"height": {
							"type": "number",
							"readOnly": true
						}
					}
				},
				"required": [
					"title",
					"url"
				]
			}
		},
		"required": [
			"name",
			"piInsurerName",
			"expiryDateOfCover"
		],
		"viewCols": [
			"name",
			"periodOfCover",
			"coverBinding",
			"piInsurerName",
			"startDateOfCover",
			"expiryDateOfCover",
			"currency",
			"limitIL",
			"limitAL",
			"deductible",
			"policyCoverActsOfDishonestyByEmployees",
			"fidelityInsurancePolicy",
			"additionalLinesOfPIcover",
			"detailsOfAdditionalLinesOfPIcover",
			"numberOfPIclaims",
			"photos"
		]
	};

/***/ },

/***/ 1590:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Profile",
		"type": "tradle.Model",
		"title": "Profile",
		"sort": "lastMessageTime",
		"plural": "Profiles",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"securityCode": {
				"type": "string",
				"readOnly": true
			},
			"city": {
				"type": "string"
			},
			"country": {
				"type": "object",
				"ref": "tradle.Country"
			},
			"postalCode": {
				"type": "string"
			},
			"region": {
				"type": "string"
			},
			"street": {
				"type": "string"
			},
			"formattedAddress": {
				"type": "string",
				"displayAs": "{1}, {2}, {3} {4}, {5}",
				"group": [
					"street",
					"city",
					"region",
					"postalCode",
					"country"
				],
				"title": "Address",
				"readOnly": true
			},
			"firstName": {
				"type": "string"
			},
			"lastName": {
				"type": "string"
			},
			"address_group": {
				"title": "Home Address",
				"type": "string"
			},
			"employment_group": {
				"title": "Employment",
				"type": "string"
			},
			"formatted": {
				"type": "string",
				"displayAs": "{2} {1}",
				"group": [
					"lastName",
					"firstName"
				],
				"readOnly": true,
				"displayName": true
			},
			"language": {
				"type": "object",
				"ref": "tradle.Language"
			},
			"middleName": {
				"type": "string"
			},
			"organization": {
				"type": "object",
				"ref": "tradle.Organization"
			},
			"bot": {
				"type": "boolean",
				"readOnly": true
			},
			"isEmployee": {
				"type": "boolean",
				"readOnly": true
			},
			"verifiedByMe": {
				"type": "array",
				"allowRoles": "me",
				"icon": "ios-checkmark-circle-outline",
				"items": {
					"readOnly": true,
					"ref": "tradle.Verification",
					"backlink": "from"
				}
			},
			"myProducts": {
				"type": "array",
				"title": "Products",
				"icon": "ios-disc-outline",
				"allowRoles": "me",
				"items": {
					"readOnly": true,
					"ref": "tradle.MyProduct",
					"backlink": "to"
				}
			},
			"myVerifications": {
				"type": "array",
				"title": "Verifications",
				"allowRoles": "me",
				"icon": "ios-checkmark-circle-outline",
				"items": {
					"readOnly": true,
					"ref": "tradle.Verification",
					"backlink": "to"
				}
			},
			"myForms": {
				"type": "array",
				"title": "My Data",
				"allowRoles": "me",
				"icon": "ios-body-outline",
				"items": {
					"readOnly": true,
					"ref": "tradle.Form",
					"backlink": "from"
				}
			},
			"myDocuments": {
				"type": "array",
				"title": "Documents",
				"allowRoles": "me",
				"icon": "ios-paper-outline",
				"items": {
					"readOnly": true,
					"ref": "tradle.Document",
					"backlink": "from"
				}
			},
			"useTouchId": {
				"type": "boolean"
			},
			"useGesturePassword": {
				"type": "boolean"
			},
			"photos": {
				"type": "array",
				"range": "photo",
				"allowPicturesFromLibrary": true,
				"cameraType": "front",
				"inlined": true,
				"items": {
					"ref": "tradle.Photo"
				}
			},
			"coverPhoto": {
				"inlined": true,
				"type": "object",
				"allowPicturesFromLibrary": true,
				"coverPhoto": true,
				"ref": "tradle.Photo"
			},
			"summary": {
				"type": "string"
			},
			"lastMessage": {
				"type": "string"
			},
			"lastMessageTime": {
				"type": "date"
			},
			"websites": {
				"type": "array",
				"inlined": true,
				"items": {
					"ref": "tradle.WebSite"
				}
			}
		},
		"required": [
			"firstName"
		],
		"gridCols": [
			"formatted",
			"lastMessage",
			"lastMessageTime",
			"organization"
		],
		"viewCols": [
			"address_group",
			"formattedAddress",
			"employment_group",
			"organization",
			"myForms",
			"myDocuments",
			"myVerifications",
			"websites",
			"coverPhoto",
			"photos"
		],
		"editCols": [
			"organization",
			"coverPhoto"
		]
	};

/***/ },

/***/ 1591:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.ProjectApplication",
		"type": "tradle.Model",
		"title": "Project application",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.FinancialProduct",
		"forms": [],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"productType": {
				"type": "string",
				"readOnly": true,
				"displayName": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			}
		}
	};

/***/ },

/***/ 1592:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.PropertyInformation",
		"title": "Property Information",
		"interfaces": [
			"tradle.Message"
		],
		"type": "tradle.Model",
		"subClassOf": "tradle.Form",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"propertyStreetAddress": {
				"type": "string"
			},
			"region": {
				"type": "string"
			},
			"city": {
				"type": "string"
			},
			"postalCode": {
				"type": "string"
			},
			"country": {
				"type": "object",
				"ref": "tradle.Country"
			},
			"formattedAddress": {
				"type": "string",
				"displayAs": "{1} {2}, {3}, {4} {5}",
				"group": [
					"propertyStreetAddress",
					"city",
					"region",
					"postalCode",
					"country"
				],
				"title": "Property Address",
				"readOnly": true
			},
			"propertyType": {
				"type": "object",
				"ref": "tradle.PropertyTypes"
			},
			"sizeOfProperty": {
				"type": "number",
				"units": "sqft"
			},
			"bedrooms": {
				"type": "number",
				"title": "Number of bedrooms"
			},
			"bathrooms": {
				"type": "number",
				"title": "Number of bathrooms"
			},
			"yearBuilt": {
				"type": "number",
				"title": "Year it was built"
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			}
		},
		"viewCols": [
			"formattedAddress",
			"propertyType",
			"sizeOfProperty",
			"bedrooms",
			"bathrooms",
			"yearBuilt"
		]
	};

/***/ },

/***/ 1593:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.PropertyOwnership",
		"title": "Property Ownership",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"dateNotarized": {
				"type": "date"
			},
			"photos": {
				"type": "array",
				"title": "Photo ID snapshots",
				"items": {
					"type": "object",
					"properties": {
						"tags": {
							"type": "string",
							"skipLabel": true
						},
						"url": {
							"type": "string",
							"readOnly": true
						},
						"width": {
							"type": "number",
							"readOnly": true
						},
						"height": {
							"type": "number",
							"readOnly": true
						}
					}
				},
				"required": [
					"url"
				]
			}
		},
		"required": [
			"dateNotarized",
			"photos"
		],
		"viewCols": [
			"dateNotarized",
			"photos"
		]
	};

/***/ },

/***/ 1594:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.PropertyType",
		"title": "Property Type",
		"type": "tradle.Model",
		"subClassOf": "tradle.Enum",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"propertyType": {
				"displayName": true,
				"type": "string"
			}
		},
		"required": [
			"propertyType"
		]
	};

/***/ },

/***/ 1595:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.PropertyTypes",
		"title": "Property Types",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"propertyType": {
				"displayName": true,
				"type": "string"
			}
		},
		"required": [
			"propertyType"
		]
	};

/***/ },

/***/ 1596:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.PurposeOfMortgageLoan",
		"title": "Purpose of mortgage loan",
		"type": "tradle.Model",
		"subClassOf": "tradle.Enum",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"purpose": {
				"displayName": true,
				"type": "string"
			}
		},
		"required": [
			"purpose"
		]
	};

/***/ },

/***/ 1597:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.PurposeOfTheAccount",
		"title": "Purpose Of The Account",
		"subClassOf": "tradle.Enum",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"purpose": {
				"displayName": true,
				"type": "string"
			}
		},
		"required": [
			"purpose"
		]
	};

/***/ },

/***/ 1598:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.QualifiedInvestor",
		"title": "Qualified Investor",
		"interfaces": [
			"tradle.Message",
			"tradle.Verifiable"
		],
		"evidentiaryDocuments": [
			"tradle.Passport",
			"tradle.Visa",
			"tradle.DriverLicense",
			"tradle.IdentificationDetail"
		],
		"subClassOf": "tradle.Form",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"narrative": {
				"type": "string",
				"displayName": true
			},
			"verifications": {
				"type": "array",
				"readOnly": true,
				"items": {
					"backlink": "document",
					"ref": "tradle.Verification"
				}
			}
		},
		"required": [
			"narrative"
		],
		"viewCols": [
			"narrative"
		]
	};

/***/ },

/***/ 1599:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.ReasonForApplication",
		"type": "tradle.Model",
		"title": "Reason for application",
		"subClassOf": "tradle.Form",
		"interfaces": [
			"tradle.Message"
		],
		"style": {
			"backgroundColor": "#EBE1FA"
		},
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"mainMotivation": {
				"type": "object",
				"displayName": true,
				"ref": "tradle.EResidencyMotivation"
			},
			"description": {
				"type": "string",
				"description": "Describe your main motivations to become an e-resident"
			}
		},
		"editCols": [
			"mainMotivation",
			"description"
		],
		"required": [
			"mainMotivation"
		],
		"viewCols": [
			"mainMotivation",
			"description"
		]
	};

/***/ },

/***/ 1600:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Refinancing",
		"title": "Refinancing",
		"interfaces": [
			"tradle.Message"
		],
		"type": "tradle.Model",
		"forms": [
			"tradle.AboutYou",
			"tradle.YourMoney",
			"tradle.MortgageLoanDetail"
		],
		"subClassOf": "tradle.FinancialProduct",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			}
		}
	};

/***/ },

/***/ 1601:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Regulator",
		"type": "tradle.Model",
		"title": "Regulator",
		"subClassOf": "tradle.Enum",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"regulator": {
				"displayName": true,
				"type": "string"
			}
		}
	};

/***/ },

/***/ 1602:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Remediation",
		"interfaces": [
			"tradle.Message"
		],
		"title": "Remediation",
		"type": "tradle.Model",
		"subClassOf": "tradle.FinancialProduct",
		"forms": [],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			}
		}
	};

/***/ },

/***/ 1603:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.RemediationSimpleMessage",
		"type": "tradle.Model",
		"title": "Remediation Simple Message",
		"autoCreate": true,
		"interfaces": [
			"tradle.Message"
		],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"message": {
				"type": "string",
				"displayName": true
			},
			"time": {
				"type": "date",
				"readOnly": true
			}
		},
		"required": [
			"message"
		],
		"viewCols": [
			"message",
			"time"
		]
	};

/***/ },

/***/ 1604:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.RepaymentType",
		"title": "RepaymentType",
		"type": "tradle.Model",
		"subClassOf": "tradle.Enum",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"repaymentType": {
				"displayName": true,
				"type": "string"
			}
		}
	};

/***/ },

/***/ 1605:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.ReportForNonProfitAllowanceUsage",
		"type": "tradle.Model",
		"title": "Report of nonprofit organization allowance usage",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.FinancialProduct",
		"forms": [],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"productType": {
				"type": "string",
				"readOnly": true,
				"displayName": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			}
		}
	};

/***/ },

/***/ 1606:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.RequestForRepresentative",
		"title": "Request for representative",
		"interfaces": [
			"tradle.Message"
		],
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"message": {
				"type": "string"
			}
		},
		"viewCols": [
			"message"
		],
		"required": []
	};

/***/ },

/***/ 1607:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Residence",
		"type": "tradle.Model",
		"title": "Residence",
		"subClassOf": "tradle.Form",
		"interfaces": [
			"tradle.Message"
		],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"streetAddress": {
				"type": "string"
			},
			"city": {
				"type": "string"
			},
			"postalCode": {
				"type": "string"
			},
			"region": {
				"type": "string"
			},
			"country": {
				"type": "object",
				"ref": "tradle.Country"
			},
			"residenceType": {
				"type": "object",
				"title": "Residence Type",
				"displayName": true,
				"ref": "tradle.ResidenceType"
			},
			"formattedAddress": {
				"type": "string",
				"displayAs": "{2}, {3}, {4} {5}",
				"group": [
					"residenceType",
					"streetAddress",
					"city",
					"postalCode"
				],
				"title": "Address",
				"readOnly": true
			},
			"address_group": {
				"type": "string",
				"title": "Address",
				"list": [
					"streetAddress",
					"city",
					"postalCode",
					"country"
				]
			}
		},
		"required": [
			"residenceType",
			"city",
			"streetAddress",
			"postalCode"
		],
		"editCols": [
			"residenceType",
			"address_group"
		],
		"viewCols": [
			"residenceType",
			"formattedAddress"
		]
	};

/***/ },

/***/ 1608:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.ResidenceType",
		"title": "Residence Type",
		"subClassOf": "tradle.Enum",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"value": {
				"displayName": true,
				"type": "string"
			}
		}
	};

/***/ },

/***/ 1609:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.ResidentialStatus",
		"title": "Residential Status",
		"type": "tradle.Model",
		"subClassOf": "tradle.Enum",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"status": {
				"displayName": true,
				"type": "string"
			}
		},
		"required": [
			"status"
		]
	};

/***/ },

/***/ 1610:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.SocialSecurityNumber",
		"title": "Social Security Number",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"socialSecurityNumber": {
				"type": "string",
				"displayName": true
			},
			"photos": {
				"type": "array",
				"title": "Photo ID snapshots",
				"items": {
					"type": "object",
					"properties": {
						"tags": {
							"type": "string",
							"skipLabel": true
						},
						"url": {
							"type": "string",
							"readOnly": true
						},
						"width": {
							"type": "number",
							"readOnly": true
						},
						"height": {
							"type": "number",
							"readOnly": true
						}
					}
				},
				"required": [
					"title",
					"url"
				]
			}
		},
		"required": [
			"socialSecurityNumber"
		],
		"viewCols": [
			"socialSecurityNumber"
		]
	};

/***/ },

/***/ 1611:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.SalaryVerification",
		"type": "tradle.Model",
		"title": "Salary Verification",
		"interfaces": [
			"tradle.Message"
		],
		"style": {
			"backgroundColor": "#E1FAF9"
		},
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"message": {
				"type": "string",
				"title": "Description",
				"displayName": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"ref": "tradle.Identity",
				"displayName": true,
				"readOnly": true
			},
			"blockchainUrl": {
				"type": "string",
				"readOnly": true
			},
			"transactionHash": {
				"readOnly": true,
				"type": "string"
			},
			"time": {
				"type": "date",
				"readOnly": true
			},
			"photos": {
				"type": "array",
				"items": {
					"type": "object",
					"properties": {
						"tags": {
							"type": "string",
							"skipLabel": true
						},
						"url": {
							"type": "string",
							"readOnly": true
						},
						"width": {
							"type": "number",
							"readOnly": true
						},
						"height": {
							"type": "number",
							"readOnly": true
						}
					}
				},
				"required": [
					"title",
					"url"
				]
			},
			"verifications": {
				"type": "array",
				"readOnly": true,
				"items": {
					"backlink": "document",
					"ref": "tradle.Verification"
				},
				"required": [
					"contact"
				]
			},
			"additionalInfo": {
				"type": "array",
				"items": {
					"ref": "tradle.AdditionalInfo",
					"backlink": "document"
				}
			}
		},
		"required": [
			"to",
			"message",
			"from"
		],
		"gridCols": [
			"message",
			"time"
		],
		"viewCols": [
			"message",
			"time",
			"photos",
			"verifications"
		]
	};

/***/ },

/***/ 1612:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.SalesData",
		"title": "Sales Data for last year",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"averageMonthlySales": {
				"type": "object",
				"ref": "tradle.Money",
				"description": "Average monthly sales"
			},
			"averageTxsPerMonth": {
				"type": "number",
				"description": "Average number of transactions per month"
			},
			"averageTxAmount": {
				"type": "object",
				"ref": "tradle.Money",
				"description": "Average amount of a single transaction"
			},
			"numberOfChargebacks": {
				"type": "number"
			},
			"volumeOfChargebacks": {
				"type": "object",
				"ref": "tradle.Money",
				"title": "Total amount of chargebacks"
			},
			"settlementCurrency": {
				"type": "string"
			}
		},
		"viewCols": [
			"averageMonthlySales",
			"averageTxsPerMonth",
			"averageTxAmount",
			"numberOfChargebacks",
			"volumeOfChargebacks"
		],
		"required": [
			"averageMonthlySales",
			"averageTxsPerMonth",
			"averageTxAmount",
			"numberOfChargebacks",
			"volumeOfChargebacks",
			"settlementCurrency"
		]
	};

/***/ },

/***/ 1613:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.SecurityCode",
		"type": "tradle.Model",
		"title": "Security Code",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"code": {
				"type": "string",
				"readOnly": true
			},
			"organization": {
				"type": "object",
				"ref": "tradle.Organization"
			}
		}
	};

/***/ },

/***/ 1614:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.SelfIntroduction",
		"title": "Self introduction",
		"interfaces": [
			"tradle.Message"
		],
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"identity": {
				"type": "object",
				"ref": "tradle.Identity"
			},
			"name": {
				"type": "string"
			},
			"message": {
				"type": "string"
			}
		},
		"viewCols": [
			"message",
			"identity"
		],
		"required": [
			"identity"
		]
	};

/***/ },

/***/ 1615:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Selfie",
		"type": "tradle.Model",
		"title": "Selfie",
		"interfaces": [
			"tradle.Message",
			"tradle.Verifiable",
			"tradle.Document"
		],
		"verifiableAspects": {
			"authenticity": {
				"methods": [
					"tradle.VisualVerificationMethod"
				]
			},
			"ownership": {
				"methods": [
					"tradle.VisualVerificationMethod"
				]
			},
			"validity": {
				"methods": [
					"tradle.VisualVerificationMethod"
				]
			}
		},
		"notShareable": true,
		"notEditable": true,
		"formRequestMessage": "Please take a **selfie** picture of your face",
		"subClassOf": "tradle.Form",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity",
				"displayName": true
			},
			"to": {
				"type": "object",
				"ref": "tradle.Identity",
				"readOnly": true
			},
			"selfie": {
				"type": "object",
				"inlined": true,
				"cameraType": "front",
				"title": "Selfie",
				"ref": "tradle.Photo"
			},
			"selfieJson": {
				"type": "object",
				"title": "Photo info",
				"range": "json",
				"readOnly": true
			}
		},
		"required": [
			"selfie"
		],
		"viewCols": [
			"selfie"
		]
	};

/***/ },

/***/ 1616:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.ServiceProvider",
		"type": "tradle.Model",
		"title": "Service Provider",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"provider": {
				"type": "object",
				"ref": "tradle.Organization"
			},
			"url": {
				"type": "string",
				"readOnly": true
			}
		},
		"required": [
			"provider",
			"url"
		]
	};

/***/ },

/***/ 1617:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Settings",
		"type": "tradle.Model",
		"title": "Settings",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"url": {
				"title": "Server URL",
				"type": "string",
				"keyboard": "url"
			}
		},
		"viewCols": [
			"url"
		],
		"required": [
			"url"
		]
	};

/***/ },

/***/ 1618:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Sex",
		"title": "Sex",
		"subClassOf": "tradle.Enum",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"sex": {
				"displayName": true,
				"type": "string"
			}
		},
		"required": [
			"sex"
		]
	};

/***/ },

/***/ 1619:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.ShareContext",
		"interfaces": [
			"tradle.Message"
		],
		"title": "Share Context",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"context": {
				"type": "object",
				"ref": "tradle.ProductApplication"
			},
			"with": {
				"type": "array",
				"items": {
					"type": "object",
					"ref": "tradle.Identity"
				}
			}
		},
		"required": [
			"with",
			"context"
		]
	};

/***/ },

/***/ 1620:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.SharedResource",
		"type": "tradle.Model",
		"title": "Shared Resource",
		"autoCreate": true,
		"interfaces": [
			"tradle.Message"
		],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"ref": "tradle.Identity",
				"displayName": true,
				"readOnly": true
			},
			"message": {
				"type": "string",
				"displayName": true
			},
			"resource": {
				"type": "object",
				"ref": "tradle.Form",
				"readOnly": true
			},
			"time": {
				"type": "date",
				"readOnly": true
			}
		},
		"required": [
			"to",
			"message",
			"resource"
		],
		"viewCols": [
			"message",
			"resource",
			"time"
		]
	};

/***/ },

/***/ 1621:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.SimpleMessage",
		"type": "tradle.Model",
		"title": "Simple Message",
		"autoCreate": true,
		"interfaces": [
			"tradle.Message"
		],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"message": {
				"type": "string",
				"displayName": true
			},
			"photos": {
				"type": "array",
				"range": "photo",
				"inlined": true,
				"items": {
					"ref": "tradle.Photo"
				}
			},
			"time": {
				"type": "date",
				"readOnly": true
			},
			"welcome": {
				"type": "boolean",
				"readOnly": true
			}
		},
		"required": [
			"message"
		],
		"viewCols": [
			"message",
			"time"
		]
	};

/***/ },

/***/ 1622:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.SkillVerification",
		"type": "tradle.Model",
		"title": "Skill Verification",
		"interfaces": [
			"tradle.Message"
		],
		"style": {
			"backgroundColor": "#FAF9E1"
		},
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"message": {
				"type": "string",
				"title": "Description",
				"displayName": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"ref": "tradle.Identity",
				"displayName": true,
				"readOnly": true
			},
			"blockchainUrl": {
				"type": "string",
				"readOnly": true
			},
			"transactionHash": {
				"readOnly": true,
				"type": "string"
			},
			"time": {
				"type": "date",
				"readOnly": true
			},
			"photos": {
				"type": "array",
				"items": {
					"type": "object",
					"properties": {
						"tags": {
							"type": "string",
							"skipLabel": true
						},
						"url": {
							"type": "string",
							"readOnly": true
						},
						"width": {
							"type": "number",
							"readOnly": true
						},
						"height": {
							"type": "number",
							"readOnly": true
						}
					}
				},
				"required": [
					"title",
					"url"
				]
			},
			"verifications": {
				"type": "array",
				"readOnly": true,
				"items": {
					"backlink": "document",
					"ref": "tradle.Verification"
				}
			},
			"additionalInfo": {
				"type": "array",
				"items": {
					"ref": "tradle.AdditionalInfo",
					"backlink": "document"
				}
			}
		},
		"required": [
			"to",
			"message",
			"from"
		],
		"gridCols": [
			"message",
			"time"
		],
		"viewCols": [
			"message",
			"time",
			"photos",
			"verifications"
		]
	};

/***/ },

/***/ 1623:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.SourceOfIncome",
		"title": "Source Of Income",
		"type": "tradle.Model",
		"subClassOf": "tradle.Enum",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"sourceOfIncome": {
				"displayName": true,
				"type": "string"
			}
		},
		"required": [
			"sourceOfIncome"
		]
	};

/***/ },

/***/ 1624:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.StatusOfInsurance",
		"title": "Status Of Insurance",
		"type": "tradle.Model",
		"subClassOf": "tradle.Enum",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"statusOfInsurance": {
				"displayName": true,
				"type": "string"
			}
		}
	};

/***/ },

/***/ 1625:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.StylesPack",
		"title": "Styles Pack",
		"interfaces": [
			"tradle.Message"
		],
		"type": "tradle.Model",
		"properties": {
			"logoNeedsText": {
				"type": "boolean"
			},
			"linkColor": {
				"type": "string"
			},
			"productRowBgColor": {
				"type": "string"
			},
			"productRowTextColor": {
				"type": "string"
			},
			"sharedWithBg": {
				"type": "string"
			},
			"sharedWithVerificationBg": {
				"type": "string"
			},
			"verifiedHeaderColor": {
				"type": "string"
			},
			"verifiedLinkColor": {
				"type": "string"
			},
			"verificationBg": {
				"type": "string"
			},
			"verifiedSourcesColor": {
				"type": "string"
			},
			"confirmationColor": {
				"type": "string"
			},
			"confirmationBg": {
				"type": "string"
			},
			"requestFulfilled": {
				"type": "string"
			},
			"backgroundColor": {
				"type": "string"
			},
			"productBgColor": {
				"type": "string"
			},
			"myMessageLinkColor": {
				"type": "string"
			},
			"myMessageBackgroundColor": {
				"type": "string"
			},
			"formErrorBorder": {
				"type": "string"
			},
			"formErrorColor": {
				"type": "string"
			},
			"formErrorBg": {
				"type": "string"
			},
			"structuredMessageBackgroundColor": {
				"type": "string"
			},
			"structuredMessageColor": {
				"type": "string"
			},
			"structuredMessageBorder": {
				"type": "string"
			},
			"shareContextTextColor": {
				"type": "string"
			},
			"shareContextBackgroundColor": {
				"type": "string"
			},
			"currentContextTextColor": {
				"type": "string"
			},
			"currentContextBackgroundColor": {
				"type": "string"
			},
			"contextBackgroundColor": {
				"type": "string"
			},
			"contextTextColor": {
				"type": "string"
			},
			"shareButtonBackgroundColor": {
				"type": "string"
			},
			"backlinkRowBgColor": {
				"type": "string"
			},
			"backlinkRowTextColor": {
				"type": "string"
			},
			"listBg": {
				"type": "string"
			},
			"listColor": {
				"type": "string"
			},
			"sourcedVerificationBgColor": {
				"type": "string"
			},
			"sourcedVerificationTextColor": {
				"type": "string"
			},
			"navBarBackgroundColor": {
				"type": "string"
			},
			"navBarBorderColor": {
				"type": "string"
			},
			"navBarBorderWidth": {
				"type": "number"
			}
		}
	};

/***/ },

/***/ 1626:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.TaxesFiledConfirmation",
		"type": "tradle.Model",
		"title": "Taxes Filed Confirmation",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.FinancialProduct",
		"forms": [
			"tradle.TaxesFiledConfirmationForm"
		],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			}
		}
	};

/***/ },

/***/ 1627:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.TaxesFiledConfirmationForm",
		"title": "Taxes Filed",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"relevantTaxYear": {
				"type": "number",
				"range": "year",
				"displayName": true,
				"maxDate": "1 years before",
				"minDate": "10 years before"
			},
			"confirmationText": {
				"type": "string",
				"readOnly": true,
				"skipLabel": true
			},
			"confirmationCheck": {
				"type": "boolean"
			},
			"confirmation": {
				"type": "string",
				"displayAs": "{1} {2}",
				"readOnly": true,
				"group": [
					"confirmationCheck",
					"confirmationText"
				]
			}
		},
		"required": [
			"relevantTaxYear",
			"confirmationText",
			"confirmationCheck"
		],
		"viewCols": [
			"relevantTaxYear",
			"confirmation"
		]
	};

/***/ },

/***/ 1628:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.TermInsurance",
		"title": "Term Insurance",
		"interfaces": [
			"tradle.Message"
		],
		"type": "tradle.Model",
		"forms": [
			"tradle.AboutYou",
			"tradle.YourMoney"
		],
		"subClassOf": "tradle.FinancialProduct",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			}
		}
	};

/***/ },

/***/ 1629:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.TermsAndConditions",
		"type": "tradle.Model",
		"title": "TermsAndConditions",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"introduction": {
				"type": "string",
				"skipLabel": true
			},
			"identity": {
				"type": "string"
			},
			"sharing": {
				"type": "string"
			},
			"notifications": {
				"type": "string"
			},
			"digitalSignatures": {
				"type": "string"
			},
			"changes": {
				"type": "string"
			},
			"contactUs": {
				"type": "string"
			},
			"damages": {
				"type": "string"
			}
		},
		"required": [
			"introduction",
			"identity",
			"sharing",
			"notifications",
			"digitalSignatures",
			"changes",
			"contactUs",
			"damages"
		],
		"viewCols": [
			"introduction",
			"identity",
			"sharing",
			"notifications",
			"digitalSignatures",
			"changes",
			"contactUs",
			"damages"
		]
	};

/***/ },

/***/ 1630:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Terms",
		"title": "Terms",
		"type": "tradle.Model",
		"subClassOf": "tradle.Enum",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"term": {
				"displayName": true,
				"type": "string"
			}
		},
		"required": [
			"term"
		]
	};

/***/ },

/***/ 1631:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.TypeOfApplication",
		"title": "Type of application",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"eResidencyApplicatoinType": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.EResidencyApplicationType"
			}
		},
		"editCols": [
			"eResidencyApplicatoinType"
		],
		"required": [
			"eResidencyApplicatoinType"
		],
		"viewCols": [
			"eResidencyApplicatoinType"
		]
	};

/***/ },

/***/ 1632:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.TypeOfCoverage",
		"title": "Type Of Coverage",
		"subClassOf": "tradle.Enum",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"typeOfCoverage": {
				"displayName": true,
				"type": "string"
			}
		}
	};

/***/ },

/***/ 1633:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.UtilityBillVerification",
		"type": "tradle.Model",
		"title": "Utility Bill Verification",
		"subClassOf": "tradle.Form",
		"interfaces": [
			"tradle.Message"
		],
		"style": {
			"backgroundColor": "#EBE1FA"
		},
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"billDate": {
				"type": "date",
				"displayName": true
			},
			"issuedBy": {
				"type": "string"
			},
			"firstName": {
				"type": "string"
			},
			"lastName": {
				"type": "string"
			},
			"city": {
				"type": "string"
			},
			"country": {
				"type": "object",
				"ref": "tradle.Country"
			},
			"postalCode": {
				"type": "string"
			},
			"region": {
				"type": "string"
			},
			"street": {
				"type": "string"
			},
			"formattedAddress": {
				"type": "string",
				"displayAs": "{1} {2}, {3}, {4}",
				"group": [
					"street",
					"city",
					"region",
					"postalCode"
				],
				"title": "Address",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"ref": "tradle.Identity",
				"displayName": true,
				"readOnly": true
			},
			"blockchainUrl": {
				"type": "string",
				"readOnly": true
			},
			"transactionHash": {
				"readOnly": true,
				"type": "string"
			},
			"time": {
				"type": "date",
				"readOnly": true
			},
			"photos": {
				"type": "array",
				"items": {
					"type": "object",
					"properties": {
						"tags": {
							"type": "string",
							"skipLabel": true
						},
						"url": {
							"type": "string",
							"readOnly": true
						},
						"width": {
							"type": "number",
							"readOnly": true
						},
						"height": {
							"type": "number",
							"readOnly": true
						}
					}
				},
				"required": [
					"title",
					"url"
				]
			},
			"verifications": {
				"type": "array",
				"readOnly": true,
				"items": {
					"backlink": "document",
					"ref": "tradle.Verification"
				}
			}
		},
		"required": [
			"to",
			"from",
			"photos",
			"billDate",
			"issuedBy",
			"firstName",
			"lastName",
			"city",
			"street",
			"postalCode",
			"region"
		],
		"gridCols": [
			"from",
			"formattedAddress",
			"billDate",
			"time"
		],
		"viewCols": [
			"issuedBy",
			"formattedAddress",
			"billDate",
			"time"
		]
	};

/***/ },

/***/ 1634:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Verifiable",
		"type": "tradle.Model",
		"title": "Verifiable",
		"isInterface": true,
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"verifiableAspects": {
				"type": "array",
				"items": {
					"ref": "tradle.Aspect"
				}
			},
			"evidentiaryDocuments": {
				"type": "array",
				"items": {
					"ref": "tradle.Verifiable"
				}
			}
		}
	};

/***/ },

/***/ 1635:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Verification",
		"type": "tradle.Model",
		"title": "Verification",
		"interfaces": [
			"tradle.Message"
		],
		"icon": "ios-checkmark-circle-outline",
		"autoCreate": true,
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"document": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Message",
				"title": "Verified document"
			},
			"message": {
				"type": "string",
				"title": "Description",
				"displayName": true
			},
			"to": {
				"type": "object",
				"title": "Owner",
				"ref": "tradle.Identity",
				"displayName": true,
				"readOnly": true
			},
			"from": {
				"type": "object",
				"title": "Verifier",
				"readOnly": true,
				"ref": "tradle.Identity",
				"displayName": true
			},
			"dateVerified": {
				"type": "date",
				"skipLabel": true,
				"readOnly": true
			},
			"organization": {
				"type": "object",
				"ref": "tradle.Organization"
			},
			"cancel": {
				"type": "boolean",
				"immutable": true
			},
			"sources": {
				"type": "array",
				"readOnly": true,
				"inlined": true,
				"items": {
					"ref": "tradle.Verification"
				}
			},
			"method": {
				"type": "object",
				"readOnly": true,
				"inlined": true,
				"ref": "tradle.Method"
			}
		},
		"required": [
			"document"
		],
		"viewCols": [
			"document",
			"dateVerified",
			"organization",
			"method",
			"sources"
		]
	};

/***/ },

/***/ 1636:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.VerifiedItem",
		"interfaces": [
			"tradle.Message"
		],
		"title": "VerifiedItem",
		"type": "tradle.Model",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"item": {
				"type": "object",
				"ref": "tradle.Form"
			},
			"verification": {
				"type": "object",
				"ref": "tradle.Verification"
			}
		}
	};

/***/ },

/***/ 1637:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.Visa",
		"type": "tradle.Model",
		"title": "Visa",
		"interfaces": [
			"tradle.Message",
			"tradle.Verifiable"
		],
		"subClassOf": "tradle.Form",
		"verifiableAspects": {
			"authenticity": {
				"methods": [
					"tradle.VisualVerificationMethod",
					"tradle.APIBasedVerificationMethod"
				]
			},
			"ownership": {
				"methods": [
					"tradle.VisualVerificationMethod"
				]
			},
			"validity": {
				"methods": [
					"tradle.VisualVerificationMethod"
				]
			}
		},
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"controlNumber": {
				"type": "string"
			},
			"issuingPostName": {
				"type": "string"
			},
			"passportNumber": {
				"type": "number",
				"maxLength": 9,
				"minLength": 9,
				"displayName": true
			},
			"surname": {
				"type": "string"
			},
			"givenName": {
				"type": "string"
			},
			"visaClass": {
				"type": "string"
			},
			"visaType": {
				"type": "string"
			},
			"nationality": {
				"type": "object",
				"ref": "tradle.Nationality"
			},
			"dateOfBirth": {
				"type": "date"
			},
			"sex": {
				"type": "object",
				"ref": "tradle.Sex"
			},
			"placeOfBirth": {
				"type": "string"
			},
			"dateOfIssue": {
				"type": "date"
			},
			"authority": {
				"type": "string",
				"displayName": true
			},
			"dateOfExpiry": {
				"type": "date",
				"displayName": true
			},
			"country": {
				"type": "object",
				"ref": "tradle.Country"
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity",
				"displayName": true
			},
			"to": {
				"type": "object",
				"ref": "tradle.Identity",
				"readOnly": true
			},
			"time": {
				"type": "date",
				"readOnly": true
			},
			"photos": {
				"type": "array",
				"inlined": true,
				"items": {
					"ref": "tradle.Photo"
				}
			}
		},
		"required": [
			"country",
			"visaType",
			"visaClass",
			"photos",
			"controlNumber",
			"issuingPostName",
			"passportNumber",
			"surname",
			"givenName",
			"nationality",
			"dateOfBirth",
			"sex",
			"placeOfBirth",
			"dateOfIssue",
			"authority",
			"dateOfExpiry"
		],
		"viewCols": [
			"country",
			"visaType",
			"visaClass",
			"controlNumber",
			"issuingPostName",
			"passportNumber",
			"surname",
			"givenName",
			"nationality",
			"dateOfBirth",
			"sex",
			"placeOfBirth",
			"dateOfIssue",
			"authority",
			"dateOfExpiry"
		]
	};

/***/ },

/***/ 1638:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.VisualVerificationMethod",
		"type": "tradle.Model",
		"title": "Visual Verification Method",
		"subClassOf": "tradle.Method",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"aspect": {
				"type": "string"
			},
			"documentPresence": {
				"type": "string"
			},
			"ownerPresence": {
				"type": "string"
			},
			"title": {
				"type": "string",
				"readOnly": true,
				"displayName": true,
				"displayAs": "based on document ownership checked by visual inspection in person",
				"group": []
			},
			"photos": {
				"type": "array",
				"inlined": true,
				"items": {
					"ref": "tradle.Photo"
				}
			}
		},
		"required": [
			"aspect",
			"photos"
		],
		"viewCols": [
			"aspect",
			"ownerPresence",
			"documentPresence",
			"photos"
		]
	};

/***/ },

/***/ 1639:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.WealthManagementPassport",
		"title": "Wealth Management Passport",
		"interfaces": [
			"tradle.Message"
		],
		"type": "tradle.Model",
		"forms": [
			"tradle.SocialSecurityNumber"
		],
		"subClassOf": "tradle.FinancialProduct",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			}
		}
	};

/***/ },

/***/ 1640:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.WealthCV",
		"title": "Source of Wealth",
		"type": "tradle.Model",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.Form",
		"verifiable": false,
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"narrative": {
				"type": "string",
				"displayName": true
			},
			"cvItems": {
				"type": "array",
				"icon": "ios-cash-outline",
				"title": "Wealth items",
				"allowToAdd": true,
				"items": {
					"backlink": "wealthCV",
					"ref": "tradle.CVItem"
				}
			},
			"verifications": {
				"type": "array",
				"readOnly": true,
				"items": {
					"backlink": "document",
					"ref": "tradle.Verification"
				}
			}
		},
		"required": [
			"narrative"
		],
		"viewCols": [
			"narrative",
			"cvItems"
		]
	};

/***/ },

/***/ 1641:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.WealthItemType",
		"type": "tradle.Model",
		"title": "Wealth Item Type",
		"subClassOf": "tradle.Enum",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"itemType": {
				"displayName": true,
				"type": "string"
			}
		},
		"required": [
			"itemType"
		],
		"viewCols": [
			"itemType"
		]
	};

/***/ },

/***/ 1642:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.WealthManagementAccount",
		"type": "tradle.Model",
		"title": "Wealth Management Account",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.FinancialProduct",
		"forms": [
			"tradle.PhotoID",
			"tradle.Selfie",
			"tradle.TaxesFiledConfirmationForm",
			"tradle.Residence",
			"tradle.WealthCV",
			"tradle.CVItem"
		],
		"additionalForms": [
			"tradle.QualifiedInvestor",
			"tradle.MediaSnippet",
			"tradle.InvestingExperience"
		],
		"multiEntryForms": [
			"tradle.Residence",
			"tradle.CVItem"
		],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			}
		}
	};

/***/ },

/***/ 1643:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.WebSite",
		"type": "tradle.Model",
		"title": "Web site",
		"icon": "ios-globe-outline",
		"inlined": true,
		"properties": {
			"url": {
				"skipLabel": true,
				"type": "string",
				"range": "url"
			}
		},
		"required": [
			"url"
		]
	};

/***/ },

/***/ 1644:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.WellDrilling",
		"type": "tradle.Model",
		"title": "Well drilling location endorsement",
		"interfaces": [
			"tradle.Message"
		],
		"subClassOf": "tradle.FinancialProduct",
		"forms": [],
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"productType": {
				"type": "string",
				"readOnly": true,
				"displayName": true
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			}
		}
	};

/***/ },

/***/ 1645:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.YourBalance",
		"title": "Your Balance",
		"interfaces": [
			"tradle.Message"
		],
		"type": "tradle.Model",
		"subClassOf": "tradle.Form",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"currentBalance": {
				"type": "object",
				"ref": "tradle.Money"
			},
			"date": {
				"type": "date"
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			}
		},
		"required": [
			"date",
			"currentBalance"
		],
		"viewCols": [
			"date",
			"currentBalance"
		]
	};

/***/ },

/***/ 1646:
/***/ function(module, exports) {

	module.exports = {
		"id": "tradle.YourMoney",
		"title": "Your Money",
		"interfaces": [
			"tradle.Message"
		],
		"type": "tradle.Model",
		"subClassOf": "tradle.Form",
		"properties": {
			"_t": {
				"type": "string",
				"readOnly": true
			},
			"employer": {
				"type": "string"
			},
			"howLongHaveYouWorkedHere": {
				"type": "number",
				"units": "years"
			},
			"monthlyIncome": {
				"type": "object",
				"ref": "tradle.Money"
			},
			"from": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			},
			"to": {
				"type": "object",
				"readOnly": true,
				"ref": "tradle.Identity"
			}
		},
		"viewCols": [
			"employer",
			"monthlyIncome",
			"howLongHaveYouWorkedHere"
		]
	};

/***/ },

/***/ 1648:
/***/ function(module, exports) {

	module.exports = {
		"properties": {
			"message": {
				"Default": "Message",
				"tradle.SalaryVerification": "Description",
				"tradle.SkillVerification": "Description",
				"tradle.Verification": "Description"
			},
			"from": {
				"Default": "From",
				"tradle.Verification": "Verifier"
			},
			"to": {
				"Default": "To",
				"tradle.Verification": "Owner",
				"tradle.Partial": "Owner"
			},
			"time": {
				"Default": "Time"
			},
			"document": {
				"Default": "Document",
				"tradle.Verification": "Verifying document"
			},
			"confirmed": {
				"Default": "Confirmed"
			},
			"companyName": {
				"Default": "Company Name"
			},
			"DBAName": {
				"tradle.BusinessInformation": "DBA Name"
			},
			"registrationNumber": {
				"Default": "Registration Number"
			},
			"registrationDate": {
				"Default": "Registration Date"
			},
			"taxIdNumber": {
				"tradle.BusinessInformation": "Tax ID Number"
			},
			"officialAddress": {
				"Default": "Official Address"
			},
			"actualAddress": {
				"Default": "Actual Address"
			},
			"country": {
				"Default": "Country",
				"tradle.PhotoID": "Country of Issue"
			},
			"companyPhone": {
				"Default": "Company Phone"
			},
			"companyFax": {
				"Default": "Company Fax"
			},
			"companyEmail": {
				"Default": "Company Email"
			},
			"numberOfEmployees": {
				"Default": "Number Of Employees"
			},
			"photos": {
				"Default": "Photos",
				"tradle.LicenseVerification": "Document Snapshots",
				"tradle.AboutYou": "Photo ID snapshots",
				"tradle.PersonalInfo": "Photo ID snapshots",
				"tradle.Posessions": "Snapshot of the document",
				"tradle.CompanyInformation": "Document snapshots",
				"tradle.CompanyOwners": "Document snapshots",
				"tradle.DriverLicense": "Document Snapshots",
				"tradle.Financials": "Document snapshots",
				"tradle.IdentificationDetail": "Document Snapshots",
				"tradle.IndividualOwners": "Document snapshots",
				"tradle.Licences": "Document snapshots",
				"tradle.ProfessionalIndemnity": "Document snapshots",
				"tradle.PropertyOwnership": "Photo ID snapshots",
				"tradle.SocialSecurityNumber": "Photo ID snapshots"
			},
			"currency": {
				"Default": "Currency"
			},
			"symbol": {
				"Default": "Symbol"
			},
			"contactsIntroducingCompany": {
				"Default": "Contacts Introducing Company"
			},
			"introducedParentCompany": {
				"tradle.CustomerIdentification": "Introduced Parent Company (legally registered name of entity) "
			},
			"accountName": {
				"tradle.CustomerIdentification": "Account name"
			},
			"officeAddress": {
				"Default": "Office Address"
			},
			"countryOfOrigin": {
				"Default": "Country Of Origin"
			},
			"contactPerson": {
				"Default": "Contact Person"
			},
			"isYourCompanyListed": {
				"Default": "Is Your Company Listed"
			},
			"stockExchange": {
				"Default": "Stock Exchange"
			},
			"welcome": {
				"Default": "Welcome"
			},
			"organization": {
				"Default": "Organization"
			},
			"form": {
				"Default": "Form"
			},
			"errors": {
				"Default": "Errors"
			},
			"verifications": {
				"Default": "Verifications"
			},
			"referencedBy": {
				"Default": "Referenced By"
			},
			"howToFund": {
				"Default": "How To Fund"
			},
			"pubkeys": {
				"Default": "Pubkeys"
			},
			"identity": {
				"Default": "Identity"
			},
			"accountWith": {
				"Default": "Account With"
			},
			"licenseNumber": {
				"Default": "License Number"
			},
			"surname": {
				"Default": "Surname"
			},
			"givenName": {
				"Default": "Given Name",
				"tradle.Name": "Given name(s)"
			},
			"dateOfBirth": {
				"Default": "Date Of Birth"
			},
			"dateOfIssue": {
				"Default": "Date Of Issue"
			},
			"dateOfExpiry": {
				"Default": "Date Of Expiry"
			},
			"issuingAuthority": {
				"Default": "Issuing Authority"
			},
			"holderAddress": {
				"Default": "Holder Address"
			},
			"entitlementCategories": {
				"Default": "Entitlement Categories"
			},
			"blockchainUrl": {
				"Default": "Blockchain Url"
			},
			"transactionHash": {
				"Default": "Transaction Hash"
			},
			"additionalInfo": {
				"Default": "Additional Info"
			},
			"status": {
				"Default": "Status"
			},
			"relatedTo": {
				"Default": "Related To"
			},
			"value": {
				"Default": "Value"
			},
			"purposeOfMortgageLoan": {
				"Default": "Purpose Of Mortgage Loan"
			},
			"totalAmountRequired": {
				"Default": "Total Amount Required"
			},
			"totalValueOfProperty": {
				"Default": "Total Value Of Property"
			},
			"propertyStreetAddress": {
				"Default": "Property Street Address"
			},
			"region": {
				"Default": "Region",
				"nl.tradle.CompanyInformation": "State/Province",
				"nl.tradle.MyCompanyRegistration": "State/Province",
				"tradle.CustomerProfile": "State/Province"
			},
			"city": {
				"Default": "City"
			},
			"postalCode": {
				"Default": "Postal Code"
			},
			"formattedAddress": {
				"tradle.MortgageLoanDetail": "Property Address",
				"tradle.Organization": "Address",
				"tradle.Profile": "Address",
				"tradle.PropertyInformation": "Property Address",
				"tradle.UtilityBillVerification": "Address",
				"tradle.Collateral": "Address",
				"tradle.Address": "Address",
				"tradle.PhoneBill": "Address",
				"tradle.Residence": "Address"
			},
			"propertyType": {
				"Default": "Property Type"
			},
			"sizeOfProperty": {
				"Default": "Size Of Property"
			},
			"currentIdentity": {
				"Default": "Current Identity"
			},
			"allIdentities": {
				"Default": "All Identities"
			},
			"nationality": {
				"Default": "Nationality"
			},
			"url": {
				"Default": "Url",
				"tradle.Settings": "Server URL"
			},
			"name": {
				"Default": "Name"
			},
			"email": {
				"Default": "Email",
				"tradle.BetaTesterContactInfo": "Email with which you registered your Apple ID",
				"tradle.ContactInformation": "E-mail"
			},
			"street": {
				"Default": "Street"
			},
			"contacts": {
				"Default": "Contacts"
			},
			"lastMessage": {
				"Default": "Last Message"
			},
			"lastMessageTime": {
				"Default": "Last Message Time"
			},
			"securityCodes": {
				"Default": "Security Codes"
			},
			"verificationsCount": {
				"Default": "Verifications Count"
			},
			"verificationRequests": {
				"Default": "Verification Requests"
			},
			"products": {
				"Default": "Products"
			},
			"codeOfIssuing": {
				"Default": "Code Of Issuing"
			},
			"passportNumber": {
				"Default": "Passport Number"
			},
			"sex": {
				"Default": "Sex"
			},
			"placeOfBirth": {
				"Default": "Place Of Birth"
			},
			"authority": {
				"Default": "Authority"
			},
			"phoneType": {
				"Default": "Phone Type"
			},
			"list": {
				"Default": "List"
			},
			"securityCode": {
				"Default": "Security Code"
			},
			"firstName": {
				"Default": "First Name"
			},
			"lastName": {
				"Default": "Last Name"
			},
			"formatted": {
				"Default": "Formatted"
			},
			"middleName": {
				"Default": "Middle Name"
			},
			"verifiedByMe": {
				"Default": "Verified By Me"
			},
			"myProducts": {
				"tradle.Profile": "Products"
			},
			"myVerifications": {
				"tradle.Profile": "Verifications"
			},
			"myRequests": {
				"tradle.Profile": "Requests"
			},
			"summary": {
				"Default": "Summary"
			},
			"websites": {
				"Default": "Websites"
			},
			"bedrooms": {
				"tradle.PropertyInformation": "Number of bedrooms"
			},
			"bathrooms": {
				"tradle.PropertyInformation": "Number of bathrooms"
			},
			"yearBuilt": {
				"tradle.PropertyInformation": "Year it was built"
			},
			"purpose": {
				"Default": "Purpose"
			},
			"averageMonthlySales": {
				"Default": "Average Monthly Sales"
			},
			"averageTxsPerMonth": {
				"Default": "Average Txs Per Month"
			},
			"averageTxAmount": {
				"Default": "Average Tx Amount"
			},
			"numberOfChargebacks": {
				"Default": "Number Of Chargebacks"
			},
			"volumeOfChargebacks": {
				"tradle.SalesData": "Total amount of chargebacks"
			},
			"settlementCurrency": {
				"Default": "Settlement Currency"
			},
			"code": {
				"Default": "Code"
			},
			"billDate": {
				"Default": "Bill Date"
			},
			"issuedBy": {
				"Default": "Issued By"
			},
			"employer": {
				"Default": "Employer"
			},
			"howLongHaveYouWorkedHere": {
				"Default": "How Long Have You Worked Here"
			},
			"monthlyIncome": {
				"Default": "Monthly Income"
			},
			"residentialStatus": {
				"Default": "Residential Status"
			},
			"maritalStatus": {
				"Default": "Marital Status"
			},
			"dependants": {
				"Default": "Dependants"
			},
			"countryOfBirth": {
				"Default": "Country Of Birth"
			},
			"taxResidency": {
				"Default": "Tax Residency"
			},
			"fundAccount": {
				"Default": "Fund Account"
			},
			"purposeOfTheAccount": {
				"Default": "Purpose Of The Account"
			},
			"phones": {
				"Default": "Phones"
			},
			"emailAddress": {
				"Default": "Email Address"
			},
			"productType": {
				"Default": "Product Type",
				"tradle.MortgageDetail": "Product"
			},
			"inUKFrom": {
				"tradle.CurrentAccount": "In UK from"
			},
			"language": {
				"Default": "Language"
			},
			"boolean": {
				"Default": "Boolean"
			},
			"houseNumber": {
				"Default": "House Number"
			},
			"houseValue": {
				"Default": "House Value"
			},
			"kindOfConstruction": {
				"Default": "Kind Of Construction"
			},
			"kindOfHouse": {
				"Default": "Kind Of House"
			},
			"additionalCosts": {
				"Default": "Additional Costs"
			},
			"restructuringCosts": {
				"Default": "Restructuring Costs"
			},
			"leaseholdKind": {
				"Default": "Leasehold Kind"
			},
			"leaseholdAmount": {
				"Default": "Leasehold Amount"
			},
			"rented": {
				"tradle.Collateral": "Rented?"
			},
			"purchasePrice": {
				"Default": "Purchase Price"
			},
			"valuedPrice": {
				"Default": "Valued Price"
			},
			"foreclosureValue": {
				"Default": "Foreclosure Value"
			},
			"badMaintenanceAmount": {
				"Default": "Bad Maintenance Amount"
			},
			"energyLabel": {
				"Default": "Energy Label"
			},
			"contractType": {
				"Default": "Contract Type"
			},
			"loanType": {
				"Default": "Loan Type"
			},
			"education": {
				"Default": "Education"
			},
			"idCardType": {
				"Default": "Id Card Type",
				"tradle.PersonalInfo": "ID Card"
			},
			"sourceOfIncome": {
				"Default": "Source Of Income"
			},
			"nameOfEmployer": {
				"Default": "Name Of Employer"
			},
			"residenceOfEmployer": {
				"Default": "Residence Of Employer"
			},
			"occupation": {
				"Default": "Occupation"
			},
			"kindOfEngagement": {
				"Default": "Kind Of Engagement"
			},
			"startDate": {
				"Default": "Start Date"
			},
			"yearsOfSelfEmployment": {
				"Default": "Years Of Self Employment"
			},
			"grossYearlyIncome": {
				"Default": "Gross Yearly Income"
			},
			"holidayMoney": {
				"Default": "Holiday Money"
			},
			"provisionalIncome": {
				"Default": "Provisional Income"
			},
			"additionalMonthOfPayment": {
				"Default": "Additional Month Of Payment"
			},
			"irregularityCompensation": {
				"Default": "Irregularity Compensation"
			},
			"overtimeCompensation": {
				"Default": "Overtime Compensation"
			},
			"bonus": {
				"Default": "Bonus"
			},
			"totalIncome": {
				"Default": "Total Income"
			},
			"insuredAmount": {
				"Default": "Insured Amount"
			},
			"typeOfCoverage": {
				"Default": "Type Of Coverage"
			},
			"insuranceFee": {
				"Default": "Insurance Fee"
			},
			"endDate": {
				"Default": "End Date"
			},
			"insurancePolicyNumber": {
				"Default": "Insurance Policy Number"
			},
			"policyHolder": {
				"Default": "Policy Holder"
			},
			"insured": {
				"tradle.InsuranceInfo": "Insured person or object"
			},
			"beneficiary": {
				"Default": "Beneficiary"
			},
			"pledge": {
				"Default": "Pledge"
			},
			"pledgedTo": {
				"Default": "Pledged To"
			},
			"interestType": {
				"Default": "Interest Type"
			},
			"kindOfInsurance": {
				"Default": "Kind Of Insurance"
			},
			"kindOfObligation": {
				"Default": "Kind Of Obligation"
			},
			"amount": {
				"Default": "Amount"
			},
			"interestPercentage": {
				"Default": "Interest Percentage"
			},
			"monthlyPremium": {
				"Default": "Monthly Premium"
			},
			"monthlyInterest": {
				"Default": "Monthly Interest"
			},
			"repaymentType": {
				"Default": "Repayment Type"
			},
			"loanPartID": {
				"tradle.LoanPart": "Loan Part ID"
			},
			"duration": {
				"Default": "Duration"
			},
			"totalMortgageAmount": {
				"Default": "Total Mortgage Amount"
			},
			"mortgageNumber": {
				"Default": "Mortgage Number"
			},
			"guarantee": {
				"Default": "Guarantee"
			},
			"termsApply": {
				"tradle.MortgageDetail": "Which terms apply?"
			},
			"mortgageProductType": {
				"Default": "Mortgage Product Type"
			},
			"creditLimit": {
				"Default": "Credit Limit"
			},
			"payment": {
				"Default": "Payment"
			},
			"paymentPeriod": {
				"Default": "Payment Period"
			},
			"insuranceCompany": {
				"Default": "Insurance Company"
			},
			"statusOfInsurance": {
				"Default": "Status Of Insurance"
			},
			"yearsOfInsurance": {
				"Default": "Years Of Insurance"
			},
			"amountToTransfer": {
				"Default": "Amount To Transfer"
			},
			"insuredPersons": {
				"Default": "Insured Persons"
			},
			"policyNumber": {
				"Default": "Policy Number"
			},
			"coverage": {
				"Default": "Coverage"
			},
			"address": {
				"tradle.PersonalInfo": "Address",
				"nl.tradle.CompanyInformation": "Company Address",
				"nl.tradle.MyCompanyRegistration": "Company Address",
				"tradle.CustomerProfile": "CIP Address"
			},
			"socialSecurityNumber": {
				"Default": "Social Security Number"
			},
			"idCardNumber": {
				"Default": "Id Card Number"
			},
			"downPayment": {
				"Default": "Down Payment"
			},
			"stateOfHouse": {
				"Default": "State Of House"
			},
			"term": {
				"Default": "Term"
			},
			"monthlyPayment": {
				"Default": "Monthly Payment"
			},
			"applicationDate": {
				"Default": "Application Date"
			},
			"startMortgageDate": {
				"Default": "Start Mortgage Date"
			},
			"mortgageGuarantee": {
				"Default": "Mortgage Guarantee"
			},
			"totalAmount": {
				"Default": "Total Amount"
			},
			"intermediary": {
				"Default": "Intermediary"
			},
			"notary": {
				"Default": "Notary"
			},
			"natureOfCompany": {
				"Default": "Nature Of Company"
			},
			"dateOfFormation": {
				"Default": "Date Of Formation"
			},
			"address1": {
				"nl.tradle.CompanyInformation": "Address line 1",
				"nl.tradle.MyCompanyRegistration": "Address line 1"
			},
			"address2": {
				"nl.tradle.CompanyInformation": "Address line 2",
				"nl.tradle.MyCompanyRegistration": "Address line 2"
			},
			"myProductId": {
				"nl.tradle.MyBusinessAccount": "Account ID",
				"nl.tradle.MyCompanyRegistration": "Company ID",
				"nl.tradle.MyDigitalPassport": "Digital Passport ID",
				"tradle.MyEmployeeOnboarding": "Employee ID",
				"tradle.MyFineArtInsurance": "Confirmation number",
				"tradle.MyLifeInsurance": "Policy number",
				"tradle.MyMortgageProduct": "Mortgage number",
				"tradle.MyTaxesFiledConfirmation": "Confirmation number",
				"tradle.MyWealthManagementAccount": "Account number"
			},
			"api": {
				"Default": "Api"
			},
			"reference": {
				"Default": "Reference",
				"items": {
					"queryId": "Query Id"
				}
			},
			"title": {
				"Default": "Title"
			},
			"confidence": {
				"Default": "Confidence"
			},
			"aspect": {
				"Default": "Aspect"
			},
			"rawData": {
				"tradle.APIBasedVerificationMethod": "Raw data"
			},
			"provider": {
				"Default": "Provider"
			},
			"addressType": {
				"Default": "Address Type"
			},
			"streetAddress": {
				"Default": "Street Address"
			},
			"address_group": {
				"tradle.Address": "Address",
				"tradle.Profile": "Home Address",
				"tradle.Residence": "Address"
			},
			"state": {
				"Default": "State"
			},
			"citizenship": {
				"Default": "Citizenship"
			},
			"application": {
				"Default": "Application"
			},
			"forms": {
				"Default": "Forms"
			},
			"artist": {
				"Default": "Artist"
			},
			"artworkTitle": {
				"Default": "Artwork Title"
			},
			"medium": {
				"Default": "Medium"
			},
			"partOfCollection": {
				"Default": "Part Of Collection"
			},
			"locationOfArtwork": {
				"Default": "Location Of Artwork"
			},
			"currentMarketValue": {
				"Default": "Current Market Value"
			},
			"areYouTheSoleOwner": {
				"Default": "Are You The Sole Owner"
			},
			"methods": {
				"Default": "Methods"
			},
			"formattedName": {
				"Default": "Formatted Name"
			},
			"dockerhub": {
				"tradle.BetaTesterContactInfo": "Docker Hub username"
			},
			"github": {
				"tradle.BetaTesterContactInfo": "Github username"
			},
			"narrative": {
				"Default": "Narrative"
			},
			"date": {
				"Default": "Date"
			},
			"wealthCV": {
				"tradle.CVItem": "Wealth CV"
			},
			"itemType": {
				"Default": "Item Type"
			},
			"yearTheHouseWasBuilt": {
				"Default": "Year The House Was Built"
			},
			"legalName": {
				"Default": "Legal Name"
			},
			"tradingName": {
				"Default": "Trading Name"
			},
			"registeredAddress_group": {
				"tradle.CompanyInformation": "Registered address"
			},
			"registeredAddress": {
				"tradle.CompanyInformation": "Registered address"
			},
			"r_street": {
				"tradle.CompanyInformation": "Street"
			},
			"r_city": {
				"tradle.CompanyInformation": "City"
			},
			"r_region": {
				"tradle.CompanyInformation": "Region"
			},
			"r_postalCode": {
				"tradle.CompanyInformation": "Postal code"
			},
			"r_country": {
				"tradle.CompanyInformation": "Country"
			},
			"tradingAddress_group": {
				"tradle.CompanyInformation": "Trading address"
			},
			"tradingAddress": {
				"tradle.CompanyInformation": "Trading address"
			},
			"t_street": {
				"tradle.CompanyInformation": "Street"
			},
			"t_city": {
				"tradle.CompanyInformation": "City"
			},
			"t_region": {
				"tradle.CompanyInformation": "Region"
			},
			"t_postalCode": {
				"tradle.CompanyInformation": "Postal code"
			},
			"t_country": {
				"tradle.CompanyInformation": "Country"
			},
			"postalAddress_group": {
				"tradle.CompanyInformation": "Postal address"
			},
			"postalAddress": {
				"tradle.CompanyInformation": "Postal address"
			},
			"p_street": {
				"tradle.CompanyInformation": "Street"
			},
			"p_city": {
				"tradle.CompanyInformation": "City"
			},
			"p_region": {
				"tradle.CompanyInformation": "Region"
			},
			"p_postalCode": {
				"tradle.CompanyInformation": "Postal code"
			},
			"p_country": {
				"tradle.CompanyInformation": "Country"
			},
			"coverHolderContactInformation": {
				"Default": "Cover Holder Contact Information"
			},
			"webSite": {
				"Default": "Web Site"
			},
			"companyOwners": {
				"Default": "Company Owners"
			},
			"items": {
				"Default": "Items"
			},
			"confirmationFor": {
				"Default": "Confirmation For"
			},
			"county": {
				"Default": "County"
			},
			"confirmEmail": {
				"tradle.ContactInformation": "Confirm e-mail"
			},
			"telephone": {
				"Default": "Telephone"
			},
			"pickupLocation": {
				"Default": "Pickup Location"
			},
			"currencyName": {
				"Default": "Currency Name"
			},
			"entityRole": {
				"Default": "Entity Role"
			},
			"entityType": {
				"Default": "Entity Type"
			},
			"position": {
				"tradle.CustomerEntity": "Position/Rank/Title"
			},
			"other": {
				"Default": "Other"
			},
			"suffix": {
				"Default": "Suffix"
			},
			"citizenshipCountry": {
				"Default": "Citizenship Country"
			},
			"residenceCountry": {
				"Default": "Residence Country"
			},
			"ownershipNature": {
				"Default": "Ownership Nature"
			},
			"ownershipPercentage": {
				"Default": "Ownership Percentage"
			},
			"phone": {
				"Default": "Phone"
			},
			"customerName": {
				"Default": "Customer Name"
			},
			"customerOf": {
				"Default": "Customer Of"
			},
			"secondaryName": {
				"Default": "Secondary Name"
			},
			"middle": {
				"Default": "Middle"
			},
			"formType": {
				"tradle.CustomerInfo": "Formation type"
			},
			"ownershipStructure": {
				"tradle.CustomerOwnership": "Ownership Structure"
			},
			"ownershipStructureOther": {
				"tradle.CustomerOwnership": "Ownership Structure Other"
			},
			"bearerShareEntity": {
				"tradle.CustomerOwnership": "Bearer-share Entity"
			},
			"ownerName": {
				"Default": "Owner Name"
			},
			"ownerCountry": {
				"Default": "Owner Country"
			},
			"ownerRegulator": {
				"Default": "Owner Regulator"
			},
			"ownerRegulatorOther": {
				"Default": "Owner Regulator Other"
			},
			"ownerExchange": {
				"Default": "Owner Exchange"
			},
			"ownerExchangeOther": {
				"Default": "Owner Exchange Other"
			},
			"ownerStockSymbol": {
				"tradle.CustomerOwnership": "Owner Stock Symbol/Ticker"
			},
			"pacOwnership": {
				"tradle.CustomerOwnership": "PAC Ownership"
			},
			"cipExemptStatus": {
				"Default": "Cip Exempt Status"
			},
			"cipExemptReason": {
				"Default": "Cip Exempt Reason"
			},
			"internetGambling": {
				"Default": "Internet Gambling"
			},
			"address3": {
				"Default": "Address3"
			},
			"zipCode": {
				"Default": "Zip Code"
			},
			"natureOfCompanyOther": {
				"Default": "Nature Of Company Other"
			},
			"formedLessThenTwoYears": {
				"tradle.CustomerProfile": "Was the customer set within the last 2 years?"
			},
			"patriotActCertification": {
				"tradle.CustomerProfile": "PATRIOT Act Certification"
			},
			"businessOrIndustryType": {
				"tradle.CustomerProfile": "Business/Industry Type"
			},
			"naics": {
				"tradle.CustomerProfile": "NAICS"
			},
			"duns": {
				"tradle.CustomerProfile": "DUNS"
			},
			"wwid": {
				"tradle.CustomerProfile": "WWID"
			},
			"govIdType": {
				"tradle.CustomerProfile": "Gov. ID Type"
			},
			"govIssuedIdNumber": {
				"tradle.CustomerProfile": "Gov. Issued ID Number"
			},
			"govIdIssuingCountry": {
				"tradle.CustomerProfile": "Gov. ID Issuing Country"
			},
			"regulator": {
				"Default": "Regulator"
			},
			"regulatorOther": {
				"Default": "Regulator Other"
			},
			"exchange": {
				"Default": "Exchange"
			},
			"exchangeOther": {
				"Default": "Exchange Other"
			},
			"stockSymbol": {
				"tradle.CustomerProfile": "Stock Symbol/Ticker"
			},
			"debtKind": {
				"Default": "Debt Kind"
			},
			"container": {
				"Default": "Container"
			},
			"photo": {
				"Default": "Photo"
			},
			"eResidencyApplicationType": {
				"tradle.EResidencyApplicationType": "e-Resincy motivation"
			},
			"eResidencyMotivation": {
				"tradle.EResidencyMotivation": "e-Resincy motivation"
			},
			"highestDegree": {
				"Default": "Highest Degree"
			},
			"major": {
				"Default": "Major"
			},
			"diploma": {
				"Default": "Diploma"
			},
			"educationDegree": {
				"Default": "Education Degree"
			},
			"exemptStatus": {
				"Default": "Exempt Status"
			},
			"size": {
				"Default": "Size"
			},
			"mimeType": {
				"Default": "Mime Type"
			},
			"accountingPeriodFrom": {
				"Default": "Accounting Period From"
			},
			"accountingPeriodTo": {
				"Default": "Accounting Period To"
			},
			"theseAccountsAre": {
				"Default": "These Accounts Are"
			},
			"companyLegalStatus": {
				"Default": "Company Legal Status"
			},
			"prefill": {
				"Default": "Prefill"
			},
			"prefilled": {
				"Default": "Prefilled"
			},
			"product": {
				"Default": "Product"
			},
			"verifiers": {
				"Default": "Verifiers"
			},
			"formationType": {
				"Default": "Formation Type"
			},
			"statement": {
				"Default": "Statement"
			},
			"confirmation": {
				"Default": "Confirmation"
			},
			"governmentIdType": {
				"Default": "Government Id Type"
			},
			"session": {
				"Default": "Session"
			},
			"typeOfIdentityDocument": {
				"Default": "Type Of Identity Document"
			},
			"documentNumber": {
				"Default": "Document Number"
			},
			"issuingCountry": {
				"Default": "Issuing Country"
			},
			"documentType": {
				"Default": "Document Type"
			},
			"shareholding": {
				"Default": "Shareholding"
			},
			"CIF": {
				"tradle.InternalInfo": "CIF"
			},
			"trueCustomer": {
				"Default": "True Customer"
			},
			"customerOfWhatBranch": {
				"Default": "Customer Of What Branch"
			},
			"customerType": {
				"tradle.InternalInfo": "Customer type #"
			},
			"investingType": {
				"Default": "Investing Type"
			},
			"evidentiaryDocuments": {
				"Default": "Evidentiary Documents"
			},
			"role": {
				"Default": "Role"
			},
			"territory": {
				"Default": "Territory"
			},
			"licenceName": {
				"Default": "Licence Name"
			},
			"licenceNumber": {
				"Default": "Licence Number"
			},
			"nameOfLicence": {
				"tradle.Licences": "Name on Licence"
			},
			"expiryDate": {
				"Default": "Expiry Date"
			},
			"nonSmokersTariff": {
				"tradle.ORV": "Non-smokers tariff"
			},
			"bankAccountNumber": {
				"Default": "Bank Account Number"
			},
			"location": {
				"Default": "Location"
			},
			"headline": {
				"Default": "Headline"
			},
			"publisher": {
				"Default": "Publisher"
			},
			"datePublished": {
				"Default": "Date Published"
			},
			"index": {
				"Default": "Index"
			},
			"data": {
				"Default": "Data"
			},
			"hash": {
				"Default": "Hash"
			},
			"models": {
				"Default": "Models"
			},
			"commercialProduct": {
				"tradle.MortgageDetail": "Product",
				"tradle.MyMortgageProduct": "Product"
			},
			"piInsurerName": {
				"tradle.MyCoverholderApproval": "PI Insurer Name",
				"tradle.ProfessionalIndemnity": "PI Insurer Name"
			},
			"expiryDateOfCover": {
				"Default": "Expiry Date Of Cover"
			},
			"artworkName": {
				"Default": "Artwork Name"
			},
			"after": {
				"Default": "After"
			},
			"inactive": {
				"Default": "Inactive"
			},
			"nonce": {
				"Default": "Nonce"
			},
			"rendezvous": {
				"Default": "Rendezvous"
			},
			"auth": {
				"Default": "Auth"
			},
			"prev": {
				"Default": "Prev"
			},
			"resource": {
				"Default": "Resource"
			},
			"root": {
				"Default": "Root"
			},
			"proof": {
				"Default": "Proof"
			},
			"leaves": {
				"Default": "Leaves"
			},
			"sig": {
				"Default": "Sig"
			},
			"type": {
				"Default": "Type"
			},
			"context": {
				"Default": "Context"
			},
			"name_group": {
				"tradle.PersonalInfo": "Personal detail"
			},
			"number": {
				"Default": "Number"
			},
			"myPhones": {
				"Default": "My Phones"
			},
			"phoneNumbers": {
				"Default": "Phone Numbers"
			},
			"width": {
				"Default": "Width"
			},
			"height": {
				"Default": "Height"
			},
			"scan": {
				"Default": "Scan"
			},
			"scanJson": {
				"tradle.PhotoID": "Extracted fields"
			},
			"periodOfCover": {
				"Default": "Period Of Cover"
			},
			"coverBinding": {
				"tradle.ProfessionalIndemnity": "Does your professional indemnity cover Lloyd's binding authorities?"
			},
			"startDateOfCover": {
				"Default": "Start Date Of Cover"
			},
			"limitIL": {
				"tradle.ProfessionalIndemnity": "Limit – Individual loss"
			},
			"limitAL": {
				"tradle.ProfessionalIndemnity": "Limit – Aggregate loss"
			},
			"deductible": {
				"tradle.ProfessionalIndemnity": "Deductible – Individual loss"
			},
			"policyCoverActsOfDishonestyByEmployees": {
				"tradle.ProfessionalIndemnity": "Policy cover acts of dishonesty by employees"
			},
			"fidelityInsurancePolicy": {
				"tradle.ProfessionalIndemnity": "Fidelity insurance policy"
			},
			"additionalLinesOfPIcover": {
				"tradle.ProfessionalIndemnity": "Additional lines of PI cover"
			},
			"detailsOfAdditionalLinesOfPIcover": {
				"tradle.ProfessionalIndemnity": "Details of additional lines of cover"
			},
			"numberOfPIclaims": {
				"tradle.ProfessionalIndemnity": "Number of PI claims in the last five years"
			},
			"employment_group": {
				"tradle.Profile": "Employment"
			},
			"bot": {
				"Default": "Bot"
			},
			"isEmployee": {
				"Default": "Is Employee"
			},
			"myForms": {
				"tradle.Profile": "My Data"
			},
			"myDocuments": {
				"tradle.Profile": "Documents"
			},
			"useTouchId": {
				"Default": "Use Touch Id"
			},
			"useGesturePassword": {
				"Default": "Use Gesture Password"
			},
			"coverPhoto": {
				"Default": "Cover Photo"
			},
			"dateNotarized": {
				"Default": "Date Notarized"
			},
			"mainMotivation": {
				"Default": "Main Motivation"
			},
			"description": {
				"Default": "Description"
			},
			"residenceType": {
				"tradle.Residence": "Residence Type"
			},
			"selfie_group": {
				"tradle.Selfie": "Selfie"
			},
			"selfie": {
				"tradle.Selfie": "Selfie"
			},
			"selfieJson": {
				"tradle.Selfie": "Photo info"
			},
			"with": {
				"Default": "With"
			},
			"logoNeedsText": {
				"Default": "Logo Needs Text"
			},
			"linkColor": {
				"Default": "Link Color"
			},
			"productRowBgColor": {
				"Default": "Product Row Bg Color"
			},
			"productRowTextColor": {
				"Default": "Product Row Text Color"
			},
			"sharedWithBg": {
				"Default": "Shared With Bg"
			},
			"sharedWithVerificationBg": {
				"Default": "Shared With Verification Bg"
			},
			"verifiedHeaderColor": {
				"Default": "Verified Header Color"
			},
			"verifiedLinkColor": {
				"Default": "Verified Link Color"
			},
			"verificationBg": {
				"Default": "Verification Bg"
			},
			"verifiedSourcesColor": {
				"Default": "Verified Sources Color"
			},
			"confirmationColor": {
				"Default": "Confirmation Color"
			},
			"confirmationBg": {
				"Default": "Confirmation Bg"
			},
			"requestFulfilled": {
				"Default": "Request Fulfilled"
			},
			"backgroundColor": {
				"Default": "Background Color"
			},
			"productBgColor": {
				"Default": "Product Bg Color"
			},
			"myMessageLinkColor": {
				"Default": "My Message Link Color"
			},
			"myMessageBackgroundColor": {
				"Default": "My Message Background Color"
			},
			"formErrorBorder": {
				"Default": "Form Error Border"
			},
			"formErrorColor": {
				"Default": "Form Error Color"
			},
			"formErrorBg": {
				"Default": "Form Error Bg"
			},
			"structuredMessageBackgroundColor": {
				"Default": "Structured Message Background Color"
			},
			"structuredMessageColor": {
				"Default": "Structured Message Color"
			},
			"structuredMessageBorder": {
				"Default": "Structured Message Border"
			},
			"shareContextTextColor": {
				"Default": "Share Context Text Color"
			},
			"shareContextBackgroundColor": {
				"Default": "Share Context Background Color"
			},
			"currentContextTextColor": {
				"Default": "Current Context Text Color"
			},
			"currentContextBackgroundColor": {
				"Default": "Current Context Background Color"
			},
			"contextBackgroundColor": {
				"Default": "Context Background Color"
			},
			"contextTextColor": {
				"Default": "Context Text Color"
			},
			"shareButtonBackgroundColor": {
				"Default": "Share Button Background Color"
			},
			"backlinkRowBgColor": {
				"Default": "Backlink Row Bg Color"
			},
			"backlinkRowTextColor": {
				"Default": "Backlink Row Text Color"
			},
			"listBg": {
				"Default": "List Bg"
			},
			"listColor": {
				"Default": "List Color"
			},
			"sourcedVerificationBgColor": {
				"Default": "Sourced Verification Bg Color"
			},
			"sourcedVerificationTextColor": {
				"Default": "Sourced Verification Text Color"
			},
			"navBarBackgroundColor": {
				"Default": "Nav Bar Background Color"
			},
			"navBarBorderColor": {
				"Default": "Nav Bar Border Color"
			},
			"navBarBorderWidth": {
				"Default": "Nav Bar Border Width"
			},
			"relevantTaxYear": {
				"Default": "Relevant Tax Year"
			},
			"confirmationText": {
				"Default": "Confirmation Text"
			},
			"confirmationCheck": {
				"Default": "Confirmation Check"
			},
			"introduction": {
				"Default": "Introduction"
			},
			"sharing": {
				"Default": "Sharing"
			},
			"notifications": {
				"Default": "Notifications"
			},
			"digitalSignatures": {
				"Default": "Digital Signatures"
			},
			"changes": {
				"Default": "Changes"
			},
			"contactUs": {
				"Default": "Contact Us"
			},
			"damages": {
				"Default": "Damages"
			},
			"eResidencyApplicatoinType": {
				"Default": "E Residency Applicatoin Type"
			},
			"verifiableAspects": {
				"Default": "Verifiable Aspects"
			},
			"dateVerified": {
				"Default": "Date Verified"
			},
			"cancel": {
				"Default": "Cancel"
			},
			"sources": {
				"Default": "Sources"
			},
			"method": {
				"Default": "Method"
			},
			"item": {
				"Default": "Item"
			},
			"verification": {
				"Default": "Verification"
			},
			"controlNumber": {
				"Default": "Control Number"
			},
			"issuingPostName": {
				"Default": "Issuing Post Name"
			},
			"visaClass": {
				"Default": "Visa Class"
			},
			"visaType": {
				"Default": "Visa Type"
			},
			"documentPresence": {
				"Default": "Document Presence"
			},
			"ownerPresence": {
				"Default": "Owner Presence"
			},
			"cvItems": {
				"tradle.WealthCV": "Wealth items"
			},
			"currentBalance": {
				"Default": "Current Balance"
			},
			"requireRawData": {
				"Default": "Require Raw Data"
			}
		},
		"models": {
			"tradle.AdditionalInfo": "Additional Information",
			"tradle.BusinessAccount": "Business Account",
			"tradle.BusinessInformation": "Business Information",
			"tradle.Country": "Country",
			"tradle.CreditCards": "Credit Cards",
			"tradle.CustomerIdentification": "Customer identification",
			"tradle.CustomerWaiting": "Customer waiting",
			"tradle.Enum": "Enum",
			"tradle.FinancialProduct": "Financial Product",
			"tradle.ForgetMe": "Forget Me",
			"tradle.ForgotYou": "Forgot You",
			"tradle.Form": "Form",
			"tradle.FormError": "Form Error",
			"tradle.HealthInsurance": "Health Insurance",
			"tradle.HomeImprovement": "Home Improvement",
			"tradle.HomeInsurance": "Home Insurance",
			"tradle.HowToFund": "How To Fund",
			"tradle.ISAs": "ISAs",
			"tradle.Identity": "Identity",
			"tradle.IdentityPublishRequest": "Identity Publish Request",
			"tradle.IncomeProtectionInsurance": "Income Protection Insurance",
			"tradle.Investments": "Investments",
			"tradle.JumboMortgage": "Jumbo Mortgage",
			"tradle.LicenseVerification": "License Verification",
			"tradle.LifeInsurance": "Life Insurance",
			"tradle.Loan": "Loan",
			"tradle.MaritalStatus": "Marital Status",
			"tradle.Message": "Message",
			"tradle.Mortgage": "Mortgage",
			"tradle.MortgageLoanDetail": "Mortgage Loan Details",
			"tradle.MotorInsurance": "Motor Insurance",
			"tradle.MyIdentities": "My Identities",
			"tradle.Nationality": "Nationality",
			"tradle.NewMessageModel": "New message model",
			"tradle.Organization": "Organization",
			"tradle.PassportVerification": "Passport Verification",
			"tradle.Pension": "Pension",
			"tradle.PhoneTypes": "Phone Types",
			"tradle.ProductList": "Product List",
			"tradle.Profile": "Profile",
			"tradle.PropertyInformation": "Property Information",
			"tradle.PropertyType": "Property Type",
			"tradle.PropertyTypes": "Property Types",
			"tradle.PurposeOfMortgageLoan": "Purpose of mortgage loan",
			"tradle.PurposeOfTheAccount": "Purpose Of The Account",
			"tradle.Refinancing": "Refinancing",
			"tradle.SalaryVerification": "Salary Verification",
			"tradle.SalesData": "Sales Data for last year",
			"tradle.SecurityCode": "Security Code",
			"tradle.SelfIntroduction": "Self introduction",
			"tradle.Settings": "Settings",
			"tradle.SimpleMessage": "Simple Message",
			"tradle.SkillVerification": "Skill Verification",
			"tradle.TermInsurance": "Term Insurance",
			"tradle.UtilityBillVerification": "Utility Bill Verification",
			"tradle.Verification": "Verification",
			"tradle.YourMoney": "Your Money",
			"tradle.AboutYou": "About You",
			"tradle.AutoInsurance": "Auto Insurance",
			"tradle.CurrentAccount": "Current Account",
			"tradle.Language": "Language",
			"tradle.RequestForRepresentative": "Request for representative",
			"tradle.ResidentialStatus": "Residential Status",
			"tradle.Boolean": "Energy Label",
			"tradle.Collateral": "Collateral/House",
			"tradle.ContractType": "Contract Type",
			"tradle.LoanTypes": "Loan Types",
			"tradle.EducationNL": "Education",
			"tradle.EnergyLabel": "Energy Label",
			"tradle.IDCardType": "ID Card",
			"tradle.Income": "Income",
			"tradle.InsuranceInfo": "Insurance Information",
			"tradle.InterestType": "Interest Type",
			"tradle.KindOfConstruction": "Kind Of Construction",
			"tradle.KindOfEngagement": "Kind Of Engagement",
			"tradle.KindOfHouse": "Kind Of House",
			"tradle.KindOfInsurance": "Kind Of Insurance",
			"tradle.KindOfObligation": "Kind of Obligation",
			"tradle.LoanPart": "Loan Part",
			"tradle.MortgageDetail": "Mortgage Detail",
			"tradle.MortgageProduct": "Mortgage",
			"tradle.MortgageProductType": "Mortgage Product Type",
			"tradle.ObligationsDebts": "Obligations / Debts",
			"tradle.OtherCollaterals": "Other Collaterals",
			"tradle.PaymentPeriod": "Payment Period",
			"tradle.PersonalInfo": "Personal Info",
			"tradle.Posessions": "Posessions",
			"tradle.TypeOfCoverage": "Type Of Coverage",
			"tradle.StateOfHouse": "State of House",
			"tradle.SourceOfIncome": "Source Of Income",
			"tradle.StatusOfInsurance": "Status Of Insurance",
			"tradle.Terms": "Terms",
			"tradle.CommercialProductType": "Commercial Product Type",
			"nl.tradle.BusinessAccount": "Business Account",
			"nl.tradle.CompanyInformation": "Company Information",
			"nl.tradle.CompanyRegistration": "Company Registration",
			"nl.tradle.DigitalPassport": "Digital Passport",
			"nl.tradle.MyBusinessAccount": "My Business Account",
			"nl.tradle.MyCompanyRegistration": "My Company Registration",
			"nl.tradle.MyDigitalPassport": "My Digital Passport",
			"tradle.APIBasedVerificationMethod": "API based verification",
			"tradle.API": "API",
			"tradle.ActivityLicense": "Activity license",
			"tradle.AddressType": "Address Type",
			"tradle.Address": "Address",
			"tradle.AllowanceAppForNonProfit": "Allowance application for nonprofit organization",
			"tradle.AppState": "App State",
			"tradle.ApplicationForEResidency": "Application for e-Residency",
			"tradle.ApplicationSubmitted": "Application Submitted",
			"tradle.ArtworkInfo": "Artwork Info",
			"tradle.Aspect": "Aspect",
			"tradle.BasicContactInfo": "Basic Contact Info",
			"tradle.BetaTesterContactInfo": "Beta Tester Contact Info",
			"tradle.CVItem": "Wealth item",
			"tradle.CancelAccount": "Cancel e-Residency",
			"tradle.CollaterizedLoan": "Collaterized Loan",
			"tradle.CommercialProduct": "Commercial Product",
			"tradle.CompanyInformation": "Company Information",
			"tradle.CompanyOwners": "Company Owners",
			"tradle.CompanyRegistration": "Company registration",
			"tradle.ConfirmPackageRequest": "Confirm Package Request",
			"tradle.Confirmation": "Confirmation",
			"tradle.ContactInformation": "Contact Information",
			"tradle.CorporateAccount": "Corporate Account",
			"tradle.CoverholderApproval": "Coverholder Application",
			"tradle.Currency": "Currency",
			"tradle.CustomerEntity": "Corporate Entity",
			"tradle.CustomerInfo": "Corporate Info",
			"tradle.CustomerOwnership": "Corporate Ownership",
			"tradle.CustomerProfile": "Corporate Profile",
			"tradle.DebtKind": "Debt Kind",
			"tradle.Document": "Document",
			"tradle.DriverLicense": "Driver License",
			"tradle.EResidencyApplicationType": "e-Residency application type",
			"tradle.EResidency": "e-Residency Application",
			"tradle.EResidencyMotivation": "e-Residency motivation",
			"tradle.EarthworkApplication": "Earthwork application",
			"tradle.Education": "Education",
			"tradle.EducationDegree": "Degree of education",
			"tradle.EmployeeOnboarding": "Employee Onboarding",
			"tradle.Exchange": "Exchange",
			"tradle.ExemptStatus": "Exempt Status",
			"tradle.File": "File",
			"tradle.Financials": "Financials",
			"tradle.FineArtInsurance": "Fine Art Insurance",
			"tradle.ForestNotice": "Forest Notice",
			"tradle.FormRequest": "Form Request",
			"tradle.FormationType": "Formation Type",
			"tradle.Funds": "Funds",
			"tradle.GovernmentIdType": "Government Id Type",
			"tradle.GuestSessionProof": "Guest Session Proof",
			"tradle.IdentificationDetail": "Identification Detail",
			"tradle.IdentityDocumentType": "Identity document type",
			"tradle.IndividualOwners": "Individual Owners",
			"tradle.InternalInfo": "Internal Info",
			"tradle.Introduction": "Introduction",
			"tradle.InvestingExperience": "Investing Experience",
			"tradle.InvestingType": "Investing Type",
			"tradle.Item": "Item",
			"tradle.KeyStaff": "Key Staff",
			"tradle.Licences": "Licences",
			"tradle.ORV": "Life Insurance",
			"tradle.LoanDetail": "Loan Detail",
			"tradle.Location": "Location",
			"tradle.Major": "Major",
			"tradle.MediaSnippet": "Media Snippet",
			"tradle.MerkleLeaf": "Merkle Leaf",
			"tradle.MerkleNode": "Merkle Node",
			"tradle.Method": "Method",
			"tradle.ModelsPack": "Models Pack",
			"tradle.Money": "Money",
			"tradle.MortgageGuarantee": "Mortgage Guarantee",
			"tradle.MyCoverholderApproval": "My Coverholder Approval",
			"tradle.MyEmployeeOnboarding": "My Employee Pass",
			"tradle.MyFineArtInsurance": "My Fine Art Insurance",
			"tradle.MyLifeInsurance": "My Life Insurance",
			"tradle.MyMortgageProduct": "My Mortgage",
			"tradle.MyProduct": "My Product",
			"tradle.MyTaxesFiledConfirmation": "My Taxes Filed Confirmation",
			"tradle.MyWealthManagementAccount": "My Wealth Management Account",
			"tradle.NextFormRequest": "NextFormRequest",
			"tradle.NotarizePowerOfAttorney": "Notarize Power of Attorney",
			"tradle.NotarizePropertyOwnership": "Notarize Property Ownership",
			"tradle.OwnershipStructure": "Ownership Structure",
			"tradle.PairingData": "Pairing Data",
			"tradle.PairingRequest": "Pairing Request",
			"tradle.PairingResponse": "Pairing Response",
			"tradle.Partial": "Partial",
			"tradle.Passport": "Passport",
			"tradle.Phone": "Phone",
			"tradle.PhoneBill": "Phone Bill",
			"tradle.Photo": "Photo",
			"tradle.PhotoID": "Photo ID",
			"tradle.ProductApplication": "ProductApplication",
			"tradle.ProfessionalIndemnity": "Professional Indemnity",
			"tradle.ProjectApplication": "Project application",
			"tradle.PropertyOwnership": "Property Ownership",
			"tradle.QualifiedInvestor": "Qualified Investor",
			"tradle.ReasonForApplication": "Reason for application",
			"tradle.Regulator": "Regulator",
			"tradle.Remediation": "Remediation",
			"tradle.RemediationSimpleMessage": "Remediation Simple Message",
			"tradle.RepaymentType": "RepaymentType",
			"tradle.ReportForNonProfitAllowanceUsage": "Report of nonprofit organization allowance usage",
			"tradle.Residence": "Residence",
			"tradle.ResidenceType": "Residence Type",
			"tradle.SocialSecurityNumber": "Social Security Number",
			"tradle.Selfie": "Selfie",
			"tradle.ServiceProvider": "Service Provider",
			"tradle.Sex": "Sex",
			"tradle.ShareContext": "Share Context",
			"tradle.SharedResource": "Shared Resource",
			"tradle.StylesPack": "Styles Pack",
			"tradle.TaxesFiledConfirmation": "Taxes Filed Confirmation",
			"tradle.TaxesFiledConfirmationForm": "Taxes Filed",
			"tradle.TermsAndConditions": "TermsAndConditions",
			"tradle.TypeOfApplication": "Type of application",
			"tradle.Verifiable": "Verifiable",
			"tradle.VerifiedItem": "VerifiedItem",
			"tradle.Visa": "Visa",
			"tradle.VisualVerificationMethod": "Visual Verification Method",
			"tradle.WealthManagementPassport": "Wealth Management Passport",
			"tradle.WealthCV": "Source of Wealth",
			"tradle.WealthItemType": "Wealth Item Type",
			"tradle.WealthManagementAccount": "Wealth Management Account",
			"tradle.WebSite": "Web site",
			"tradle.WellDrilling": "Well drilling location endorsement",
			"tradle.YourBalance": "Your Balance",
			"tradle.EmailAddress": "Email Address",
			"tradle.Ack": "Item Received",
			"tradle.Name": "Name"
		}
	};

/***/ },

/***/ 1649:
/***/ function(module, exports) {

	module.exports = {
		"properties": {
			"message": {
				"Default": "Bericht",
				"tradle.SalaryVerification": "Description",
				"tradle.SkillVerification": "Description",
				"tradle.Verification": "Description"
			},
			"from": {
				"Default": "Van",
				"tradle.Verification": "Verifier"
			},
			"to": {
				"Default": "Aan",
				"tradle.Verification": "Owner"
			},
			"time": {
				"Default": "Tijd"
			},
			"document": {
				"Default": "Document",
				"tradle.Verification": "Verifying document"
			},
			"confirmed": {
				"Default": "Bevestigd"
			},
			"companyName": {
				"Default": "Bedrijfsnaam"
			},
			"DBAName": {
				"tradle.BusinessInformation": "Database naam"
			},
			"registrationNumber": {
				"Default": "Registratie nummer"
			},
			"registrationDate": {
				"Default": "Registratie datum"
			},
			"taxIdNumber": {
				"tradle.BusinessInformation": "BTW nummer"
			},
			"officialAddress": {
				"Default": "Adres"
			},
			"actualAddress": {
				"Default": "Correspondentie adres"
			},
			"country": {
				"Default": "Land"
			},
			"companyPhone": {
				"Default": "Werk telefoonnummer"
			},
			"companyFax": {
				"Default": "Werk fax"
			},
			"companyEmail": {
				"Default": "Werk Email"
			},
			"numberOfEmployees": {
				"Default": "Totaal aantal werknemers"
			},
			"photos": {
				"Default": "Fotos",
				"tradle.LicenseVerification": "Document Snapshots",
				"tradle.AboutYou": "Photo ID snapshots",
				"tradle.PersonalInfo": "Photo ID snapshots",
				"tradle.Posessions": "Snapshot of the document",
				"tradle.SocialSecurityNumber": "Photo ID snapshots"
			},
			"currency": {
				"Default": "Valuta"
			},
			"symbol": {
				"Default": "Valuta symbool"
			},
			"contactsIntroducingCompany": {
				"Default": "Inbrengend bedrijf"
			},
			"introducedParentCompany": {
				"tradle.CustomerIdentification": "Bedrijfsnaam (zoals geregistreerd bij KvK) "
			},
			"accountName": {
				"tradle.CustomerIdentification": "Account naam"
			},
			"officeAddress": {
				"Default": "Kantoor adres"
			},
			"countryOfOrigin": {
				"Default": "Land"
			},
			"contactPerson": {
				"Default": "Contact persoon"
			},
			"isYourCompanyListed": {
				"Default": "Is het bedrijf geregistreerd?"
			},
			"stockExchange": {
				"Default": "Stock Exchange"
			},
			"welcome": {
				"Default": "Welkom"
			},
			"organization": {
				"Default": "Organisatie"
			},
			"form": {
				"Default": "Formulier"
			},
			"errors": {
				"Default": "Foutmeldingen"
			},
			"verifications": {
				"Default": "Verificaties"
			},
			"referencedBy": {
				"Default": "Doorgestuurd door"
			},
			"howToFund": {
				"Default": "Financiering"
			},
			"pubkeys": {
				"Default": "Publieke sleutel"
			},
			"identity": {
				"Default": "Identiteit"
			},
			"accountWith": {
				"Default": "Account met"
			},
			"licenseNumber": {
				"Default": "Licentie nummer"
			},
			"surname": {
				"Default": "Achternaam"
			},
			"givenName": {
				"Default": "Meisjesnaam"
			},
			"dateOfBirth": {
				"Default": "Geboorte datum"
			},
			"dateOfIssue": {
				"Default": "Datum van uitgifte"
			},
			"dateOfExpiry": {
				"Default": "Vervaldatum"
			},
			"issuingAuthority": {
				"Default": "Uitgegeven door"
			},
			"holderAddress": {
				"Default": "Adres"
			},
			"entitlementCategories": {
				"Default": "Entitlement Categories"
			},
			"blockchainUrl": {
				"Default": "Blockchain Url"
			},
			"transactionHash": {
				"Default": "Transaction Hash"
			},
			"additionalInfo": {
				"Default": "Additionele informatie"
			},
			"status": {
				"Default": "Status"
			},
			"relatedTo": {
				"Default": "Gerelateert tot"
			},
			"value": {
				"Default": "Waarde"
			},
			"purposeOfMortgageLoan": {
				"Default": "Doel van de hypotheek"
			},
			"totalAmountRequired": {
				"Default": "Totaal hypotheek bedrag"
			},
			"totalValueOfProperty": {
				"Default": "Waarde van het object"
			},
			"propertyStreetAddress": {
				"Default": "Object Adres"
			},
			"region": {
				"Default": "Provincie"
			},
			"city": {
				"Default": "Stad"
			},
			"postalCode": {
				"Default": "Postcode"
			},
			"formattedAddress": {
				"tradle.MortgageLoanDetail": "Adres van het object",
				"tradle.Organization": "Adres",
				"tradle.Profile": "Adres",
				"tradle.PropertyInformation": "Adres van het object",
				"tradle.UtilityBillVerification": "Adres",
				"tradle.Collateral": "Address"
			},
			"propertyType": {
				"Default": "Object Type"
			},
			"sizeOfProperty": {
				"Default": "Grootte object"
			},
			"currentIdentity": {
				"Default": "Huidige Identiteit"
			},
			"allIdentities": {
				"Default": "Alle Identititeiten"
			},
			"nationality": {
				"Default": "Nationaliteit"
			},
			"url": {
				"Default": "Url",
				"tradle.Settings": "Server URL"
			},
			"name": {
				"Default": "Naam"
			},
			"email": {
				"Default": "Email"
			},
			"street": {
				"Default": "Straat"
			},
			"contacts": {
				"Default": "Contacts"
			},
			"lastMessage": {
				"Default": "Last bericht"
			},
			"lastMessageTime": {
				"Default": "Last bericht tijd"
			},
			"securityCodes": {
				"Default": "Beveligingscodes"
			},
			"verificationsCount": {
				"Default": "Verificatie telling"
			},
			"verificationRequests": {
				"Default": "Verificatie requests"
			},
			"products": {
				"Default": "Producten"
			},
			"codeOfIssuing": {
				"Default": "Code Of Issuing"
			},
			"passportNumber": {
				"Default": "Paspoort Nummer"
			},
			"sex": {
				"Default": "Geslacht"
			},
			"placeOfBirth": {
				"Default": "Geboorteplaats"
			},
			"authority": {
				"Default": "Authority"
			},
			"phoneType": {
				"Default": "Type telefoonnummer"
			},
			"list": {
				"Default": "Lijst"
			},
			"securityCode": {
				"Default": "Beveiligingscode"
			},
			"firstName": {
				"Default": "Voornaam"
			},
			"lastName": {
				"Default": "Achternaam"
			},
			"formatted": {
				"Default": "Formatted"
			},
			"middleName": {
				"Default": "Middelste naam"
			},
			"verifiedByMe": {
				"Default": "Geverifieerd door mij"
			},
			"myProducts": {
				"tradle.Profile": "Producten"
			},
			"myVerifications": {
				"tradle.Profile": "Verificaties"
			},
			"myRequests": {
				"tradle.Profile": "Verzoeken"
			},
			"summary": {
				"Default": "Samenvatting"
			},
			"websites": {
				"Default": "Websites"
			},
			"bedrooms": {
				"tradle.PropertyInformation": "Aantal Slaapkamers"
			},
			"bathrooms": {
				"tradle.PropertyInformation": "Aantal badkamers"
			},
			"yearBuilt": {
				"tradle.PropertyInformation": "Bouwjaar"
			},
			"purpose": {
				"Default": "Doel"
			},
			"averageMonthlySales": {
				"Default": "Gemiddelde maandelijkse verkopen"
			},
			"averageTxsPerMonth": {
				"Default": "Gemiddelde hoeveelheid BTW per maand"
			},
			"averageTxAmount": {
				"Default": "Gemiddeld BTW bedrag"
			},
			"numberOfChargebacks": {
				"Default": "Aantal Chargebacks"
			},
			"volumeOfChargebacks": {
				"tradle.SalesData": "Totaal bedrag chargebacks"
			},
			"settlementCurrency": {
				"Default": "Settlement Valuta"
			},
			"code": {
				"Default": "Code"
			},
			"billDate": {
				"Default": "Factuur datum"
			},
			"issuedBy": {
				"Default": "Uitgegeven door"
			},
			"employer": {
				"Default": "Werkgever"
			},
			"howLongHaveYouWorkedHere": {
				"Default": "Hoe lang werk je al hier"
			},
			"monthlyIncome": {
				"Default": "Maandinkomen"
			},
			"residentialStatus": {
				"Default": "Verblijfsstatus"
			},
			"maritalStatus": {
				"Default": "Burgerlijke staat"
			},
			"dependants": {
				"Default": "Dependants"
			},
			"countryOfBirth": {
				"Default": "Geboorteland"
			},
			"taxResidency": {
				"Default": "Belastingplichtig in"
			},
			"fundAccount": {
				"Default": "Rekening Courant"
			},
			"purposeOfTheAccount": {
				"Default": "Doel van de rekening"
			},
			"emailAddress": {
				"Default": "E-mailadres"
			},
			"commercialProduct": {
				"Default": "Product Type",
				"tradle.MortgageDetail": "Status verzekering"
			},
			"inUKFrom": {
				"tradle.CurrentAccount": "In UK from"
			},
			"language": {
				"Default": "Taal"
			},
			"boolean": {
				"Default": "Boolean"
			},
			"houseNumber": {
				"Default": "Huisnummer"
			},
			"houseValue": {
				"Default": "House Value"
			},
			"kindOfConstruction": {
				"Default": "Type bouw"
			},
			"kindOfHouse": {
				"Default": "Type woning"
			},
			"additionalCosts": {
				"Default": "Kosten koper"
			},
			"restructuringCosts": {
				"Default": "Verbouwingskosten"
			},
			"leaseholdKind": {
				"Default": "Erfpachtsoort"
			},
			"leaseholdAmount": {
				"Default": "Erfpachtcanon"
			},
			"yearTheHouseWasBuild": {
				"Default": "Bouwjaar"
			},
			"rented": {
				"tradle.Collateral": "Verhuurd?"
			},
			"purchasePrice": {
				"Default": "Koopsom"
			},
			"valuedPrice": {
				"Default": "Getaxeerde marktwaarde"
			},
			"foreclosureValue": {
				"Default": "Executiewaarde"
			},
			"badMaintenanceAmount": {
				"Default": "Achterstallig onderhoud"
			},
			"energyLabel": {
				"Default": "Energielabel"
			},
			"contractType": {
				"Default": "Contract Type"
			},
			"loanType": {
				"Default": "Aanvraagtype"
			},
			"education": {
				"Default": "Hoogst genoten opleiding"
			},
			"idCardType": {
				"Default": "ID bewijs type",
				"tradle.PersonalInfo": "ID bewijs type"
			},
			"sourceOfIncome": {
				"Default": "Inkomstenbron"
			},
			"nameOfEmployer": {
				"Default": "Naam werkgever"
			},
			"residenceOfEmployer": {
				"Default": "Woonplaats werkgever"
			},
			"occupation": {
				"Default": "Beroep"
			},
			"kindOfEngagement": {
				"Default": "Soort dienstverband"
			},
			"startDate": {
				"Default": "Ingangsdatum"
			},
			"yearsOfSelfEmployment": {
				"Default": "Aantal jaren zelfstandig"
			},
			"grossYearlyIncome": {
				"Default": "Bruto Jaarsalaris"
			},
			"holidayMoney": {
				"Default": "Vakantietoeslag"
			},
			"provisionalIncome": {
				"Default": "Provisie inkomen"
			},
			"additionalMonthOfPayment": {
				"Default": "13e maand"
			},
			"irregularityCompensation": {
				"Default": "Onregelmatigheidstoeslag"
			},
			"overtimeCompensation": {
				"Default": "Overwerk"
			},
			"bonus": {
				"Default": "Eindejaarsuitkering"
			},
			"totalIncome": {
				"Default": "Totaal inkomen"
			},
			"insuredAmount": {
				"Default": "Insured Amount"
			},
			"typeOfCoverage": {
				"Default": "Type Of Coverage"
			},
			"insuranceFee": {
				"Default": "Insurance Fee"
			},
			"endDate": {
				"Default": "Einddatum"
			},
			"insurancePolicyNumber": {
				"Default": "Insurance Policy Number"
			},
			"policyHolder": {
				"Default": "Verzekeringnemers"
			},
			"insured": {
				"tradle.InsuranceInfo": "Insured person or object"
			},
			"beneficiary": {
				"Default": "Beneficiary"
			},
			"pledge": {
				"Default": "Pledge"
			},
			"pledgedTo": {
				"Default": "Pledged To"
			},
			"interestType": {
				"Default": "Rentevorm"
			},
			"kindOfInsurance": {
				"Default": "Soort verzekering"
			},
			"kindOfObligation": {
				"Default": "Soort verplichting"
			},
			"amount": {
				"Default": "Bedrag"
			},
			"interestPercentage": {
				"Default": "Rente percentage"
			},
			"monthlyPremium": {
				"Default": "Premie/Inleg"
			},
			"repaymentType": {
				"Default": "Aflosvorm"
			},
			"loanPartID": {
				"tradle.LoanPart": "Leningdeelnummer"
			},
			"duration": {
				"Default": "Looptijd leningdeel"
			},
			"mortgageNumber": {
				"Default": "Leningnummer"
			},
			"creditLimit": {
				"Default": "Hoogte krediet"
			},
			"payment": {
				"Default": "Lasten"
			},
			"paymentPeriod": {
				"Default": "Betaalfrequentie"
			},
			"insuranceCompany": {
				"Default": "Maatschappij"
			},
			"statusOfInsurance": {
				"Default": "Status verzekering"
			},
			"yearsOfInsurance": {
				"Default": "Looptijd"
			},
			"amountToTransfer": {
				"Default": "Afkoopwaarde"
			},
			"insuredPersons": {
				"Default": "Verzekerden"
			},
			"policyNumber": {
				"Default": "Polisnummer"
			},
			"coverage": {
				"Default": "Dekkingswaarde"
			},
			"address": {
				"tradle.PersonalInfo": "Adres"
			},
			"socialSecurityNumber": {
				"Default": "Burgerservice nummer"
			},
			"idCardNumber": {
				"Default": "Nummer ID Bewijs"
			},
			"downPayment": {
				"Default": "Eigen inbreng"
			},
			"term": {
				"Default": "Term"
			},
			"monthlyPayment": {
				"Default": "Maandlast"
			},
			"applicationDate": {
				"Default": "Aanvraagdatum"
			},
			"startMortgageDate": {
				"Default": "Passeerdatum"
			},
			"mortgageGuarantee": {
				"Default": "Hypotheekgarantie"
			},
			"intermediary": {
				"Default": "Intermediair"
			},
			"notary": {
				"Default": "Notaris"
			},
			"mortgageAmount": {
				"Default": "Mortgage Amount"
			},
			"yearTheHouseWasBuilt": {
				"Default": "Bouwjaar"
			},
			"productType": {
				"Default": "Product Type"
			},
			"prefilled": {
				"Default": "Prefilled"
			},
			"session": {
				"Default": "Session"
			},
			"nonSmokersTariff": {
				"tradle.ORV": "Non-smokers tariff"
			},
			"bankAccountNumber": {
				"Default": "Bank Account Number"
			},
			"totalAmount": {
				"Default": "Total Amount"
			},
			"currentBalance": {
				"Default": "Current Balance"
			},
			"date": {
				"Default": "Date"
			},
			"phones": {
				"Default": "Telefoon nummers",
				"items": {
					"phoneType": "Type telefoon",
					"number": "Telefoonnummer"
				}
			}
		},
		"models": {
			"tradle.AdditionalInfo": "Additional Information",
			"tradle.SocialSecurityNumber": "Burgerservice nummer",
			"tradle.BusinessAccount": "Zakelijke account",
			"tradle.BusinessInformation": "Business Information",
			"tradle.Country": "Land",
			"tradle.CreditCards": "Credit Cards",
			"tradle.CustomerIdentification": "Customer identification",
			"tradle.CustomerWaiting": "Customer waiting",
			"tradle.Enum": "Enum",
			"tradle.FinancialProduct": "Financial Product",
			"tradle.ForgetMe": "Forget Me",
			"tradle.ForgotYou": "Forgot You",
			"tradle.Form": "Form",
			"tradle.HealthInsurance": "Health Insurance",
			"tradle.HomeImprovement": "Home Improvement",
			"tradle.HomeInsurance": "Home Insurance",
			"tradle.HowToFund": "How To Fund",
			"tradle.ISAs": "ISAs",
			"tradle.Identity": "Identity",
			"tradle.IdentityPublishRequest": "Identity Publish Request",
			"tradle.IncomeProtectionInsurance": "Income Protection Insurance",
			"tradle.Investments": "Investments",
			"tradle.JumboMortgage": "Jumbo Mortgage",
			"tradle.LicenseVerification": "License Verification",
			"tradle.LifeInsurance": "Life Insurance",
			"tradle.Loan": "Loan",
			"tradle.MaritalStatus": "Burgelijke staat",
			"tradle.Message": "Bericht",
			"tradle.Mortgage": "Hypotheek",
			"tradle.MortgageLoanDetail": "Adres van het object",
			"tradle.MotorInsurance": "Motor Insurance",
			"tradle.MyIdentities": "My Identities",
			"tradle.Nationality": "Nationaliteit",
			"tradle.NewMessageModel": "New message model",
			"tradle.Organization": "Organisatie",
			"tradle.PassportVerification": "Passport Verification",
			"tradle.Pension": "Pension",
			"tradle.PhoneTypes": "Type telefoonnummer",
			"tradle.ProductList": "Product List",
			"tradle.Profile": "Profiel",
			"tradle.PropertyInformation": "Property Information",
			"tradle.PropertyType": "Property Type",
			"tradle.PropertyTypes": "Property Types",
			"tradle.PurposeOfMortgageLoan": "Doel van de hypotheek",
			"tradle.PurposeOfTheAccount": "Doel van de rekening",
			"tradle.Refinancing": "Refinancing",
			"tradle.SalaryVerification": "Salary Verification",
			"tradle.SalesData": "Sales Data for last year",
			"tradle.SecurityCode": "Security Code",
			"tradle.SelfIntroduction": "Self introduction",
			"tradle.Settings": "Settings",
			"tradle.SimpleMessage": "Simple Message",
			"tradle.SkillVerification": "Skill Verification",
			"tradle.TermInsurance": "Term Insurance",
			"tradle.UtilityBillVerification": "Utility Bill Verification",
			"tradle.Verification": "Verification",
			"tradle.YourMoney": "Your Money",
			"tradle.AboutYou": "Over jou",
			"tradle.AutoInsurance": "Auto Insurance",
			"tradle.CurrentAccount": "Lopende rekening",
			"tradle.Language": "Taal",
			"tradle.RequestForRepresentative": "Request for representative",
			"tradle.ResidentialStatus": "Verblijfsstatus",
			"tradle.Collateral": "Onderpand (or Woning)",
			"tradle.ContractType": "Contract Type",
			"tradle.LoanTypes": "Aanvraagtype",
			"tradle.EducationNL": "Opleiding",
			"tradle.EnergyLabel": "Energielabel",
			"tradle.IDCardType": "ID Card",
			"tradle.Income": "Inkomen",
			"tradle.InsuranceInfo": "Insurance Information",
			"tradle.InterestType": "Rentevorm",
			"tradle.KindOfConstruction": "Type bouw",
			"tradle.KindOfEngagement": "Soort dienstverband",
			"tradle.KindOfHouse": "Type woning",
			"tradle.KindOfInsurance": "Soort verzekering",
			"tradle.KindOfObligation": "Soort verplichting",
			"tradle.LoanPart": "Leningdelen",
			"tradle.MortgageDetail": "Hypotheek",
			"tradle.MortgageProduct": "Hypotheek",
			"tradle.MortgageProductType": "Commercieel product",
			"tradle.ObligationsDebts": "Schulden en verplichtingen",
			"tradle.OtherCollaterals": "Zekerheden",
			"tradle.PaymentPeriod": "Betaalfrequentie",
			"tradle.PersonalInfo": "Over mij",
			"tradle.Posessions": "Bezittingen (or Eigen vermogen)",
			"tradle.TypeOfCoverage": "Verloop dekking",
			"tradle.SourceOfIncome": "Inkomstenbron",
			"tradle.StatusOfInsurance": "Status verzekering",
			"tradle.Terms": "Terms",
			"tradle.CommercialProduct": "Status verzekering",
			"tradle.FormError": "Form Error",
			"tradle.GuestSessionProof": "Guest Session Proof",
			"tradle.ORV": "ORV - Life Insurance",
			"tradle.MortgageGuarantee": "Mortgage Guarantee",
			"tradle.RepaymentType": "RepaymentType",
			"tradle.YourBalance": "Your Balance"
		}
	};

/***/ },

/***/ 1650:
/***/ function(module, exports) {

	module.exports = {
		"properties": {
			"message": {
				"Default": "Message",
				"tradle.SalaryVerification": "Description",
				"tradle.SkillVerification": "Description",
				"tradle.Verification": "Description"
			},
			"from": {
				"Default": "From",
				"tradle.Verification": "Verifier"
			},
			"to": {
				"Default": "To",
				"tradle.Verification": "Owner"
			},
			"time": {
				"Default": "Time"
			},
			"document": {
				"Default": "Document",
				"tradle.Verification": "Verifying document"
			},
			"confirmed": {
				"Default": "Confirmed"
			},
			"companyName": {
				"Default": "Company Name"
			},
			"DBAName": {
				"tradle.BusinessInformation": "DBA Name"
			},
			"registrationNumber": {
				"Default": "Registration Number"
			},
			"registrationDate": {
				"Default": "Registration Date"
			},
			"taxIdNumber": {
				"tradle.BusinessInformation": "Tax ID Number"
			},
			"officialAddress": {
				"Default": "Official Address"
			},
			"actualAddress": {
				"Default": "Actual Address"
			},
			"country": {
				"Default": "Country"
			},
			"companyPhone": {
				"Default": "Company Phone"
			},
			"companyFax": {
				"Default": "Company Fax"
			},
			"companyEmail": {
				"Default": "Company Email"
			},
			"numberOfEmployees": {
				"Default": "Number Of Employees"
			},
			"photos": {
				"Default": "Photos",
				"tradle.LicenseVerification": "Document Snapshots",
				"tradle.AboutYou": "Photo ID snapshots"
			},
			"currency": {
				"Default": "Currency"
			},
			"symbol": {
				"Default": "Symbol"
			},
			"contactsIntroducingCompany": {
				"Default": "Contacts Introducing Company"
			},
			"introducedParentCompany": {
				"tradle.CustomerIdentification": "Introduced Parent Company (legally registered name of entity) "
			},
			"accountName": {
				"tradle.CustomerIdentification": "Account name"
			},
			"officeAddress": {
				"Default": "Office Address"
			},
			"countryOfOrigin": {
				"Default": "Country Of Origin"
			},
			"contactPerson": {
				"Default": "Contact Person"
			},
			"isYourCompanyListed": {
				"Default": "Is Your Company Listed"
			},
			"stockExchange": {
				"Default": "Stock Exchange"
			},
			"welcome": {
				"Default": "Welcome"
			},
			"organization": {
				"Default": "Organization"
			},
			"form": {
				"Default": "Form"
			},
			"errors": {
				"Default": "Errors"
			},
			"verifications": {
				"Default": "Verifications"
			},
			"referencedBy": {
				"Default": "Referenced By"
			},
			"howToFund": {
				"Default": "How To Fund"
			},
			"pubkeys": {
				"Default": "Pubkeys"
			},
			"identity": {
				"Default": "Identity"
			},
			"accountWith": {
				"Default": "Account With"
			},
			"licenseNumber": {
				"Default": "License Number"
			},
			"surname": {
				"Default": "Surname"
			},
			"givenName": {
				"Default": "Given Name"
			},
			"dateOfBirth": {
				"Default": "Date Of Birth"
			},
			"dateOfIssue": {
				"Default": "Date Of Issue"
			},
			"dateOfExpiry": {
				"Default": "Date Of Expiry"
			},
			"issuingAuthority": {
				"Default": "Issuing Authority"
			},
			"holderAddress": {
				"Default": "Holder Address"
			},
			"entitlementCategories": {
				"Default": "Entitlement Categories"
			},
			"blockchainUrl": {
				"Default": "Blockchain Url"
			},
			"transactionHash": {
				"Default": "Transaction Hash"
			},
			"additionalInfo": {
				"Default": "Additional Info"
			},
			"status": {
				"Default": "Status"
			},
			"relatedTo": {
				"Default": "Related To"
			},
			"value": {
				"Default": "Value"
			},
			"purposeOfMortgageLoan": {
				"Default": "Purpose Of Mortgage Loan"
			},
			"totalAmountRequired": {
				"Default": "Total Amount Required"
			},
			"totalValueOfProperty": {
				"Default": "Total Value Of Property"
			},
			"propertyStreetAddress": {
				"Default": "Property Street Address"
			},
			"region": {
				"Default": "Region"
			},
			"city": {
				"Default": "City"
			},
			"postalCode": {
				"Default": "Postal Code"
			},
			"formattedAddress": {
				"tradle.MortgageLoanDetail": "Property Address",
				"tradle.Organization": "Address",
				"tradle.Profile": "Address",
				"tradle.PropertyInformation": "Property Address",
				"tradle.UtilityBillVerification": "Address"
			},
			"propertyType": {
				"Default": "Property Type"
			},
			"sizeOfProperty": {
				"Default": "Size Of Property"
			},
			"currentIdentity": {
				"Default": "Current Identity"
			},
			"allIdentities": {
				"Default": "All Identities"
			},
			"nationality": {
				"Default": "Nationality"
			},
			"url": {
				"Default": "Url",
				"tradle.Settings": "Server URL"
			},
			"name": {
				"Default": "Name"
			},
			"email": {
				"Default": "Email"
			},
			"street": {
				"Default": "Street"
			},
			"contacts": {
				"Default": "Contacts"
			},
			"lastMessage": {
				"Default": "Last Message"
			},
			"lastMessageTime": {
				"Default": "Last Message Time"
			},
			"securityCodes": {
				"Default": "Security Codes"
			},
			"verificationsCount": {
				"Default": "Verifications Count"
			},
			"verificationRequests": {
				"Default": "Verification Requests"
			},
			"products": {
				"Default": "Products"
			},
			"codeOfIssuing": {
				"Default": "Code Of Issuing"
			},
			"passportNumber": {
				"Default": "Passport Number"
			},
			"sex": {
				"Default": "Sex"
			},
			"placeOfBirth": {
				"Default": "Place Of Birth"
			},
			"authority": {
				"Default": "Authority"
			},
			"phoneType": {
				"Default": "Phone Type"
			},
			"list": {
				"Default": "List"
			},
			"securityCode": {
				"Default": "Security Code"
			},
			"firstName": {
				"Default": "First Name"
			},
			"lastName": {
				"Default": "Last Name"
			},
			"formatted": {
				"Default": "Formatted"
			},
			"middleName": {
				"Default": "Middle Name"
			},
			"verifiedByMe": {
				"Default": "Verified By Me"
			},
			"myProducts": {
				"tradle.Profile": "Products"
			},
			"myVerifications": {
				"tradle.Profile": "Verifications"
			},
			"myRequests": {
				"tradle.Profile": "Requests"
			},
			"summary": {
				"Default": "Summary"
			},
			"websites": {
				"Default": "Websites"
			},
			"bedrooms": {
				"tradle.PropertyInformation": "Number of bedrooms"
			},
			"bathrooms": {
				"tradle.PropertyInformation": "Number of bathrooms"
			},
			"yearBuilt": {
				"tradle.PropertyInformation": "Year it was built"
			},
			"purpose": {
				"Default": "Purpose"
			},
			"averageMonthlySales": {
				"Default": "Average Monthly Sales"
			},
			"averageTxsPerMonth": {
				"Default": "Average Txs Per Month"
			},
			"averageTxAmount": {
				"Default": "Average Tx Amount"
			},
			"numberOfChargebacks": {
				"Default": "Number Of Chargebacks"
			},
			"volumeOfChargebacks": {
				"tradle.SalesData": "Total amount of chargebacks"
			},
			"settlementCurrency": {
				"Default": "Settlement Currency"
			},
			"code": {
				"Default": "Code"
			},
			"billDate": {
				"Default": "Bill Date"
			},
			"issuedBy": {
				"Default": "Issued By"
			},
			"employer": {
				"Default": "Employer"
			},
			"howLongHaveYouWorkedHere": {
				"Default": "How Long Have You Worked Here"
			},
			"monthlyIncome": {
				"Default": "Monthly Income"
			},
			"residentialStatus": {
				"Default": "Residential Status"
			},
			"maritalStatus": {
				"Default": "Marital Status"
			},
			"dependants": {
				"Default": "Dependants"
			},
			"countryOfBirth": {
				"Default": "Country Of Birth"
			},
			"taxResidency": {
				"Default": "Tax Residency"
			},
			"fundAccount": {
				"Default": "Fund Account"
			},
			"purposeOfTheAccount": {
				"Default": "Purpose Of The Account"
			},
			"phones": {
				"Default": "Phones"
			},
			"emailAddress": {
				"Default": "Email Address"
			},
			"productType": {
				"Default": "Product Type"
			},
			"inUKFrom": {
				"tradle.CurrentAccount": "In UK from"
			},
			"language": {
				"Default": "Language"
			}
		},
		"models": {
			"tradle.AdditionalInfo": "Additional Information",
			"tradle.BusinessAccount": "Business Account",
			"tradle.BusinessInformation": "Business Information",
			"tradle.Country": "Country",
			"tradle.CreditCards": "Credit Cards",
			"tradle.CustomerIdentification": "Customer identification",
			"tradle.CustomerWaiting": "Customer waiting",
			"tradle.Enum": "Enum",
			"tradle.FinancialProduct": "Financial Product",
			"tradle.ForgetMe": "Forget Me",
			"tradle.ForgotYou": "Forgot You",
			"tradle.Form": "Form",
			"tradle.FormError": "Form Error",
			"tradle.HealthInsurance": "Health Insurance",
			"tradle.HomeImprovement": "Home Improvement",
			"tradle.HomeInsurance": "Home Insurance",
			"tradle.HowToFund": "How To Fund",
			"tradle.ISAs": "ISAs",
			"tradle.Identity": "Identity",
			"tradle.IdentityPublishRequest": "Identity Publish Request",
			"tradle.IncomeProtectionInsurance": "Income Protection Insurance",
			"tradle.Investments": "Investments",
			"tradle.JumboMortgage": "Jumbo Mortgage",
			"tradle.LicenseVerification": "License Verification",
			"tradle.LifeInsurance": "Life Insurance",
			"tradle.Loan": "Loan",
			"tradle.MaritalStatus": "Marital Status",
			"tradle.Message": "Message",
			"tradle.Mortgage": "Mortgage",
			"tradle.MortgageLoanDetail": "Mortgage Loan Details",
			"tradle.MotorInsurance": "Motor Insurance",
			"tradle.MyIdentities": "My Identities",
			"tradle.Nationality": "Nationality",
			"tradle.NewMessageModel": "New message model",
			"tradle.Organization": "Organization",
			"tradle.PassportVerification": "Passport Verification",
			"tradle.Pension": "Pension",
			"tradle.PhoneTypes": "Phone Types",
			"tradle.ProductList": "Product List",
			"tradle.Profile": "Profile",
			"tradle.PropertyInformation": "Property Information",
			"tradle.PropertyType": "Property Type",
			"tradle.PropertyTypes": "Property Types",
			"tradle.PurposeOfMortgageLoan": "Purpose of mortgage loan",
			"tradle.PurposeOfTheAccount": "Purpose Of The Account",
			"tradle.Refinancing": "Refinancing",
			"tradle.SalaryVerification": "Salary Verification",
			"tradle.SalesData": "Sales Data for last year",
			"tradle.Savings": "Savings",
			"tradle.SecurityCode": "Security Code",
			"tradle.SelfIntroduction": "Self introduction",
			"tradle.Settings": "Settings",
			"tradle.SimpleMessage": "Simple Message",
			"tradle.SkillVerification": "Skill Verification",
			"tradle.TermInsurance": "Term Insurance",
			"tradle.UtilityBillVerification": "Utility Bill Verification",
			"tradle.Verification": "Verification",
			"tradle.YourMoney": "Your Money",
			"tradle.AboutYou": "About You",
			"tradle.AutoInsurance": "Auto Insurance",
			"tradle.CurrentAccount": "Current Account",
			"tradle.Language": "Language",
			"tradle.RequestForRepresentative": "Request for representative",
			"tradle.ResidentialStatus": "Residential Status"
		}
	};

/***/ },

/***/ 1651:
/***/ function(module, exports) {

	module.exports = {
		"tradle.CustomerInfo": {
			"_t": "tradle.CustomerInfo",
			"customerName": "Lindt Inc",
			"customerOf": "US branch",
			"formType": {
				"id": "tradle.FormationType_302c5997af0e0ed72ff907ea4aa6a546c8616141",
				"title": "Corporation"
			}
		},
		"tradle.CustomerProfile": {
			"_t": "tradle.CustomerProfile",
			"addressType": {
				"id": "tradle.AddressType_0f643323a50e6264ed05bead4dde9d63b5fd59bc",
				"title": "Physical"
			},
			"message": "",
			"address1": "22 Broadway",
			"city": "NY",
			"region": "NY",
			"zipCode": "10001",
			"country": {
				"id": "tradle.Country_b424fcc35801022868a5285956805e8e9e0bb31a",
				"title": "US"
			},
			"natureOfCompany": "FinTech",
			"dateOfFormation": "2014-06-09",
			"patriotActCertification": "2014-06-09T18:37:46.000Z",
			"businessOrIndustryType": "FinTech",
			"naics": "NAICS",
			"duns": 123654789,
			"wwid": "WWID",
			"govIdType": {
				"id": "tradle.GovernmentIdType_10b70fe4e6e3371080599293002d2fc5e46c4e64",
				"title": "U.S. Employee Identification Number"
			},
			"govIssuedIdNumber": "44-2223333",
			"govIdIssuingCountry": {
				"id": "tradle.Country_b424fcc35801022868a5285956805e8e9e0bb31a",
				"title": "US"
			},
			"regulator": {
				"id": "tradle.Regulator_6d87d852dc38879a2931ea1770e266c1ddb72179",
				"title": "U.S. Securities and Exchange Commission"
			},
			"exchange": {
				"id": "tradle.Exchange_5aecf70b60518bbb0a5a403eb955590c3bd3fd86",
				"title": "U.S. NYSE"
			}
		},
		"tradle.CustomerOwnership": {
			"ownershipStructure": {
				"id": "tradle.OwnershipStructure_83c7ca422067c7e87763b0ede033af68ec643058",
				"title": "Corporation (for-profit)"
			},
			"ownerName": "Tradle Inc",
			"ownerCountry": {
				"id": "tradle.Country_b424fcc35801022868a5285956805e8e9e0bb31a",
				"title": "US"
			},
			"cipExemptStatus": {
				"id": "tradle.ExemptStatus_a9d0648a756426f145630b46509c6125b02fe7f5",
				"title": "Non-Exempt"
			},
			"_t": "tradle.CustomerOwnership"
		},
		"tradle.CustomerEntity": {
			"_t": "tradle.CustomerEntity",
			"entityRole": "CFO",
			"entityType": "Person",
			"lastName": "Ellen",
			"firstName": "Katsnelson",
			"dateOfBirth": "1986-09-20",
			"citizenshipCountry": {
				"id": "tradle.Country_b424fcc35801022868a5285956805e8e9e0bb31a",
				"title": "US"
			},
			"message": "",
			"residenceCountry": {
				"id": "tradle.Country_b424fcc35801022868a5285956805e8e9e0bb31a",
				"title": "US"
			},
			"ownershipNature": "F",
			"ownershipPercentage": 2,
			"email": "ellen@tradle.io",
			"phone": "2121212121"
		},
		"tradle.PersonalInfo": {
			"_t": "tradle.PersonalInfo",
			"firstName": "Michael",
			"lastName": "Mann",
			"dateOfBirth": "9/20/1976",
			"placeOfBirth": "New Jersey, US",
			"houseNumber": "30",
			"city": "New York",
			"region": "New York",
			"postalCode": "10023",
			"country": {
				"id": "tradle.Country_123",
				"title": "US"
			},
			"street": "Lincoln Center Plaza",
			"nationality": {
				"title": "American",
				"id": "tradle.Nationality_123"
			},
			"emailAddress": "ellen@tradle.io",
			"idCardType": {
				"title": "ID Card",
				"id": "tradle.IDCardType_123"
			},
			"idCardNumber": "K1234 22333 55566",
			"maritalStatus": {
				"title": "Married",
				"id": "tradle.MaritalStatus_123"
			},
			"phones": [
				{
					"number": "12123334444",
					"phoneType": {
						"id": "tradle.PhoneType_4b3d018c5085bc93de73405760a5d2fbcbef6c78",
						"title": "Mobile"
					}
				}
			],
			"photos": [
				{
					"url": "data:image/jpeg;base64,/9j/4AAQSkZJRgABAgAAAQABAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCAH0Au4DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD36iiigAooooAKKTNIXoAdRUZek3j1oAlzRkVDvo3j1oAmyKMiod49aN49aAJsijIqHePWjePWgCbIoyKh3j1o3j1oAmyKMiod49aN49aAJsijIqHePWjePWgCbIoyKh3j1o3j1oAmyKMiod49aN49aAJsijIqHePWjePWgCbIoyKh3j1o3j1oAmyKMiod49aN49aAJsijIqHePWjePWgCbIoyKh3j1o3j1oAmyKMiod49aN49aAJsijIqHePWjePWgCbIoyKh3j1o3j1oAmyKMiod49aN49aAJsijIqHePWjePWgCbIoyKh3j1o3j1oAmyKMiod49aN49aAJsijIqHePWjePWgCbIoyKh3j1o3j1oAmyKMiod49aN49aAJsijIqHePWjePWgCbIoyKh3j1o3j1oAmyKMiod49aN49aAJsijIqHePWjePWgCbIoyKh3j1o3j1oAmyKMiod49aN49aAJsijIqHePWjePWgCbIoyKh3j1o3j1oAmyKMiod49aN49aAJsijIqHePWjePWgCbIoyKh3j1o3j1oAmyKMiod49aN49aAJsijIqHePWjePWgCbIoyKh3j1o3j1oAmyKMiod49aN49aAJsiiod49aN4oAmoqLfShqAJKKaGpwOaACiiigAooooAKKKKACms1DGoXfFADmfFQvMB3rL1jXLLR7Zp72cRp2HVmPoB3Nco/ifXNRy2m6SkMJ6S3jEE/8AAeKAO5a5x3qM3VcX9p8UiHfJc6cD6eSf8aiF54lb/l50/wD78t/jTs+wro7c3XvTftXvXG+Z4lIz9qsP+/Lf40rt4mVN32qwI/64t/jRZhdHY/aj60faj61yEf8AwksgyLzTx9YT/jTHbxMr7ftWn/8Afk/40WYXR2X2o+tH2o+tcX5/iTdg3Vh/35P+NOWTxI7bRd6fn/rif8aLMLo7L7UfWj7V71yTp4mSMubzT/p5J/xqES+Jm+7c2B/7Yn/GizC6Oz+1H1o+1H1rjDL4mHW5sP8Avyf8aep8TMM/atP/AO/J/wAaLMLo7D7UfWj7UfWuOz4nzj7TYfXyT/jTseJ8Ei60/wD78n/GizC6Ov8AtR9aPtXvXIKPE7DP2nTx/wBsT/jSlPFAGftWnn/tif8AGizC6Ou+1H1o+1H1rk/K8UYybrTx/wBsT/jTQniktj7Tp/8A35P+NKzC6Ou+1H1o+1H1rkxF4oI4u9Pz6eSf8aRY/FBzm608Y/6Yn/GjUdzrftR9aPtR9a5Qw+KAgYXenn/tif8AGkWHxQf+XrTx/wBsT/jQB1n2o+tH2o+tcm8XihOt1p//AH5P+NJ5fijGRdaef+2J/wAaAOt+1H1o+1H1rkjH4nBAa708H/rif8aGj8Tr/wAvenkf9cT/AI0rgdb9qPrR9qPrXJBPE56Xen/9+T/jThD4mP8Ay+6dn/rif8aLjsdX9qPrR9qPrXKNF4mVsNeaeP8Atif8aQxeJwwH2vT+f+mJ/wAaLhY6z7UfWj7UfWuU8jxRkD7Zp/P/AExP+NO+z+J84+26d/35P+NLmCx1P2r3o+1H1rlWg8TocG807/vyf8ad9l8Ubc/bNO/78n/GjmQWOo+1H1o+1H1rlvs3if8A5/dO/wC/J/xoNv4oAz9s08/9sT/jRzILHU/aj60faj61y62vihh/x+6cP+2J/wAaR7fxQgybzT/+/J/xo5kFjqftXvR9qPrXKpB4occXmn/9+T/jS/ZvFOCftmn8f9MT/jRzILHU/aj60faj61yqweJ2OBeaf/35P+NKbbxTnH2zTv8Avyf8aOZBY6n7UfWj7V71yog8UbsfbNP/AO/J/wAad9l8T5x9t07/AL8n/GjmQWOo+1H1o+1H1rl/svijP/H5p3/fk/401oPE6nH2zT8/9cT/AI0cyCx1X2o+tH2o+tct9m8T/wDP7p3/AH5P+NH2bxTni804/wDbE/40cyCx1P2o+tH2o+tco0HihSB9r0//AL8n/GhofE6gZvNP5/6Yn/GjmCx1f2o+tH2o+tcqYPE4GTe6cP8Atif8aaYvE46Xenn/ALYn/GncLHWfavej7UfWuRK+J1OPten/APfk/wCNKU8SrjN5p+T28k/40XFY637UfWj7UfWuUEHig/8AL3p//fk/40eR4pzj7Vp//fk/40AdX9qPrR9qPrXLi18UZx9t07/vyf8AGl+yeJwcG907/vyf8aYHT/aj60faj61ywtvE5Yj7bp3H/TE/40v2bxQel5p5/wC2J/xoA6j7UfWj7UfWuWNv4nAyb3T/APvyf8aQweJwuftmn/8Afk/40WYaHVfaj60faj61yfl+Js4+2af/AN+T/jTvI8T97zT/APvyf8admK6Oq+1H1o+1H1rlBD4mYHF7p5/7Yn/GjyfE2Ob3Tx/2xP8AjRZhdHV/aj60faj61yhh8TAgC8085/6Yn/Ggw+Jx/wAvmn/9+T/jRZhdHV/aj60faj61yJXxODj7Xp5P/XE/401R4oOd1zp4/wC2J/xoswujsPtR9aPtR9a4x5fEqdbqw/78n/GmmfxIMYurA/8AbE/40crC6O1+1H1o+1H1ri/O8S/8/Nh/35P+NL5viT/n70//AL8n/GjlYXR2f2o+tH2o+tcX5/iPBP2vT+P+mJ/xpBceIyM/arD/AL8n/GizC6O1+1H1o+1H1rivtHiTbkXNh/35P+NAn8Slc/abD/vyf8aOV9gujtRdU77VXDm48SgZ+02H/fk/40PceKAgZJ9PY/3fKIz+tHK+wXR3a3VSpcD1rz5PFN/p7AazpzRRn/l4gO9B9fSuktdRiuYEmglWSNxlWU5BpDOjWUGpQ1Y0Vx71eim3UAXwaWoVbIqUGgBaKKKACkJ4paa5oAjdsCsbW9Xg0jTZr24PyRjIA6sewHvWnM+FrgvFbtfa/pGm8mIE3Mg7Hb0/kaAKdhp891eHV9YzJqEvKI33bdeyqOxA6mtdQoJGeTUjiT723rSrbFsMRitkkkZvUY6ssJDdO1VgCDVq8cIqIKiQgiqWwiZJlVcEVM242/yjr2quyrt96uxKwjXBGKkZAu9YgSMc06S2Z8MO9S3IYQZxxTraRZbfB6ikBAbfamcZNDQrDtfPJ7VZVSqkk8VVVjcXPH3FoAtMhwqlchqQJGh2hcU6WRWAKHpURdQQzHmgB+xcE4BpCokT5RjFCspf73BprTKGK9BQBIGCADrTtg6gjmoFlSNDgg1FNdBoSy8MB0osBaRyWKlePWndIhjk1xGqeKrvS2JeE7fWrXh/xhDqh2M2yT0NX7KVrk86vY6zmRRk45oLMGG0ZFVxdqykY/GqGpX01vEWtxvxyalJsq5uDH3uhpFOHII61wVv4vurm9FuIiGFdha3jtErSj5jRODjuCkmaSgAE/pSA7geKgWeIt97HtTxcoSVrOxRLtAX5uaNqsoK9KYrKVOTxSiRSuENSMc8SvgnrSPEAAD0pxbco3cU5iAoxzQMrPbMGBTNI0JLA4watFyVyBSMpbmkMrSADAf86a52kHHSqmuXM9tAGijLADtXCy/EKWG48h4CDnHNXGlKexMqijuejnJcEU8gdzzWHo2oXWoIspTCGtLUBLHbF4wS1ZuDTsWpXVy0xCjB60rElARXn83i27jvfsvksXz2rrtNuLm4tg0ikEjoacqbirsUZp7GlwVwTignYvy80042fNxTgQqcDNZlB99fQ0Y2Kc80m7cvpRwqHJzQMEcOMKMGlVWVDuNNVlZSBxQuQpyc0CCNlYnHBpyqQSSaYjBs4pyDDZJoAN4Y4x+NBADDmkD5YgCkVPnzmgB+5t1IzLuAI5pFZjJyOBQ8iqSzcYoAVlHBz+FId24YPFclqfirbem1tQZJM44pTc60sfnGLjr1rX2T6kc66HVs+SBjmmygZUHrnpXJ23i3N6lrNEVkzjNdpGEdVdudwzSlTcdxqaexAYmkIzwKV4myFAwKtOMEY6UuSxwRgUAVvJG4DrUggj384JqTI8zFNwBIcHmgBfLAbk4FNLBnIAwBTd4DHcelMFyjE9gKYiXgthetNCbWJaqxuRklKjN0VjJ6nNNCLgYMGyMCkXhPlNUTOzx+lRvJKMY4pkl4yLgBjzSORgAEVQyzsO5pp80MS4IUVSQGgCrZwRkUisozuYYrODMQSmTSfvAvzAiqsTc0SQqZTpSZVwATg1Q3vwB0oLsDkckUWHc0lkAcKBkDvSHIYsT8tZy3D89qct0UXDHOaLBc0QQylh1prDeADVT7ScjHAqUTRk53dKVguOcRn5NuTUXkZY8YFPDqSSOtBYshzwaAIWt2U5J4NQMnlg55q6TtVVY0OqkhcZp3CxQ4C5x1oztxgdattDlioXioDE6tjHFMQw5HQcUmW3ADpSgOGOelNAK554poQvzb/al3MWx2pEDBSSfpTQWXPPNAC/eJRwNvoe9YF3bv4eu21PTg32Jjm7tVGVHq6jsfXFbzMfL96QMpXDpkEYYHuKmUboadi7bXayRpJG4ZHAZWB4IPetWCfOOa4LwvK1st3pbEkWUzJH/uZ+X9MV1lvLgisTU6OGTI61bU1kW0nTmtONsigCxRSL0paACo2NSVE/SgClctiuOnBm8bYIB8uxG32yzV1t0a48zrH45YMPvWQA/76ahbg9jaRDtxwTUU9yIYyO9Wo9sY3k9aydUZGPynmtVuZlaSUytuNPiBJqOKIeXknJqxChPAq2IsLblyMMKutGqxKpbBFJBAEUMTzUepjZAGHU1HWxRHd3UaQGPdk1Ttr/yFIABzVFY2mbJzVyOxyOTVWSJuyea/EqYHFLCTFCSOd1VprQKPlNMiuXtztYZWnbsFyyrPyFPNKgJH7w1EJmkb92uM1IFKnLnJpNAWo1iyDuI+tV7iVfNwoyKjeYyDavFMJKrk8mhIGwUNuJB49KT72QeKXkkMKbu5INUIwPFlsk1goIBJrgLizu9DnS4j3bTzmvRPEQ2Wqd+akfTYdT0hI5FGSvBraE+VamUo3ZW8OeI01OFY3IEmOa6BgNjAHOR0rya7trvw1qYdMhA3X2r0DQtZi1O33bxvxyKVSFveQ4SvozP062X/AISGY7QMCtPWtWudLi8xEDIB1qrYDOvTj2qz4pUDRJR1yKl6ySZS+FlHSfEN1q3zRoAfrVy81i/scFoMjPJFc74JuI4IZGdgMV1FpfwatK8RUMo70ppRlsEW2tyabVrpNOFyqEqRkisfTPGM97dmCOPDA4PNdO9mn2VoVHy46V5kqnRfFh/hV2zSpqMk1Yc24tHrMd3ILffNxhcmsjTfFKXl+9uOdpxTtSvv+JUxHV0wK85sJZNK8RIzk4du9TCnzJlSnZo9V1PVpra2aWBOB61R0TX7vU3O+PCg9aNRnR9MG08vxipdGt/s2njaMMTWWijqXq5HQMqyx4fBBFeT+PPDv2Wdry3X5c7uBXpyO4jG44qrqllHqWnSQsAflPNFKpySCpDmicl4B8QiWD7K+Nw4rtdYv0tLBpGxkjCivFZfP8M66GTITdXcWl5N4mnhGT5SjmtqtNX51sZU5u3L1LmgaSlxcyandgBScjIq7feLLeC4+y2aB3HHFVPF+onRNFFtEQpx2rE+H9gt9I93MN7E5yanlUo88tir2fKjpRPq0yeYIyB1quPFElhOIb2Mrk9a7VQuzGAMCuQ8caXFPpTzKoDr3FZwcZSs0XJNK6ZvRXcV7ZebakE4rjNW8WT6Zd/Z5I+p9azvh7rcyzvaSPuUHHNVPHwH9sofetY0UqnKzOVRuHMjq/7XvvsQuEhJTGeKZo3jKG8vPss42v7mtLTLuzj8OhZGXPl8g15zbWr3Xi0PbKQmSciiNOMr3Q3OStY9T1CaW2tzLAu4YzXHW3jS4uNRNqI/mzjrXdTqBpDg8ny8V4/pTKni6R2GFD1NGEZJ3Q6kmmj025vrq2svOZMcZ5qhoutXmpXH+qIUHrSXeprrN0LSFgEBxgV02mabFYQbIwAfWoaUY6opXb0LSKTjjtzVDWspp8rRj5tp6VpDO4+mOaZNHHKjRtghhWS3NOh4joupx2fiR3u/75617BbalZXsYETIQe2a898VeBHe5e5tM888VyaXOtaJJyzhVrulCNVJpnJGUqbs0eoan4bSbWI7qBcAHJxSaprV1Y3UdrBGWOMVg+GvH7TzJBdEBuxNdmLW3uboXn3iw4rCV4O0zWNpK8TEu9c1S1tzPJGQoGetUdK8Y32quywx8j3rX8T5/smcEDha5H4dpvupFx1PWrjyuDlYmV1JK50L+I9QtbxFlhO1jgmt975orZrktxjNPutLhusbsZBrI1hxDELNGyTxWV4ysaWaKGl+KhfarLbv2OBzWnrGoPZQeZGhOegrzvUYJdC1uK4UEK+CTXfwTJqlpE8mCuAaurywtJbEwvK6ZRi1O/MHmeVjv1rLh8Xzy3xtRFlwfWuzlt7ZbBymMgeteWacoHi9iB0Y0UpKabtsKacWlc7S51jUoIhIbb5KW68RXK6eJ/J4A5rbEsVxbGGVBzWfrVtFBokioo+6azjUjJpFuDSMbSPFNzqshWGIBh71oahq2p2kZd4cp3rjvBVwtreTOxAANdrb6xFq149r8rKRitKi5Z6LQiGsS/o+om8tQ6ptc+taMvnkZKgiqMVk1muYRgCr0F0ZPlcjNckptvQ6IxVtSITxk4K/N6U/lRkxZpt1D/y0Refan2t2XG1xyKXtJdx8iIZPLkA2jae4NSJDbFPmfDfSi6jVh5ijBpLOaORfLdRkVXtpbE+zQ3yS7fI4IqM27x5PNTXKGI+ZEcY7ViQaxcXOpPbbulaxqNkSgkah8xRkA07zmJGT0qhLqk9uXEnKgVWstRFzMDkFSeQK1i01dkNO5ueej8nqKmSdWXgcisLUtQjs5F8vkNV6IvJAHXuM07Jq4rmkrMynPX1phJxg9apiaQYGalMnmMMnmlYEPaLeCM1DJbEKBmp8hzwelHBYZ7UXGUiCBtzS7Tjjk1bmhRvmXg9xVUoVyc8VSZNhjZJGKQkhhxkUgGGJB4p6Akk9qYjEg2xeK9SVRgNHEx+u0V0ED9K5tTjxZqH/AFyi/wDQRW9bt0rm6m5v2r8CtiBsqKwLQ1t2x+UUAXlNOpi0+gAPSoX6VMelQv0NAGbdmuJucHxqcn/lzH/oTV2l13rjJ9o8bHcM/wChjH/fTU1uJ7GvFKHmWNjxUF/CFlwOlMuWVCJF4pjziYAk81tYzuRqdpx2qzHMqLx1qo+B0OaQE1QjSW6ccls1BdXMkow2cVWVm3cc1JM+Y8Ac1NhkQl8vgCpUd36sagUFjV2K1Z14NN2EiSKDzOPM59M1XeLkq3UVJGphmIZsVDNIWc0kMsImyGo23ggjJFLCszjKqSBU8bS9DGCKAKmMN70oVsHPIq+sSO2WTFOkgRGGGyKOYVjO++vy9qDlcZGTVramSoGDTW+RScZxRcLHOeI1K26MT3rS08b7KIAfwisDxG99esscELbR7VraFdXC26288JBAxnFate6SviDWdGj1GzZGQFscHFebFbzw1qWcsEJ/CvZVBXvWN4g0OLWLJvkUSAcUU6ltHsKcL6owPDWoDUdSaUdSta/ihGXR5s+lY/hDR59L1GTzUOOgNbHigXNzaPBBGWyO1Ere0Vgjfk1OW8Hacl/bSq+enaur0XRjpc0jH7prnfC1vqGkuwe3bB61091ql2LZ1jtiSRRUbcrJ6DhZLU2Ul8xvkOfXFcF48sTFNFeIuCOtdP4aS6xJJdIQSeAas+JNMXUNOdQuW7CsoPkmXJc0Tl9Mvm1S2tYc5xjNVfGunfZzHdRjG0jpWn4N0Oa0dnmQgA4Ga3fEukNeaZKijcccVbmo1NNiVFuGpgaNeHU4LdAcletdlEdsQTGMCuT8E6LNZK7zKRjoDXYqSSy7cGsazV7I0p7aiLuaLB6VJGNqY6io4y21lIqKaV4ICyruwOlYGp5v8RY0WaNgB17VufDtQdLZuhJ61ieKLLUNZmBjgbCnitHwmt9pUJgkgYAmu2WtG1zmj/FuWPiFZTTWIkHOPSm/Dm8VLMx5AYdq7Ca0GoaeUuFG1vWuKHh+80O/aazy0ROSBWUJqVPkZco2nzI9HjmEinB5rB8XXKw6JKHIyRxUEGsyiLDQsHx6Vi6pa6hr0giKlIe+azpxtK7LnK6sjA8A2kkupyTgHbnrT/Hx3avGW9hXeaNpMWjadthUF+5riPFOnX+pakJI4WKg10xqKVS/QxlDlhYi1PTr6306K5gd2jCgsoNb/gnVdPkzG6Is+Mc9a1dFiNxpgtbiIg7cc1yWreGL3TdTF1YqcZ6ClzqacWPlcbSR6ZezI2nyhf7teMWsLXHimaMHGWrvrTUL1tMaOWE+YVwa5LT9J1C311rxoW2ls5xSoe4pBV95oj1G1vvDepi7iLmPdk4r0Xw34ji1e1G5xvA6ZqDUoU1HTGR4Mtt61wOn6bquk6p5sET+Xu6UXVWOu6DWEtNj2ETsxwOlUNVvvsNuZQenWo9KvJbiECVCrY5qLXrRruzkji5LCuRL3rM6G9Lok0fUF1GAS5DeoNJeaXa36OskCjI9K43SrfVdCkOY2eMnOK3W8Q3DRlUt23fStXBp+6yFJNe8jzfxPpa6RrA8jj5uAK9S8LGaTSYmYndjvXKDQLnWdUFzeDagOcGu3gMdrbpbwEAAc1piKq5UupFGDUm+hQ8UnGkT7iM4rjfh87C4k2HHPWuk8RNNPZvDChYsO1cx4Z0++0ydi8TAE0oP90wkv3iPRpYRHG0kkhzjPWuRf7Vcai8sOWVTgVc1W9vjaGOJCSafoJmit8SRHeeuRWMFaPN1NZO8rGB4ktbu+sy8kfKDjip/BeqLNbfZZCNy8Yrp72JntnzHncOlcBZaXqFhrJnjhYRlsniuiCdSm4yMZe5O6PQJ1KxPtzjBrzfSif8AhL34ySTXoUt1J9hYiI7yuMVw1jpuoQa8bv7O20n0p0KXLFpsVWfM1Y9Ijs3lwfu8Vn+Ird49Kl+fI2nHNalrJPPApKkYHNZPiI3Elk0MSliRWcKSUi5TdjhPBlml5dzI/Q5rrNP0E6fqbyxk7T0rmvDtlqOlXpdoG2k88V2kuoXAty0du27FdFVXdkY09EX/ADHf5PM5HXml8nHIzmsLRRfSXMs1yCoJ4BrqykEWnvdTyBEQZLMeBXPKlGJuptlMTTKNvJFSfZ5GxIvFZun6pHqnmmFJFEbAHeu0kEZB/EVriJ44hIT8tZulErnYwTOuVkQkVWYfvN8a7farZcnpz9aQS4GGUCp9iP2giSrMhVuGrlTHJYa60207WPWunMcbc5Kn2qJ7RJPvHJ9aIxlEG0zPlPnxSMU3Kw6YrDgtXtr9XhyFJ5WutjQQnaUBWo5IVZg0cfNHO49A5UzIvrF723eQAhl6Vd0G9mFosMqZYDAzWnby2xY24kj87GWj3Dd+VMkgFvKJFUKAaJVfdsNU9bkhVd2ZF21FJBsbeOnarNxc26WTyyMFVRkse1YWq+I00exHSWaY7YIgMs5+npRCq1uKUE9jQWXyyW5qwtwpAbvWfY3V9/Yiy39kDeMC3lKQMeg/KrEi7CvHBHOO1bxmpGTi0XC6BMjnNNkClQOxqqJ9rhcHFWA8ZODVWERPAqrwetRkFRtFWvlYgUjxBz8vUUXFY5UZHiy/B6+VF/6CK3rc1hNn/hL9Qz18qL/0EVuW/asOpsbFp1rctTxWHadRW3a9BQBfXtUlRrUlAAelQv0NTHpUL9DQBl3XU1xN0ceNv+3Mf+hNXbXXU1xzqW8cEgZxZg/+PNTW4nsWrwoINp+9Weue1Wrxt8pJ6VXyAOK6FsZMeEPWpkjOMmoIgzPknirg6UMERwA+YQRVpbYyIx7iiFM5OPxrQtVB7VDZSRhlCjYIq3BKQuM0mpQ7JiR0NVo2K96rdC2Hz72kzmkkXCLnqacJQW5pHPmOABQBoQyMlttTv1piuVB55qvtlib5TkelGGckg4PpSsBP5pxljSM5LZB4rPaZ95V88U1pn2/IafKK5ol1D8kZNJuChiTms4ucgueaXc+7r8tHKFy4TG+CAKfmNMcDPrWd5mQQpwaXeyoCxp2Fc0Q4Vs5yKXzVkUjoRWYXcuCDxTvMJJANLlHc0V8tBuwM0oCs4PGKoB2VDuORTt7EKVPFS0UmaGIS23auadHFGA2VUis4SYfk809ZJAx54qBmmoRF/d4zWbreu2OjR24vjIDOSI1jXcWxjP8AOnrMQDtPNc7r8nneKfDAcAgSTdfolSykdBo+u6bqYdbJzvj+/G67WX6itOXPXquM1xc+y2+I9jLEoUT2b+dt43EZxn8hXVSXJ2MR02n+VTcZi2/jfQDIB5kyJu2+YYiEz9a6lJY5cMmCGGQw7ivHodVuP+EFms20hjAzFGuiMhQW+9Xp+iCGHSLKJJPMCQqFc/xcUr3KJ5762hv4LGVts1znyxjrjrUz24SN2Y5RQSa5vV2LeO9ABHRZf5V1SZ5Dcr3pAZlhc2F9p/2+2cPBgnJGMY60um3NpqtkLu1GY2JAJGM4rjY7k6JofibSlOJI5dtuPaU7RXbaDZR6doVpaKMGOMZ+p5NTcdjP1TxJY6LLFa3nm+ZKCyLGm4kVb0nUbTVrVp4FkCA4xKm01zXiO4vLfx3pzWenreyGzceWTjA3HnNdTpDXFxZeZdWYtJcnMQOcfjSGV9W1HTtHsWu7xdsQYLlVySScDiq+k+JNI1C6+zQyOk5Xcscse0ke1Z3xFzF4ct5I4/Mdb+AhP7x3jistLifUvGujpe6c2nGFJHjLDmU4A25/WndiPQRtYHbUSwx871WnrEQDsPNMEcpyGpagV7m7tNMtvtErbVLqgwO7EAfqathRIp3qMVzPjCEx6Ihzn/S4P/Ri10arIyEHjigY0xQRxu+BhQWPHYVFp1xbajZR3cADQSAlGx15I/pRcRFbG6IJJ8l//QTWN4BSRvBGlZ+75b/+jGp3YjX1PU9P0axa5u3Cxg4AAyWJ6ADuap6NrWma08qQBlmj5aKVNrAeuKz/ABHCk3ijw7bOAyGdnwehYKSP1FbEel2aa6bw7VvTEUwDjKcdvypagXJJoraCWZlCxxqWYjsBWFp/jDStQuY4rVbljKcKxhO0/jWrrMe7QNSx/wA+7/yrl/BF9qa6Lpkb6KqWxjwLnf29cYoA7RIA7fvAuPQ1jQa1o9/dXVrZsGmtiRLkYxjritjY0zBmbA9BXlNjCdM1RtVBIhuL2e1l/HdtP5gUOTQ7I9H06WzvrJbuB90b5ANU9ZvrLSLcXFxKVVjtUKMlj6AVk+DVdPCtswPDM3H40niXTb6/FjPZeU1zaymRIpekgxyKlJsbdifTNZtNUeRLdnEsf34pU2sM+1a0g8m1aV1ULGpZjjoAM1g6Df211rs0d7YNZawsQ3Kejp6g966DVWH9jX3/AF7yf+gmtYUtLmcp6mLp3ijStRuYkiW4dpThWMJ2/nXS4VB8sY+tcV4Rv9TfTLCFtGWO32Y88N29cYr0C2RJrZlx8wFbRSSIbuyiQXPOKTYgYhlBp8i7OAORTEDF/mFWiWOKRHgLUZChsbB+VTbvak34PIoAu2Q3W7qRxVNxGSVI6VaspCzlR3qrNAyysMd6XUYq20LJ2z9KtS2yJYZCjOazd5Q1pNL5mmZ9xQxGYfl5AAFcvq3imKa7mtIbWa9tbJQZFhHyvKecE+g4rb1qC4n0q5htXKzvGQh96xvDV1D4a8KCzXTbmS6y0lwzLgM56kn0pSHEl8PXhijvptQMSs4+0tJExI2nouMA5HTHtXT2+owXej/aHilgiQ8mUAZHr1rjtM0iXUNOaYypaXd7P54j6hU3ZCgfTFXrvSNal0VdCuJ447YAhrhTueUf0pajNmbU7FdMlvoJRJDGpJYdDiquiX0t9pcV5doI2lJZV9Fzx+lYd3pWsjS7bTUjtBYocSRRAqXGDgk5Pfmqt/ouoxRWkAubi6hEbAJEQiq3YEjnFO7Cx3JkjGM4GaQtHuChgC3ABPWuLvH1TU7PT7aK0uEa1ZTcsG2lyuMgH8KhvtL1q81tLy4hncxvG8UcEm1EUEFh7nGRQ2Fju2Tapy3Ss6+1AwaU9zbYck7FI6Zzio7mPVNQ+RrdrG1b7zMcyMPQelGpCxttAa0bKxjCoEPzbu2PejcRnxactlrOnqhLXDK7yuTy3rXQu0ko2sBXB6dB4m1e8a8F5DBHH+4UsvzlQeT6Z5NdwkkwllWRF8pQPLcNy/FZuCZak0ZGsa5YabaXNtdQzTEJzGi8H8ayPD62FvMNRnKLPMQscTNv8sc4APrVm8vZNXu4/J06WWzXluMeY/YH2HX8Kr3Gg6rLcfaYms4mEZEMap/qj3I55PuaylTa2LUjvRJFcRkZUtj16Vxus6hc3epHQ7Bys2Mu6n7memfaqmiadrdrcyS7kjd0CM8spYg85OOmeaiTSNZhmmiRYxLNMzT3TP8APKpPGMdBjHSou0ytGdtCttJCAJQ7LwWBzzVC4vUtruC3ILSSkhcdgBnJ/wA96oWGnapodnJBFbxXaMxcSBypBPbvVvTrR5JpLu+wbpxtAXoi+greFXozKVPsXoZgxO7rVhWz8ymq89vsXdGT9KhSUxgZ710aPYy1W5iSkHxjqJH/ADyi/wDQRW3b1hMQfF2oEH/llF/6CK3besDU17TqK3LboKw7TqK3LboKAL61JUa1JQAHpUL9DUx6VC/Q0AZd11NcdJKY/GkmO9iP5tXY3XU15v4hvpbLxijRKW3WmCB9TVRV5JCk7K5rSybiRUIHNYX9q3JbiFvypBqt2M/uG/Kuv2bOfnR1MR2ip1Irkl1m9x/qG/KlOv3QXHlHNL2TD2iOxExI2KK0LIYHJ5rh4tdu0QMIGJI9Kevia/jG5YGz9Kh0pFe0R2WowGXBUc1jsjRsQwNY3/CYaiD88LVDL4kuZ/vQHP0pqlJA5xNxnAYVaJEUIIHzGuSGtXS/N9mY49qdJ4ivJYsfZ2GPaq9myedHQNcSKCSamhuxxv4rj1126Jx5R/KnyardlQfJb8qfshe0R2FzLC4+UYPrVHgZCnmudXWroLzEx/CkXVrsvu8ls/SmqTQOomdCw+XLmlJIK7elYH9q3bD5oG/Ko21m6QgeQw/Cj2bFzo6TK5wOtIGIB38iueXWLuTkQNn6Ug1a93YMDflR7Nhzo6JiSVKU/eu7HeuaOrXe3/UsMe1SJq107f6knj0ocGNTR0K5Gd3IqTOUGyudGrXm4gwNj6VIuqXWP9Sw/Cs3BlqSN9sDBbrT0LbvUVz51O6YD9035U7+17mMgeU35Vk4lqR0AwCcdawtf0zUNRudNu9Okjjnsndv3nQ7sf4UiapcFs+WeanGpzkY8o8+1Q0UmM0rR7yPUJNU1WdJrpk8tFjGFjX2rdckphe4xWN/aM+MGM0DUZ8DEZ/KoKEtdDki8MSaS8g3ujLuHTJrR0iCSw0y1tZmBeFAhPriqH2+5Zs+WR+FPN/OcExH8qV0iizdWklx4i07UA4C2ocEHvmtxLkl8Z4rmxqc2ceWc09L+5z/AKtvyqHJDsJqnhk6n4ntNRSdVgUg3EX98ryv611iuhJC4z6Vyy39wJM7G/KpF1CcOTtYGs3NIqzF1vStam1+11TSJYUeKFoXWUcEE5rW0f8AtNbZv7VMJnzx5I4xWamq3XQBqQapdI33WNHtIhyst+INLfWrK3t42CNFdxT5PcI4bH6U3WNIuNR1DSryJgr2UxZs91K4P9KhGrXA52H8qQazcnI2nmj2kQ5WdCvAyppUbdkGubXVrmMfdNO/tq567DR7WIcrLHibSZ9Y0SS2s5VS4DpIjN0BVgR/Km6MfEf2krqptDbBMfulw2e1QLq90M4Q807+1Ljb9080/aIOVm3LEHt5kB5kRl/MYql4Z019H8PWemu2426spb1yxP8AWqI1O5jYnafxoOsXZ/gOPpR7RBysl8SaHNqqWlzp86w6hZSiWFmGVPqD7EVBoWjaoNen1nWp42uGi8mOKIfKi5BP8hVm0v7h5RuUge9acl6fuKuSe9UpJq4rEWpxPe6fdWkJ2mWMpn6iuU0nTfFWlwWljPPaPZwDZkD5ttdLJfNCCNvWq/2xpTyDSch2JB9oTkMSK5pvDc8/h+/052G+ad54nx91t25T+ddP++uQABhRVhYSFAq4U77kylYwfDekXGlaJb2N1IHeLOSOnNHiDSru9ayudOnEV3aOWQN91wcZB/IVvmFsUsUH71dx71uopIycrnL6bo+pHXG1jV5ITcCLyooohwq9z+tbtzH9osbm2IAMsTRg+hIIq5cRETkdqj8okc1XQk5rR9I8UaXb2sMsllJZxfKxUfNtrqLKTZPj+FuDVi1kJRom6YqlsKyMR0BpJdBss3iLDPlRwaotJukzjFaE2JLVX6kVRVN+eKaEJkk8UEkdRmnrbsw4oMEo6KSKYE1jIomHFNvZDHcsQcgmkSwlb5gCKlj0yaTO8GloMpSlXTKjmp4J41tDEx5PNWotIk3c9KkOinfnIxRdBZmNI+XHHFT3H2efTWtpUDo3Ueta0mihlGGGaR9G/d7QRmldCszj2sZ575mh8tVbG12HKYHaprrTrx1Xddt8vQLIeP1rpk0ZkQgEZqH+xpi2TRdD1OYGkahLl2uX3AcHecf561D/AGXfr5gF0eQMYaupawuVYqFOKiezkj6qc0aAc+NPv95InI+jYxR/ZeoK8bC8cKvPLnNbhhlAztIFOd96qpGCKdguQm2uLzToLVJ28xGyxZzk/jXN6lpd/a6nbWyxvICHYSYyqsccn8B+tdba5SXeTjFLNunlLdqVguc7Posmy3S0l8tYoyhOeTnqanstFvH2r5xKoFx8x5xWu8TJ1q+q+RacfeYUNBc5yOwuo7pDLOxRWyQGPPBqC40q4MsphnKgtmPBxgHr/Stx4namrbuOtOyC5hNo13jclwQ7HLEn2FQS6PqDgMJyGxg4c5rpGUr1pMMG5XANZypplKTRR0u3uklnM05kRugJzVm2Ki6YEcU5rdkO6M1DIzrIGIx61zyi0axkmXbi324kU8elUJovNbcBwfSr/wBoRosHkYqrbZeQqv4VUKnKxSjc5aOMx+K9QUnny4z/AOOiugt6xZlZfGepK33hFFn/AL5FbVvWt76kWsa9p1Fblt0FYdp1Fblt0FAF9akqNakoAD0qF+hqY9KhfoaAMu66mvPtZQv4xXGOLQdfq1eg3XU1wuoR+Z4z+lmP5tVR+JCew1bN+CAKmgtjghsE1LFIVJU1Kp2vu7V0NmFiD7GSw4GKr3GmZG4AVrM24fL1pUTKcnrUc7uVyox7aB2l2Bcge1WZLRgMBRWiR9mi3IoBPc0iukoGD83em5MLIy3tRIn3Rmqvkj7pUBga3fK596qXVvk7lHNCmxOKKwhBXGBxT4LXkhgpUilijY9amw5JAHGKfMFjMudOMeWQDFPgTdGAVGa0irGPaw7VT8toH3EZBpqV0LlsMlsQTlVFPtYcMUdRmrcRDDNPMP8AGvWjmHyjGtAqfdGfpTZNPimjyVGR7VfiIlXB4NKqYfFTzNDsmZFnb7bkoYxt9cVbNmC7HYp/Crs0TKm5VGfWo7bcMh+9Pme4JFQWalGQouTVZLQwMQVGK2HjIORStCJYznqKlSYcpn+QrR8KM0x7cFAABmrYTB2nijYd3rSbKSK32cKo+UU+exWaMFVFW3jAUZqWH5TzyDUNjsYi2wjkAIFW1hG4HAxVi8h+cMvSki5XmpbGhhgRm+6KYsHlzcqMVZ6HNSBS6n1pFDEt1Lk4BWnJbo0uCoxWfq19NpmlTzxYLqVAyOOWA/rWXNfa7Pd3s1jPbLDaBD5Txkl8rk854qWxm5LYmOYuFG2pU8uKJ55dqRRqWdm6ADqal028Gq6VbXW3aJow+30z2rjfiZpmpvo13c22pvDaRwEvbKn3wBzzUspHY2whuVW4iKvCwyrDoRVLVZ7LTlE93dQwIem9sE/QU3wUwk8F6Vk5P2dc1mv4UGo+MLrUtYCz2McQS1iY8L/eJH5UgNPTLqz1FPNtJ4poxwShzilvrzT9MHm31zFAhPG89fwrjtKitLT4mXkOg5NgIB9pVDmNZPb8MVr6h4et7vxE+t6tIJrG3hwkDDhMDkn1pDN7Tr3TtYVmsrmKdR12HkfhRNbeTJnHFcN4Ym066+JU0ugr5VktswnUHAZu2B9a9KnUSR470tAKMcKyHoKqeZbvfy2kcqNPEAXjB5UH1qj4h1o6FZgxL5t3OdlvF/eb/AVzfgizubD4gatBfSma6a2jkmc/3mXcQPYZx+FFgO2ku7Syj828ljhiBwWc4FFtrmh3V5HDbahbSux+VFbk1yfxHaGJtIhuUd7Z7oNIiDJYDnH6U7w9qPhKXWYbaPR206/OTAZRjf8AQ+tNMLHdXsCkeaWVEUZYscACs6x1rRLy5W2h1K2kmBxsB6/T1rA+Jeotb6Xp9g0rww3twVmdeuxQCR+tYM03g++e0soba50po3X7NeFMbyPU+9PQR6jdTQxqFRfyFZ95q1rp8HmzypEhONznHNWyFKgEgkDk1R1LSNP1W1FveQiZN24A8c1G70K2RRPijR5V/wCQjbf991s2KRyQC4DKYiNwbPBHrXnWu+FtGn1my8PaXYpHcy5mupgxPlRD+pJ/Sux8R2UsHgW8stMfy/Jt9iEnnaPf1raFO2rM5S7F2LxVoMl39lTVLfzs4A3d/r0raJxnmvB7zVPCcngSO2t7J11PylVGAwwk7nd9a9K16TUNP+Gdwwk8y9SzAaRT3wASPwzWqZDRrHxToYvPsh1S387ONu7v6Z6Vpu+Nrqcgc8V5zHoXhg/DgzlYS5tjJ55b5/Mxxz9a6H4e38mpeCLCedi7gMhJ74PFNMGjr5MTwB0+93quJAOG7UAvHyh49KglYu33ME+9NIRKs4DkgY96j2syMQepqSG0eTFacOngDLnApXsBlwwysu3nFW4NOc8461eMttAdoI3e9RNetkhcCldhYctjHH95vwqUeRH0waotMzH5iaZn0alZjuXmu0XoopDeBlyvWqXNJyvK07BcsG7kVqV55GTcDVcYkXB60kb9VNFgJI7mTzPvGpJrp17mqqAiSllbLCiwFiK4k6sxp7agV96qyEgALWTrt9PpmlPcQRiS4Z0iiVum5mAGfbnNFgOijvix+Zak+1W7cMua4GS98SaWUF7JbXEErKBKkZUoSeVxk5+vtWnF4lsTqjWJWVXG4CRl+ViuMgfmKQzrPKt5RwAKrTaWjZKEVy8PjWwls57oCZI4sEbl++D0x9a1tH1+LUrYTw71GSpSQYIIoAz9W1TStBuEh1G9SB3G5VbOSKr2fibRNQm8m01KCSTsucE/nWJr1vaar8Z9HgvoVmgNhISjdCRitTxl4D0O58O3N3YWy2V7bIZYpYTggjsfalzMLI24QZZhvOFBq1O4ZyAeB0rB8FTza54M07UZSTK8ZVyO5Viuf0rWMDI/zE1aaZOxJkUxpcH5TmogxZtucCgqRnbzTELG+6UAjOTVm7I81UxjFQWsTGZSPrUkrb7ps9uKBi5AXJFQTRpOhC9adM5ChQKTKhAQCDSavoCdjOZJIQVPIpltIYZ9xrW2rIAHFZ95B5cowOK5Z0rao2jO+jOemk83xlqL+sUR/wDHRW1b1gKwbxZf4PSKMf8Ajorft+1aR2Je5r2nUVuW3QVh2nUVuW3QVQi+tSVGtSUAB6VC/Q1MelQv0NAGXddTXF3G3/hNTn/nzGP++mrtLrqa4e9wPGw9fsYx/wB9NTjuJ7Fq6h+fKURtuXHerJG9zVQqY5s9q3b6GRPD+7bB71pRRKoDnBqim2QbvSnrKxGM9KiXkNFy4RJ4gvT6VVMKQDIxRGXZqvQ2vn4DipvYvcrABkytKIgR8y1eW18qbGMrT1t3JJxxmlcLGHLb+W+4dKlWBim5ec1tm1DJtZeKzzDLBLwCV9KfMKxSMbB/mGAKSSPzE+7mrl5fWen2MlxqEqQxqOrnGTXB33xS0ezZ1to2uCOjD7uaXPbcfLc6dVw23pUyowbrwe1eT3XxTv7hGWG3iifPDgdqyo/iB4iRi63uc9ioOKPaIOQ9sAeOUMAcVqwRpIofqTXgUnj3xDPDsa8K5OcgYNWbT4j+IbK3aIXCyFujMMkUnO41E9/Mav8AJgVmXFs8cuFOc+leW6V8W9QhkH2+GOZPVcA12Fh8SNA1GVVkuPs7t/z1GBn60KQNHTDIXaw5qMeZvwARVgILtFmgdXRhkMhyDViOAqmTywptiSKstpviHZ6hji2A7utaJUj5jUUkROXApXHYpFCwO4fjTI9xO3nFX8kxDC5pFt3bkLgUXCxW8guNtQLCQ5FaIiZelVJ/lbIFIYwJzUypt70xPmTPejcaAKOtWD6hpc9tEQHk24z7MD/SsZdN1yO8u4bN7dYLpUDSP95MLg4rplJzk0pAHzr1pWGWNNsYdM063s0OVhjCBj3x3rG+IEKzeB9WK/eW2Y8fStdZTInJ5qNgZAY5QHjYYKsMgipYzE8FObfwrpKsDzbrkGuT8V+JYtT8TyaNPqzaZpdso85o+HnY9s9gB/OvUI7WLYoVVUKOFAwBWfLYabNOzT6fbSMTyzxAk/jUjMTwnqHhNEGlaDJFvI3NjlnPqT1NUtR8Srovi2bTNXRItPljDQSsvDccgn867C20vT7SXzbazghf+9HGAf0qe/sLHVbbybu3imUdBIoOKVhnmFnJp+qfE6xuPD8SrDBE/wBskgXahBUgA4464r0zpzVG1sINNBgtYI4EPZFABq5jHFIDjvEXhbVb/wAQxavYahHCYotiJIgYIckkgHv0rltDstej+JN4Jb1TOiIZ5dgxImBgY+nFesscZzyDVF4IhM0yooc8FgOTSGZPiXXLTR7/AE46jZK9pK2PtRXPkt2+lcx4k1Cx8Q6zolho0i3N2l4sxkiGfLjAOcnt2r0aO3jvYGgniSWJuqOMg06HS9N0lcWdrBbluGMaBSapCOQ+J1k1xpum34gMsOn3G+YAZ+UgZP6VheMNe0rXtCh0/TXjubq4dfIjjUZT/CvU3uIljKnayEYIPOayYtL0+CYzWVjBDI3V0jANG+wC2cLwwwQyHc6oqsfUgc1ovHFawSTv0jUufwGaS3hKfM45qUurqysm5TwRitqdOyM5TucV8PIW1CTVvEFyMzXk/loT2Rc8D86ufEO0u5PB94LLecYMip1ZO4rqoUhhiEcMaxoOiqMAVJ8pHPStLaWIvqeX6lrHga5+H4ghgtvP+zBEgWMeZvx+ec10ujNeaf8AD6Jb+2a6uYbPLwOMlxj7p/CthND0u2vvtiWFt5uc7xGM5rTlhEx86E4zyaSVh3PF71PBZ0Nr2yEv2qYYj04TMQsp4HyZ7V6R4L02TSPCljZzLtkVS7L6FjnFXo9F02K8N0ljbi56+YIxn861ra0eRixzg0WsF7jERpDgVet7EHBkGPrUypFbrzjNV57pn4Q4FF7hYstJFAMKBmqr3Uj5AOKgDFutLRYLmbfW8rP5qMfeqy3UycZNbDDjnkGqF1AUbco4od7aAiFdRkDfMOKnj1GMtgioljWVcYGaha0KtkVl7TuXy9jTW5jPGeKkVxnKnIrF3sj7WFTCVlIKEkVamieU05plhG+st9YH2gKo4q8UFzEA3ANZzWiQXIJUMKbfURoxXglkAAxUyHc5BrNhwtznGB2q4x2gtmmndA9yR50ST5jwKxtf3anp728D+VKrrJG3oykEfyqd5duSwznpVd1kmwQMCocilEwLka7qkkZvZYoRERtiiPDHPLH8qpQ6Lqy6qt2Sjskrt5juWLK2OME4GMeldfHa856mpWXb8gHzGo5rsrlscLb+HNX+zXcW2JUkVQsG4sjEHkjJ+XPt0rrPCWj3ml2DLeuSzOWVC5bYPTJ5NbVtAFXLDmrOMDitkjNs868Q6ja6V8XNJu7yVYYBYyKXY4AJxVvxV490x9Fm0/S7j7be3a+VHHD83Xua6u/0XTdUdXvrKC4ZRhTIgbA/Giy0PS9OffZ2FvC/95IwDSsx3E8EWT+H/COnaZMP3kUZLj0ZiWP866No4bleMA1mfjT0kZDwaLCuNudNdCSvSqufKQjGa2IrwP8AK9JPZrKu5MU7hYzbEOS0vQDimBslmI5JpZYpbbIGcHtUCOQSGpiJmGVxU0EAYZb7oqOFGmbHRR3qSeUFRFHxjqaAI7lldwEGAO9RsiuAr9aSXKx8DmohvwGPWiwHJyxiLxlqSL0Ecf8A6CK27esWbP8AwmWo56+VF/6CK2resyzXtOorctugrDtOorctugoAvrUlRrUlAAelQv0NTHpUL9DQBl3XU1xdxGJPGxz2sx/6E1dpddTXGzf8jq3/AF5j/wBCamtxPYu4KMQajlUOvFWpV82M46gVXiOAQeta3MyGFij7e1XfK3YK1VkXnI61asG3SAOcCk+40WYoiNpIGc1qRg8EGqksXz5VuKtW4OCC1ZstExYjGPxoLE4FCggHJFYfiXxFa+HdPNxczKhbO1f4m+gqSixrniPTvD8KzahcCNW+6vUn8K8o1v4vXk90/wDZUAihHRpDyfwriPEev3niPUZLu5kO0n5EJ4UVhncenSoch2NLWvEOoaxMZLy5eXPOCeBWOgJOPfNWILZrh8dq0o7GNVwAfdj1NTZsZnQgF9qx72/SrLQMSFI59Aa1YbJTGdoESd2J5NRGCNHzFISV/jAppAZbxSK+1EWPHUsaibcjYeTcfatN7RlUtgknnJqp9mw2TRYBnmoQMxqfrSeYmTtUD2BqytmsnLE/XHApz2dpAdwkZj6EUwNLR/F2q6PhbK4cJ/zzY5Br1Hwv8SbfUkFtqR+y3YHVvuv+NeOh7Zl3GIY6ZU8ipNy4GGJx0Y9qExWPpe3mM6CRGDoeQwOQamVZmGGFeF+FviBfeGpfIuAbmyY52k8p9DXtOh69YeI7FbrT5wy/xIfvIfQ1VxWL6Q7euM1KDtUikII70rL0NMCFzgHnmqEsTMCxq1dRuZQVPy1FMHIznihAygJChxipht25PJpJIwVyRzUKsRwaYgu7iO0sp7uUnyoULvjrgVQ0HXLLxDYC9sXYxbipDDBBHr+dM8SPt8K6qP8Ap2auO8CSDR7oWchCwXtkl3H6bhlWH6CpbsxnYXfibTrXxJBom9zeSgEAL8oz0BNJrXjDTtHuEtCk1zfOMrb26bm/H0rz+wje88ZaRrcpOb7UH8sH/nmpCj+VdB4JRbjxBr+ozqHuRePEC3JVQTgCpuUbuj+ObC91BNPuoLmwu5P9Ul0m0P7AjPNVtX8f2GmySrcafqKrG20yeR8ufY5qH4lW0B8LHUFUC6tZo5IXHBDbgMfrTvHMgf4cO0ihpHSIlsdzSGXdC8a2mtXK28dreRZXd5k0W1MfXNVJ/iHZfaZE0+xvr+OJirSwRZTI9CSM1D4ljm034cG4tiA5s4gSowQCozXReFrKxtfDOnQW0aqv2ZCSB94lQST+NICPR/EGn+JLaSaykbzIeJIpF2uh9xWGvxC05pZo4bLUZ/KcozRQ5GR+NQyRJpXxYgFqoVb2zkNwq8DhcgkfWsLwlrdzp9pqMMGiXF4ovpG86IjHOOOfp+tAHcaN4n07X5Zbe2MsdzEAXhmTYwB74pbHV7K+W8lWQrFZyvFMzjAUocN+HFcj4Xu21r4i32oTW5sZoLdYhbH7zDJO41b8L6YNX0PxZYtMIPO1G7QSH+El2pIC+vxEslia4t9K1JrIDP2pYflx64znFaWoeJrCPS7XUUS6vYbn7hto9xH16YrnrTWfEXhvSo7DUvD0d5a28flmW2b7ygYyVI9K2/Cl7pt3o8X9kRbLQsf3bdUPcUAYi/EPSZZXhistSd0OHUQZK/Xmu50yRbmxiuEjdFkXcFcYYfUVyHhS0j/4TrxblVwtxEAMf7FdyXCfKBxWtOHUznLoOIyKIpUhLBxkEUisrDrTZB3ArexmPEkEvAO00jwSp9w7hVfYOD3qdZJUUHOR6UDI2fbwwINJE0mCqZANTO5uMLtFaFpaBPmfgCk3YCO0sjjc9WpZkiXalMnuNvyp0qmcknJpbj2Fdy5yabtFL2pu7HFMQNwOKbkmlZs02gQuTikI3DBGc0UpHApgZ80TQPvHSno6unqatuA42t0NUJIWhbKdKynC+ppGVhHj3dRVZnaBsfwmriuJFweDUUsIcVhez1NN0LDdkJjqO1Cu0swIGRVYQMOBwKaty8DEYrXnurEKOpYu5ChBAwaY10zxgGomkMhy5zWLqnjHw/pExgu75BKOqKNxFTzNKxVkzcDGTA7CrCrkgAVkaPr2la0udOvI5T12g4P5VtNLHbxPLKQqIMsxPAqHdlIViI0z3pbeMud7Csi01mx1qRv7Ou451Q4fYelX9R1rT9Ctkm1K6S3jb5VLdzW9ONlcylK7sae7Jp2ap2F7b6jaR3dpMssEgyrr3qrq3iLStDaNdRvY4Gk+4rdTWlyDWzSZNZOpeJNJ0i0gur6+jihn/wBWx/irMX4ieFnIA1aLcT3BFFx2OqBzS1n/ANr2I05tQFzE1oq7jKrZUCpdP1K01WzS7splmgf7rr3oEWxwanhuWjbk8VQvr6302zku7uVYoIxl3Y8CucPxH8Kf9BaI/gaHYZ3zIl2nbdWVdWTIxOOKxtH8b6Hqt4Law1BJZcZ2j0rr0dLiMBqm9gsYpuBFF5ajBpF5UHvVi8stj7scVT37Dtwc9qoRI7hVyfyogha4bzHO2MUJblm8yY7UHb1p89yJEEca7U6UwONvSreONUKfd8uPH/fIrWt6xJRjxjqI/wCmUX/oIrbt+1ZFmvadRW5bdBWHadRW5bdBQBfWpKjWpKAA9KhfoamPSoX6GgDLuuprjpBnxsw7/Yh/6E1djddTXE3NwbbxwGAyDZgH82prcT2NbO05qs/3twq1kSLuA69qqucPg1o9DMniCvxtzUjQiF8gEVBBmOTd2q826den0oY0PtpGI+Y8VoRqBhgazkjaMYPStGHa0eAeazZaINT1S30qxmvbhsRxLuNfOPifxHeeKtYlvLg4iB2wxjoi/wCNem/FPVozZR6SJMKzb5dp646CvJSEVdwUBRwBWbLRXjgUYL8g1J9kDMCxCJTrcPcTAY4zV2S0aQ/Nz6CkMgikWKIxxIAT1c08JldxyB6+tXrPSzkF/wDvmtVNKVuSKBGDGwVOAxz3zTFE4JK8g+ldQukxleBzUsWkhX3bFYDse9OwHLgzSHZJ3q19jWOPCKGb1Iroho4Zw56ipxpwC5KjI70WA4qaxn+8CcegFR/YHY9Oa7WSyVVGBnPWqc1oN3CiiwHINp7ozYH5VA0bxcEcV1z2LY3CqNxZ7hytKwHNs4+4a3PCviG78N6tHc2z/ISBLGejisu8smRsgVCQPJyw+ZOlAz6ns7qO9sormM5SVA6/iM1KSWGM15t8KfEqXlgNInf97CuYsnqvpXpRUK4OatElafhcbuars5K4zV64Re1VPLVSSaBEJBI5qsyfNxVhnyTg1CwO7r0pgZes2sl7o97Zpw80LIpPqa5XVPCuoT6DpEVnIqX1mnlM2eqHqK7TVLlbPSbu927jBEZMeuKwfCniQeI9La78rypUfY8fpwCD+tSykI/hqWO78Ni32iDTP9Z6np/XNVr7Q9Y0fXbjV9AaOVLrm4tJehb+8D2NST+MhH40t9Bjh3ByqvLn7rHnH6itTT9dF74g1PTGjCLYqGMhPUcVIzEOk+IPFV7ax62sVlpkEglaCLlpWHQEntXSeLNFl1bwvPp9oFEj7QmegANc+nifWdbuJv8AhHNNSS0hfYbmc4Dkf3c1s+HvFU2pT3umanZNZ6naR+YYz92RcHlT+FIDUfSo9Q8Ox6VdDKG3WF8eygf0rjrSDxh4VgGmQwW+pWsXywTOSrBewbFdf4T1n+3tHW/aPy8yOm3/AHWI/pUZ1tLzxheaCIQDBbrNv9c0WAyfDHh6+TVLrX9bnWXUp0MaRoMJCp7Crng7R7jQ9MurW527pbyScY9Gxj+VZ/izxkPCl3aQLAZ2lO6QD+CPua6S81BItEk1OJQ6rCZVHrxmgDEPh26T4hrrMSr9ka0EUnPO4MT/ACNQ6f4PuW0jX7Ca4aD7feTzxSRnBUOxI/nVHTPGHi/UbBL2y8ORyW0oJRy+MjOPWr974t1TSPCc2p6npqwXMb4EQbIxnrSGUorrxxZWy2MmnWdxKq7BdEkBu2SM1peEdCk0HThbyuJJ5JDLKyjCgnsK3Rvn2tn7wzVtECJ71UI8zuTJ2Ob0fSLnTvEviDUJSvk38qPFjrgLg5raMnNVdY1QaVpd3fmMSGBNwQ96p+EtbXxdof29IhDKrlJIv7p7foRXQrLQyeupqwZMmc1YLjBrirjxkYPHEXhyKAHc2x5c9GxnFdUpbGCc5NVdMVrE2d3Q80+EszbTyKi8thIMd617K0GN7jFJuw1qPtbRQN5FOubg42L+lMvr1IV2A4qlFcLN0PNRuPYeWJPSgHnpSg5oPSqJFqNutJzRQMKKQ0UxC0GjNITQAAjuKacGgmmk/nQBDLACcpVdhJH71d3Y4701iOn51LimUpNFXzFZBkc1TO15WyK0niTGF61mXtvJCQynGaj2Viuco30sy2N15AzKImKY9a8j+H954eS/vv8AhI0ie/kmOGueQB3/ABzmvUL69fTLK5vdrSeSm/avU1yul6f4b+IEJ1CSwiSZ2IkC4VwfU4pWC5YXwXar4uttc8M3sMFqGDSRRtuU/Tnoa0fifrMmm+EZo0bE964gQDjqef0BridU0f8A4V/460mLR72V4rmVN9vv5wWwQRVnx+2oeLviFBo2jYkawG4Dd8oYck/pTUbA2VfBMVx4M8d2tjcsVh1K3BGexPI/l+tdF8dFP9iaOmeTPJz+CVyXjPSfGNt9l1rWVjK2LKqvGwyo/D6VtfEzVU1nwV4XvUcMZJHLc98IDVPawupr/BTVZDp95ocx/eW0hKZ9Cea8/wDilqsmt+MrtoyWt7RvKU9uOK2tQupPAXi+31RARBf2SucdCxTn9axLjS5E+GrazMP3t7fAlj1xzSYI6L4j7ZPDfghZceWUwx9Rlc13N54Z8CDQWeW3s1HkA7w5BB29evXNcH8RIjP4b8FQueHTb9MkCu2t/g/4baCFpTcSEopI8w4PHPen1A8+8LS3Z+H3i+KN3bTo438ok+3b9K9I+DvPw9tsn/lo/wDM1Z8X6PYaH8MNYsdOtkt4Etm4QdTjqfWqXwekjXwBbK0i7hK2RnkcmhaCNL4ojHw31cj+7H/6MWuF+H2neArjwtFJrK2TXxY7/OlZSB24BFdx8UCrfDfWSpB+WPODn/lotcj8OfAvhbV/CMN7qNnHPcuxDFpCMYx2zT6j6HbaBpHgyK8M+gQWQuFGC0MhY4/EmuthlZBkHnviuc0Lwh4e8P3huNJs44pnXaSrZOPSt8cgnn1xTEa8UqXEZR8ZrNvLRonDgcA0RyFGBHWtJHW5i2t1qdg3MOeVpQBngdqhdwgXHWrd5bGByQOKosvmHpzViOWmbf4y1FvWKL/0EVtW9YkilfGGog9RFF/6CK27esizXtOorctugrDtOorctugoAvrUlRrUlAAelQv0NTHpUL9DQBl3XU1w16u7xt6/6GDj8Wrubrqa42bjxq3/AF5j/wBCanHcT2J7e4fzthXA6U67HzhhV1o4xbsyLmQ96zDKxGHHetnqZrQ0LQo0ZDVZUiFgO5qhESmCOlXg6zKOzCo8hl3aWQE9DSGBoYXKtjI656DvTIJdy7HOMVV8T34sPCeoXIOHWEqn+83A/nUMtHiXjLUl1HxFK6NuijGxSO9c2qNM4QDippHMkhH8RNX9MtdzgkEknrWRZJa2vlgYXmtSC0y2SOtTrAqNjFW4kGBgc0wFgtFQc1cjg55HFPgi7mrixjAIpgQJCF64qQKoPSpTHgetOVAeTTEMCjb05pjLxtxg1YwBSEA8+lAFNoePeqs1vk5FagALZpJEUDIFIDFaEBSMVBJApHAHFasyAYIxVNgARkc0DMe5sFkQnHSsC801mRinIHWuy2bg+Ky3i8tmyMqeD7UrAcxompTeH9bt71M5icFh6jPNfTWnXtvqlhDd28geKRAykV816xZmMb1AIBxkV6b8G9XMlpd6XIxbyv3kYz0HQ/zoXYGemEZbk1VuQT8y9Ku/KWqq7APsNWJlA5z0pCMj3qSbKMcDiod1AjL8THHhbVf+vZ64rw1Mnh+7tGmbbbajpyy5PTzEJB/QivQtQsP7S0u6sy20TxlN3pmsTVfA0Op+HtO037U0T2WAswXqO4xmpaKRxVjaudb8PatMpE2oX0k/P93OF/QCti3Dt4i8bmPPmfYZNgHdtnH611V34ZjmudGmik2R6X91Nv3sAf4U3TdDWy8QalqYl3G9AUxleABipsMZ8PBC/gmwMRHQhsf3u9aU9/pw1e4sY2VtRFo7theQnufr2rAXwZqGm3c76BrJsredtzQSR71UnuORWpoHhRNGN5cS3T3d/eLtmuJBjjB4A7DmkByHgix8Uz+HzJpmp20FqbiXYkikkfMc9vWrXhZdStfihqq6tcJNdfY0zInTHauy8OaKPDukLYCXzQJHfdjH3mJ/rVW48LmXXtQ1aG78ua7tRAPkzsOMZ60Aefya3a6pr/iC8udOvbyCaJ7S3eGEuqj1/St3wnq51H4b6lZzFhPYwyRMrjDAY4z+tdh4d0SHw/o0OnRkSeWvzOVwWPc1QXwYsGqaxdxXWyHUrfy3i2fdb+91pDOW8JWvjOXwrYNY3tnFZlD5SyjJA3H29c1Y8eLfRfDqdNSliluwRvaMfL14/SpbPwb4j02yjs7XxNst4xhF+z9Bn/eq3d+Fb7U/Dc+k6hqnnzStkT+VjaPTGakDq7SItGjN/dFSvJ820DNcZH4Z8UW6IP8AhKcomOPs/b/vqta2N9/wls2ZWeyFn90rgCTcvOfpurqgrIxk7sZ4zCjwfqZ6N5X9a5Pwve/8IlfQNM+y11HTY7lSem9Vwfx4Fd3q+lf2xpVzZNJ5fnpt3AZxWLrngL+2tC0zTzO0RsVVBKF5ZQADxn2pyQJnGaZbSTeJ/DGpT/LcapdPdOW9GJIH5EV669r5JyTmsC/8NRS6pot4khRdLAVIgv3gBgV0cO+4cBqIqwN3JrK33y7j0q/cyiNdi8cU4KttDx1NUJH3kk0bsNjD1KcvMQM8VLpRzn1qtdf8fTD3qCO7+yyjHQ1N9SraHSjgUzcagtLkTx7qmfitDMUtTTIgOMgms2/vxGm1M5rJF3OH384qXJIpRbOoozWfY33nrtbrV0HNUncTHE4ppag9aYzUCFzzTSeaTPWmk0ALuxSbscAZNITTS4QdKABpBENzctWfdPLMuccVKpMspZzhRUixieXA+4KL6iKcNkssMgkUMpGCD3FcFcfC2za/luLC/uLFZGyUj6A+1emXURgTMfINVrdWkbkUNJIE3c5Tw98PtM0jUl1KaWa+vFIZZJj0PtWxoHg7TNC1W91KFpZLm7zueQ/dyc1tzMkKkAU23kD8E4NStSmQatpdtrFjNp95zBOhVueR6VzTfDPR5NDtNKeedobWVpUbPOTjI/QV12MucntT4yMU2guYHiPwNpfiewtLW7MiLaKFjdT82AMYp+peCtM1PwvBoJ3x2sBVl2/eBFdCrDJLDNO35zkfSiwHNaz4I0vWrfSoLh5VGmkNFt7gdj+Qrp1+VFVeAAABTQx2gfnSr05oSAqavp0OtaVc6ddbvJuEKNt6gGvPx8HtGs0Aj1a/jXuBxj9a9KdgqE5rn725luZSBnFKTsNGLZeAtIh0q+0s6hdzw3igOXPIwQRjn2qlF8GtJhTbFq1+innCkf41vqksLB+a6CwmM0Iz1FJO42rHM6D8ObHQdTS+i1O+mZeNsh4/nXa5OSfU0wcDmgtxwcH1qkTceCalglKODnvUI4FA4NAGrIq3cJwOaxZIzFIVIrQtp9jAdqlvbcOu9e9JOwzzm4/5HTUv+uUX/oIrZt6xrgY8aakPSOL/ANBFbNtUFGvadRW5bdBWHadRW5bdBQBfWpKjWpKAA9KhfoamPSoX6GgDLuuprjZRnxo//XkP/Qmrsrrqa4q5k8vxqfezH/oTU1uJ7GwrfKV7Vn38EkcXmL93NXu2R3psvzwsh6VrsRa5BppF1EQT8wq9Gnly4PSs2xiFtMX3ECtc/vY/MQUpd0CHzABg6VxHxT1YxaVZ2CcGVvMYD0HT9cV3NvIH+UrzXkvxNu1l8TJGhyIY9pHvispbFxOOsrUswL53P1PtXS6bbATfdwoqhpsHzo0hzxk/0Fb1mFUkBSDUIsbIg8w+mamtyA2MAUroGJwOaljhBKnHFMC5Cy44GeKlBbGTwKi3eUoGBxQ0qtg7higRMPrmjdziofOUdDmpPNVgMUwJMg9qUkYxTPMApkkwGMGgCUdaRnHIxVYzEck0ecc4xQA6RA43AciqcsGR05q6JecMOOlQTuwIIHy9DSAqqu0EYqhMD5hyPlNapIboKqzIo5IoAxWija2uI5UyB19j61b+FUy2XjQxnpLC8Y/Dn+lT3FmdjPGAd8eCB34rE0Wd9I8U6fd9Nso3e4PB/nSGfQ7bduR1qnMuTupbidxsljXKsM0kcxn4KirJI1AlUgjmqzQGN8GrUrGNsBcUOVdOfvUARINtP6pWdqov20uddNx9sICxk/w5IyfyzXMA3uh+J9KsYdYuLye6VjdW8rBgBx82P4eeKTGd1GRtKnFVNwE+Md64DxHLf6LaSX17rk8WrSylra2Rh5e3OFXb06YrZ8U6reQaf9msSF1Ca3MjOP8Alku3LN/hUtjOx2jg08CuA1jV7iDwVoR+2Txy3LRrLNHy5GCT+PFbPg+4srlrtbfVby7mTb5kV2Tuj64OD6/0qRnTkZ4pFYdKx/F2pvo/h+eaE4uZP3UPrvPSsbwPcXtvNf6Fqc7z3Nm4ZZHOSyMM9fxoA7VUDOMGnSOCduRgV5p8PNe1C2ns4dYneW11MsbaaT+FxyUz7jNSWqaprHhi/vbW8m+22epytF83DooXKEdxgmgZ3c0y5+XFLAoILE1wEGsTeMtQtLOxaW3tbdRJfspKnzOgjz+B/OiLWbvR9F8S2ckzvc2s7LbFjk4flMf99U6a1uTJ6HoMqhl68UR2yyY2PjHXmvN01bUrLwLqOnT3MjapBMLRZCfny7YBz9DVmPxDB4e8ZTWmqX8qQfYk25yw3ZGTXRzGdj0jfDajHDNUEl7IeSQF9BXBQ+JbfWPGN2um3by2sels2OQPMDHnH0IrmNCvNButJim1bxFqS3zFvMQXDgA7jjofTFK6FY9caQNIDkc1sWMShfM4ryjxA1nFqXhuzn1a4t9KljJaYTFSwwdpLZ+lXLLULOy8ZaTZeGtdub+GYuLuF5jKgTaeec45xScuhSR6Pczh2wGGB71BkbOua8lF7o1z4h1tda16+tWjutsUcU7qoXHoDXofhuOyTRUOn3c13buxZZZnLk/iaaYmVb9tk7Hpk1WjtRcSrubiud8S3EI8WXCeIJry204Rr9kaJmSNuOSSO+c1Noelw6jZTW/9szXVgZA0EsUxEiD+6WBzS0uPod3bRJBGFUj86fO4EZ+YdPWvOfCvh9r7VdWNxqmosljdiOJTcv05PPPPSsy4uLGfxJrkOra3c25gnVYE+0lBt2jtn1puVkK2p3fE0zZ55q55aCIqVXP1ry611O5/sPX3tb6aezhyLadmy33RnB6nnNS6b/wj13HZ51/UDdSBcqbh+WOOOvrWPMaqJ6DE3kXQGQK21cNGG3D868h8R3FsvjNYNR1K5trVbbK+VIVy2R6fjXU6Bp+karptxHp+q30yMVDsbh9ynnoc8VpCVzOcbHaFx6j86aT3rzrRvDrXPiPWbWbVtSaGylRYl+0t3UNzzz1r0FRsRVznaAKtMljs0hNIGpCaoQhJpshOwcU4k1FIeOtNIGQSKynAPBqxp79QabkMVz3psaNHOOeCam+tibaXL1w4CYIqmrrEm5jU90MxcdazpIGbG4mhq4RdtSyJY5nAxkUzaI7gdhTIVWNxzUjuHmyOalaMvdEqqGYkntSp04pUxlicdKYhHNUBLmnA1GDS5oAkBp4PFRA08HtQBFePtgJrOstrucjNSXsjNJtzwKhtABPxWUpWZcY3LsxVoiu1Rio9PkwxXGOaW4txHEzAmqtu5icEd6SlrqVKK6G+SeBSVGjFow2KrvdFZtueK1Mi/R3pituTNOHSgBwOBWlaTeavltWZUsMhjek0M4nUUCePdWUdAkf/AKCK1Lesq/bf471VvWOP/wBBFatvWaKNe06ity26CsO06ity26CmBfWpKjWpKAA9KhfoamPSoX6GgDLuupribsKfGpBHP2IY/Nq7a66muIu22+Nv+3Mf+hNTjuJ7GjDIVIU1LJ8qHHeo3G8ZTrTom3fK3WtnqZ7EUfzNtq1FL5coRjhag8vZLUzwiZQR1FT5DLoXZOGTlTXj+tW41LxncNjMay849a9bhcqmwH5gMV5n5Lw69dRHG9WY8+uDWUi4lO3h8pnmA+XJAHrV6xjbBZu/NR3zLbxhOpPTFWoCVgXPXFSUICEcjOeae8xHAAGPSqV3eR2gBYgE9ayz4ghaQgN1NAzfR2c88+xqUJu4xisy2vVkw2QMj1rXhO9QQQfoaAI2iYcDpTQrLk5PFXvKyQDwKZJEeCvIxQIijbIyQaRgWPTipY1YDGKlRcHnFMCr5RYY20hTapHcVe2ryAazrq5ht3IeZRjryKQELyHPXFOEiNCQrgn9a5/U9diUskHzHNYn9rXnm7l49qVxnc5wpHemspeE461laXqL3KAS8N/OthWwhBpgRWxJiPdlO3HtWHcW2ZTLjAifd+takUhhvdpOFk4qG5iIfLuNrsVIoA9jtH8/R7VxyGjBFQFJUlDICR6Ck0CUPoFnt5UR4FaEeQ5OBVEjGiDxgnrjpVR+G56U2eSaOdjkY9BTg4lTOOaAMrxL/aK6FcHSEL3jAKgUgEAnkgnvisDwvHe6efIPh2WCSb/XXjyozE+p5zXSaxNfW+lTyaekcl1GNypJ0YDqPrisG68XA6BaXVggk1C7byo7cnlXH3s+w/rUsop6nF4kvtJudHutHW7lZnSO8Lrs2EnBOTnIB9O1TXvgT/iWTGK/ujdG1ETbXIVyq4A+nFOtNV8R+ILqeDS5LW1t7Q+VNcyAnzJQPmCgdgeKmtvE2pWv9q6dq8MI1CytXuInjPyTqqkg+opAVtIstb8P6Hp6WcX2142BuLeRhuAwfuE8cHHetXRLHUr3xXc6/e2QsU+zi3ihLAu/OSWwT7VY0y+mu9Ah1N1VXkgMpA6Zxmsd/F2qyaFoVzYx2wu9TuHhImyUULn/AAqRl/xNoM/iPXdPtrmM/wBlW6GWVg2Nz54H5AfnVSLwkdC8U2Oo6LExgkUxXSs/QdjzUt5rniHRNR09NXSxmt7qYQ/6NlXUnvg9a6XWdSg0TSbnUbjJigQsQvVsdhQBzlj4UuH+HcGkXaiG9i+eN852SA5U5/CjwPp1/o/h2W01FAty93JKdpyCCFAP6VEbnxzNpw1QCxAK+YNP53FeuN3TdirNzrtyLnQoo7byX1JZfMSXrGyqCKTGhPCekTac+qG4iCGe8aVMHqpC8/zrM8QeGLy98cWd9AoNg+x7kZ6snTjv0FN1HVfGNhrGn2Sf2W325nWNtjcbcZz+Yq7dazrWi3Fg+rrayWc7eXLNACPLcngnPbpW0FpqZy3KGp+H7u88d2l8qj7AzrNcc/xp04+orZtNKmXxxe6lLCDbSWqpG5x13DimQ6vNfeKjp9ksbWtsubuY8/N2VfeugupTDZTzKAWjiZwD3IBNaWRNzCm0eb/hL7i/iiAt5dMNvuGP9ZuJ/kRXO6B/b+iaRDpz+FXmMJYeYssY3ZYnP3vetjwj4uk16yuFvIVgvocvsHR05ww/EEVEnivUY9Js9Zkt4nshcPFeBQdyKHKhh+A5pabgaX9iXuo+IvDuq3NgI4IEfz4nIPlkg4/pUniHRWl8S6Hqmn2qB7a4IndAAfLKsPx5xVvUfEs03iCx0bRhFMpUTXc55WOPGRjHc/1rY570krg3Y4CzGt6JrGsNH4be+hurnzY5VkQcYx3IrrdKu7q7shJd6e1jJuI8lmB49eCazvFvic+G7NHjs5p5ZGAUqvyLyBljT9a1q7s7Gw+w2gnvL0hY1JwqZAJJPpzTWgbmZq02v6dq9yFtDqemT4aJFdQ0JwMrhiOKq+GNHuLG51C/ubVLP7Y4KWykHYB3OOKf/wAJLqFrd3tlrFohurWDz0NqSwkX0x1Bqlb6/rUWqaamq2lukV++xVikJeIkEjIxUvVlJ2Ru+GtPudNu9cmuFCpd3Yli5zlcGsjTtFmj1nWrie3Ui6uQ8ZIzlQoH881c8T+KDo81ra20XnTyyor+kaE4yfzp2v6/f2Oq2en6bBaNJLC0rvcSbFUAgD+tW0rWIu7nOS+GL1B4it4LYCK7Aa3AIALFRn6c1qWV9r1rptvanwk+Y0VGcSx44GM/erobH+0XsUm1FIFnYk/uG3LjtzVzzZNmc8Vm6fYtT7nnuq2mrWni3+07fSWu4mtvLKh1G05B7n2rp/DWoX1y0yXmltYhcbdzqd35E1sJF5r5xSOgDEqMEVpGCTM5TuZekadcWviHXLuZMRXUqNEc9QEUH9RW4ajWTcvuKcWyOKq1gvcQkCm7uaa7gD3qPBYZPApNpDSuSu4Azmq7SFlJxkU1ivIzk01CwyO1VF3JkmhyM7j5VzjtSmZtwAHIpELxyZTipZUaQ7hgGstVPUrRxGS3LsQuKJZnRMMnJHFDI+3pzTmmd4grqCR3pzTvcIWsUyso+YjipAJEXeAcetPUtgqRxSoXUY/h9Kc720Jja+pCZmPGakSR1UcHFMkTByBVmGQeXhhUamujJVYMBinVEyFPmU5WlVs8d6tO5LViUEDNIZVBwvLVFNJiMjPNLo1uZrlnc8LSlKwRjcSbS7iUGUjAPvTLK2CS4Y810xw2R+lYc0MkczELxmsr3NNh9zbl7cishLORm2oc4rWDu8RyaW1jdJvun60mrId7kNvvjQo/UVAY/MkOTg9q0LyIq28fjWdMeQ+eapTuiLWZftnyCpPNTg1Rtz84IPWr2K1TJegvanDNIDTlPOKBHE3n/I76n/1zj/8AQRWvb1kXn/I76n/1zj/9BFa9vWZZr2nUVuW3QVh2nUVuW3QUAX1qSo1qSgAPSoX6Gpj0qF+hoAy7rqa4yaJZfGzZ6iyGPzauzuuprjZd3/CbNtH/AC5DJ/4E1NbiexcVjESpFKyEHzBU0se9Nw6ioVYk7Sa3RmTK6ypuPDCpImG8c8VUZWjOQeKsREOnHWs5IaLQi8mbzeqmvMNRuAfFtwwON0pJ+leoQ5ZdjGvJdTTHiq5JGCZCKzlqi4heyCW+T0OSKvof3efas54QHSQnJJwtWpCwtJCDg7eDUlHNayWluW3Atz0FZrWz/eCkD2FdDbWzyHdL8wHc1eF1p1qpQhWPoBzSGcMbi6hYqpYAVbtdc1GBw0cpOOx6VuXmqaWTzbxnPcnJrM8yzlfdFGOewpAbln4mubhAsqAN6iugsZ5ZIQz4Oa46J4kIZcDHUEV0elXBkUKT8tUgNottFU7i827sdqskHacmsi+VlBOTzQBk6pr1ykJSDKsTj8K5O4lvLhyzFie9bl3cxxu24bm7CqZmniTzwg257DjPpSAhsNLvbhwREQPVq1x4cuGG5pF/Cqltrdz/AHSVzjKmr41qeMkMTkclHGDihAEdtJayhRyR0Nb1vL9phDY+YcNVa0kivrdZFwWzz61biTyQ3bccjimBQvGKTxuOxp+pIVKEZOXHPpUOrMUVXx3wavahKn2ONsD7q0Aeg+CZhL4ZiXOSjstbcrMpyK4XwBq6zx3FiI9rJ84I712wbzB/tVSJYTRCVck4bFZsTNDKVY8Vo8ggNUU1qsrBgcUAP8jeA4rjNF8PQx/EjWZfKIjjgjkhB+6rPuDEe/yiuziulR/KUZFSiRFcsqqGPBIHJpDPP9D1WPwnealourBoCLl54Jivyyo53dfXnFRxq/i7XNUv7ONxaJYSWkUjDHmuykce2TXf3UFvfIFnhilx03oGx+dNt40iURIioo6KowBUso4LS/Fen2fg0WV0XjvLeFoTb7TuLYwMVm3Gj3D6H4Q0+482Em7dnKHDICCR9K9OksLUzCZrWFpeu8xgn86We0SUqzKCRyMjpUjOF13w/Ho+saJqsN1d3IW6WN0uH3qAe444rqvGulXOseENRs7Qbpmj3Iv94jnH41b4LBJFVlBz8wzWpFJtjLChAziV+IOmpoImUSG+EYUWmw7vM/u/nUF1LeXWveELm9hEc589pVQHCZUYrrn061ac3JtofOznf5Y3Z+tI8aySLlQSvQkdKSV2F9Dn/ECE+LPCzBSVV5yxHbhK09WhhvNEvbSaISJJEwx744xV6aJSFYoCy9DjkVCSTjArqS0MTnPBcdhongfT7i53rJdbGmkblmkcgc/ia6jUbbOm3bI3/LCTj/gJqK50+C8tUt5ExEHV9q8cggj+VWGGUIxkYxg0WFc82i0u9t/COma1ZRkXtpG4aPH+tjLHKn+ddV8O7OPUfAoW6hzHcNMWjcdi7GtlGLssYUBRxgDArcgiW2tMRqqrjoBgVLQ0zz/4b6WlhoM8hV/Oe6ljLSctsRyqj6YArs6QKq52IqgnOFGKWmlYTdznfHCF/Cd2Au47kwAP9oVn+JfEDaFoumrCkf2mdFVJJVJWIYGWOK7B0V1KsoYHsRkVXltoZwBLDHIB0DqDinYLnB6ddaZaWl/qVrdSatqpj3zFxtLAD7qjHArJ1a50+/1nSNT0aeaXUXuFPktkoqn72R2wM16VLZwQpmGCOM46ogFZ/wBkt4zujhiRz1ZUANTbUpPQ4XXdM1610ya5eO1mknu4maUZ3cN8ox2Ga1r9tFl1q3XxHblLsWoxIGPlnk5A9x/WuoZgihWAZeuGGaoReXeX5WeOORR0DqDj86pWIdyv4IlzpeoKDK2n/a3+xebyRH9fTOcV0giBtmINOaFFtlVFCgcAAYAqeCHFsQe4qtkTuyvE4SLpzVUyDzSKmzjKmsiaci6YA1V7E2bLXmYlO2p/M4wo5NNtIkkXnGTVvyooRnOSKylUNo09CBYiFLvUbZYZPAp7ymVvaoZnwMA0R7sb7IqElJCQaf5rVJBEJG5q6LJDg0riM/zGHek86T1rTNlGp5o+yJ3GKV/MdjM81z3ppketX7BHjrSfYF7c0XAyhI9L5j4rUNkoHK4o+wptzii/mIyS7EcmprclvlY1ZltgFOF5qmuY354pp2DcvRPsbY3K0+e3Ma+ZHyKgBDrnvViK4JTym6+tKSs7opO+jM5t0rfMcCtbSCEL7elUZbcqcg8Gte1jSG3VgMHHNYzbNdErIvKQGz6024KiNsrWfbX3m3LJ78VeuW2wEnrSjclmLdEwwhh3NJFqcvl4UA+9V9UlcoIxxijSTiQhueK0exK3Fmvp5MqagWTcdrdalZt9y5xjmnG1KkP680kOwkIkzkdqmMsyKSTxU1oQe1Jf8Q4Hc1sloZvcZZ3fmuVJ5rS75rn7VTFNu9a3kOQD7UxHF3Rz421P/rnH/wCgiti3rHuhjxtqf/XOP/0EVsW9ZlmvadRW5bdBWHadRW5bdBQBfWpKjWpKAA9KhfoamPSoX6GgDLuuprjpGC+NmBzzZD/0Jq7G66muHvHKeNgVGT9jH/oTU1uJ7G3krUU0fPmL2qwoZowzLg03HUGtdjMhQeepHcU1MxzY7U7Bhk3Doan2CZMjg0MaLKLyHHNeZeKrZIfE0kanBfDD8a9LtiEQqzc15542UJ4rsZB/EBuz7CsZGiMaaUG6igHRO9XVUMm3IPtWQJC2rtkdBzWhtUnpzUoZHfK8No/l4Ddua5ywtEuLyNblyIicuxPWuilszO3B2r3JNSw6ZAIwjbTjvSGcrrlvBBJNHBGUk3/u2/h2/wCNWdEitZW/0qMpEIsM57t6iujbR7ZuTMcemKY1jAi7Y1496LAczIgklkQMW2nCOR1FdBpb7VjUDngYrOubdlm4Hyir9l8ki8HrQB0fmfKQ3pWddOJI2x6VIrFgR396o5YOQTweKYHO31qik4BLk5JHapzNI2kxQxqBIgIII6g1dns2aUnHXpVy2tViAJUH2pAcrZafeRoIdpW3MgZsmt3VrdtRliZI9vlLjd0zW9HBaSjLwqKWQ2yjYoxj1osBh6YgtSVcMGPtWs0qkAfN/wB8moJBuYfdYfrT1yOM/nTAoasd1uR6Ukju9mqt6YBq1dQCZCDVGT91A6nk54pAdb8L1jN/fLxkIv8AOvRJYxHJuHSvPPhZbSGTULv+FsJXoswDDbnmqRLICRICR1qNGPIJxS7TC/8Asmh0B+btTAhkiEKl16mi1KyZBb5qeGVxsJqE25hy4YAUhlryysmTSuv8Q6ikgkEycAnHXNPyB8vNSUgVt4qRjkACoGUocr0qVGDLwOakZBNDu5XrVlV2woGPFLENz4NLIpk+QdqLCIZZCWCr0psajn+9UwQKtQofnYgU4bhLYlGPypjKoyaj3s8uxOtTNblP9Y6j8a6TEjZgpGTUbzAHABqfyoNu8tmleWBYjhDntQIZabZJRxzWvcNshCVn6ageQNjFWr44ape5S2KlA6UmehFKTTEIajp5YUw0CGPyprMcYJBrUNZ+okKme9DQ0Zd5MB0NV7BgLncTwahuH3HbTrGJpLgIvWs5OzSRvCPuts6OW5URAI2amiv08vDelVzZSRxgkCq5jBzzgitebujm5fMld9zM3asGRsXpOeCa2Qi9Gfj2rK1NFinVk6VMpq6Lpweo5ZpEuwFY4rULlh8xrBjYvcKw4rQd3BzQ3G9x2aSRbeZVGBUKAyv7UscRkAJq/bW+0g8YpO7EhIIduCatgHdimuApz2qReCAOpqWxokAA4PX1puz5ueaXHHsKZ5h/h/WobKsOzz93ikBAfoabkMfv8ilDZztIpc6HYbczJbwtNK21F61zNzrV1cMVhJij7Adas+IblpJY7ccKoy31rMiiq0IcJrlus8v/AH0aePNPWRz9TU8cNWFg9qYimBKOkj/99UuJv+ej5/3jTrvUNOsDi6vIYj6M3NZh8YeHhn/TgcHHCGi4GkTOessn/fRp3mXO3b58uPTear2uv6Levsg1CEt6HI/nWqsKsoZSCp6Ec0tBmePOVtyyOD6hjT/tF4Dk3Mp9mcmr32f2pjW9MRVM7zN+8+961Ygfy5lYHtUbw45oIwqkDmiye4NtbD2fbPuPc1fkmUoAp6is6UF9uBSxErcqGPFJqzsVGWhr267Ux61XvTmQLVxOgxWdOx8856CtTIj2jGfQ1q27b4VasuMgq3Wr9g2UC9geaEwOVuv+R21P/rnH/wCgiti3rHuznxtqZ/6Zx/8AoIrYt6zLNe06ity26CsO06ity26CgC+tSVGtSUAB6VC/Q1MelQv0NAGXddTXIEL/AMJwzMM7bIYH/Amrr7rqa5Bv+R2f/ryH/oTU1uJ7Fr7c7XLK4wO1WCQ2CpqC4tfMbcOPWktpkSTyya3tdaGd7FwKHG1utOjiMbcnihNu8k1ZzHImO4qGNELoA+49K4b4h2x8+wu4xnDbTXcZO4Kemaw/HMCf8IxNKB88bKwPpyKyZaOBhWORmnAwxGD9anhXgnPNUdGYyWI3c/MauP8AIakocWJyE7d6b5jheBzT1YDHHBqzHCMZ20DKoYkc8VIrAKeCastbjHTpUUk8VuhY4+hoAo3Ks3zbKSFlWSPHGOtNN8GbDDgniljQtODigC87lRvxUAIcn164qzKo2leao4KvuHIFAhzPvwNhypqeIk9BiiS9iEYVdu7FU7XVFFwUkGOaBmkwLKQOPpVfypCRg8+9asKpKgdMHNLJAccjGO9AjMEHzfMMH2pWTaeOcVPIcZFQF8HmgBkjBUyazLyVVwT0bIq/dOPKINY12jyFXB+VOSKGM9R+GaBfC0kgHzNcsPwAGP5muqlOG5rl/h2+zwqmO8rH9BXTsN/NNEjW/ejBqENjKVMSFHFQOpPzDrTAj8pk57mpPKaUKrdKsWsqyfK3UVK5C9KQys80VliNR1p7EMAy45qteJ567h94U203ofnOBSY0WucYNIMocjpUpj3LlTQsZYbTUjHxkHkd6kUBQSahjVonx2pshZnIHQ0noAjybsgU1AYz7GmsBEPU1Irhkw3Wqp7kz2I2jw29BzUErO5zJmrnI+6eKawV+GFdBkU8sqgdqkeRcBSKdJEQODxUTbG2gdRTGa+mKBzSXMm+ZlqawTEWe2Kqzr+8LD1qOo+gzG3ik6UoIYc9aCcDmmSRkUlPI4+tMORTAaaydU+Yhc1r9qyNQwZh60pbFR3MeaHEgxWpoVsBcl2FV9m5ua1dLXZkisYL3joqy/dmncvgYwMVQliQ5OOoqzcHNQeo9q6UcTKU6IiAjNZ+qw/uo3HetW5XKVFfRB9OT1ArCvsb4d6mHaRZcMa1pIhtBrPh+QLg961GPyge1OirxLxD94igk2tt7VqREFKx04l/GtSFTsJoZkSkcjNOU5XI60ctkH0py4BA9qhloeDxtJqBgWfGMCnk4BxSLyK5asmjSKARgHOKayEdKkz2pG4GaxUmaWRy2ov52pyn0OPyp0MdQ58y4kc/xOT+tX4E6V6MdjnYskkNnbPcTuEiQZZj2ry3xF8Q7+6uXh0v9xarwrjln9/atj4kamW8jS43IQfvJQD970B/WuLtdPknjBVACTxxSYIzvs95fTGa5mZnc5O85qWSwKg4529wa6q28Os6gu7Z9qux+FlyCWb86Vh3ODjhmQcEKfUnFdFofizVNFkULcieEdYnyQfxrcn8Ow7clckd6y7nQEKkquD7UWC56f4b8Tad4li2wt5V0o+eBjyPp6it17U+lfP1ncXfhvVor6MkNC4P1Hoa+jrC6t9V0y3vrY7op4w6+2R0qkxNGRLDjtTI7ZpeAOF61q3MAANQWvy+cvqM0pbAjMZcB8dqqxqTKGNaGCY5apJkoW9KqXRjp63NmInaMdKrzwnzNwGfaprc7oxU7D2rRq6M9mZ3lsRgJirttEYl571KBx1p/TG7pSUUgbucTdHPjbUz/wBM4/8A0EVsW9Y91g+NtTwMDy4//QRWxb1BRr2nUVuW3QVh2nUVuW3QUAX1qSo1qSgAPSoX6Gpj0qF+hoAy7rqa498/8Jq+P+fIf+hNXYXXU1xV1L5XjU+9mP8A0Jqa3E9jaByMGoxpwZzNkKq808NuTKjNSZyhBzitb2IY2CVJX2A9KsfZ2Dbh0rNAEchYcYq3Hd7xhXyfShoEyy8e6PcOorF8T4l8LX6N2jz+RFbILmPnpWTroU6NeB+EMRyaxZaPNNOAgg2YHrVotv59KorJxhewqzE+5B+RqSyVPmYCt0IkEIYgFiOlYcb7J/WrN1efKMUALeXgjjZi2K4+91GW7uxEhO3PNW9SunmIiQnLGmW1nHBFvPLk8mkBopZbWjfGRgVo26eZIABkmsFtQuYWAQhl9DV7TdaWOYORtYetAG48O7IPas6WEo+O2fzpJNVAlOWGGqjc6sy/6ldzep6UwLbafvbfjtWTqdq4XzYgd6/qKdBd38jFpJ8J/dAq8JPMXBBPFICvoWvNEwViSOhFdi12l1CGXowrzu9sjbTC5hHy5ywHat/TL0+UATn2oQGncMFkIqrMdpDUSTFjuwcHtUUz7l4pgVbqUFtvpVF5cwOg70+5c+YSKrxPvjbAyScUgPWfBiG38K22OrsWro0kXbhu9UPD9o9v4aslZMMI8kVLOGADCrJLDJ3HelwAvNQC5JQAVIWBTOelAEDqUfcKsRuJF5601iCmTwPWqMGradPcNDa3kMsqfeRWyRSGaQG04qC5haVhsz+FThgwBHpSxMc89aQx1uTCgWTrUxkVTnFc+2vadN4jfRxOwvo03lCpwR7Gn33iPTtO1Cz0+6mIubskRKFJ6evpU3GdAzhos4qPG2ME0kWSCDVW5uURo43dVLttQE9T6UmCDcGlyelTskbLkHmqryReY0AYeYoBZe4BqXMSSJEZAJHBKqepx1/mKukTMgmDxj5WP50+1kMiHIORVe8lSE75H2oO5pyOIRgsAzHAB7mugyCSYM5UGnCIBlIOc1TmkSCKSeU7URSzH0A5NZmmeLtM1O6ggtvtRaQnazW7hT/wIjFGgHeWuVszVJpPmK0umanBem8tYt2+1ZVkJHGSMjFMuHhto5J55FjiQbmZjgAVC3KYrKDznmm4J61haV4t0fWL4WttNKsrgtF5sTIJR6qSOadq/i7TNGuhazvLJPt3tHBE0hRfU4HAp3FY2yACKa471ly69ZLpC6qkvm2jEAMg9TjpVjTNVt9Vsxcwbtm5k+YY5BwaALX8JNYt0d93V/UNUsNNRWvLlIA/C7j1rLt7621B2mtZBJHkjcKmb0Lpq8hCNrHmtLTM7WrLcENWppp+QilBalVX7pckORzULcKTVHxBrtnoFolxeeZtkcIojUsxPoBWbp/jDS9RvEsf9It7qQfIlxC0e/6E1qmjmaNmc/u81IVWTT8cHisu61S3e7l05HP2mOMSMuP4c461m3msLplp51xIVjLBOOeT0rKsro2oJk4AWQL71pSDaAfasC61KCwha7umKxR8sQM1tNcJNFG6HKsoKn2NFJ8qLrK7IhzJWxbk+XzWbBHlq0VGxQPWgzJQw3/WnD5jkdqi4yPapEz+BqGikOHUj1qIuq556UPOiZyw3DpVOWcSyBcADvWUqXMWp2JXuNzfuwTTLi8KWz5XB2mrcCxRjAIJNU9ZkRLFlG3LEAetNUYoOdmDAvStSHCKWbgAZNZ8A6VZvmMekXbr1ELY/KtiDyi/L614juZyMoZMD6Ct60tEjcKABiqum6ebdlJ5ZznNbKtHG2WxnNSMvxQqigY5qdVFVUd5FypqRGk3bSOaoCUopzkDFZ91bnqq8VbZJeWzxVK4voYTsmlVM9MmkBjalZrInzrkFcHiuv8AhDPKltqOkySF1t33RjPQH0/OsSTa8e8YYDn61qeA4xaeM5NhxHPERj14zQB6Pcx9eKyj8kpPqDW3crwaxLoYNMRAoBikA71QjXCtV6Jk8lvmGapR/MzjNOppFDo/EzQs2BjqznJwORVKxPDDtV5QimqWxD3HbSB04pwwegyaa7ArgCmq7L0FMRxl1n/hNtTz18uP/wBBFbFvWPcknxrqZPXy4/8A0EVsW9ZlmvadRW5bdBWHadRW5bdBQBfWpKjWpKAA9KhfoamPSoX6GgDLuuprh70A+NDk4/0MYH4tXcXXU1w1+D/wmeR2sx/6E1OO4nsatvMUIU9KskMee1URyAF61ahlyuxzWzMkSeWJV245qoo+yTgFSc1fhmWNskUs7xzOCF6VN7FWuSyyE2w2jGRmsm/tZtQ0i7t0GXaM498c1cS53F1bgDpWlp0WBv8AWs2WjwuXzILkxtGy7eDkVZiYiOvYtY0S2vtPu4hbxCWROGCjORzXjYV4WkibhkYqRUFkquWcHHNN1GQxx5PHFMiJD5pL6NnZNw7g0gKUcRBDSfeYZ+lSMTj5Tn2qjf3rRPgg/hVWLVY2JBl2n3oA0hGW57GmyQgqD0PTFNS6jwP3lPMtu5XEnOaAIzA7YwSQKmjTLAY4HU1MJIlGfMA9qi+2W6ZBYH6UASMCGwDgCpEkKcZ69aqC8iyfm61Wmvool3PIKANdHEsbK4DAjGKrWkptLswnoeVP9KzbTUFeXhuK0pojL5Lp130Aa7SHbnrxVR5GJyelTSMViVSMYFUpHJXigCNk825SMdXYL+Zr0zR/hvZWd4lxNcPLGp3CIrjn3NcBoFt9t8S6fBjIMyk/QHNe8qnygelNCIJD5SBQMKBgCqjYbO4cVdukJj4qkDng1QilJGVJK0qS4UirpVQvNUpISGJHSgAu5UGmXHmEqnltuIGSBjrXAQXMmkGzDW9peKY5Da3Nu22Qd8OvOfzrvc8FSMgjBB71Fp+haZbztPDZxLIwIJ68HrgHpUspHCWmt6tDYzzvdvuNutwu8g/PzwAOx6V23hW7mv8ARIry4l3zzku6Yx5Rz9z8On4VLD4c0qJn8uxiUlt3c9On/wCqrVnbw2bSrHGqeY5dgOhJ6mkNHnGrRtb+NtR1qP8A5cbiDzP+ub7lb+YNV9Rb+1PE9vraHdbLfR21ufYKzMf1H5V6M/h+wkfUnkV2/tFAkwJ4wM4x6dagj8JaXHpVjp8SyLDZzedH83JbBHPr1qWhnQxEPFuBrlfGAug+jGzKC4+2DaX6fjXTw7IYvLzzVe5iinMYkjDNG25Cex9aGB59qV7rVnf6mZ5I/tEvkRq8IxtUsOme+OPxp0Or6rCEDv5jxRzhHbBOPk647jJrt7nS7SaKXz4Ek84BX3dwDkVEuk2iWZt7aBITsZVcDJXdjPXr0HX0q6ZEzhrq4na3ns11RrvzLaGXecZR2Zs9PoKvSi4h8RWtldX8siWt6pVzgFtyK2D+JNa2ieDo9NkuJrqSOZpQqhVTaABk5+vNbb6dZPMZZYFeQuH3HruGMH9BWtiLlTxGyz+HdQgURxNNA8YkkOFXcMZP51x8T6t4autHhnvre9tbmUW5jWLYUJUkEHJyOP1rvdRs7e/sZrS5iEkEyFXXPUGsGy8D2Vle297JNdXLQZ8lZ5dyx57geuPWnYVzpo7ePSdPv7+3tnmnlw7xoeXI4GK4vxPqt5qvgS+nl0+exIcK8chBO3ueK9KtAGgI9qzr62gubaW1uIxJFICrqe4qRnFeJIreKbwu1ntEwu4hDtHWPjP6ZqO6iv8ASfFmrXdrZR6jHdxruxKFaE+hBHStfS/B2n6ZexXUct1cPApW3FxKXEQ6fKPpT9U8JWeo3r3jXF1BLKmyX7PLtEi+hosFzG8DaeL/AMEGC+TKtdyNtU8AAgjB+ua6qx0+DT7f7PbJtj3Fse5OTU1pZ2+n2UVraxBIYxhVqUcc5qkhM4nxuJE1PRvLa2VvMbm4+5071jz6le6bIFD27fa0MUP2f7okJAB/LNd7q2l2Wpwj7bbpMI+V3djXOxaBB9ss2iCR2tq5kEQXOXwQDn8azqGtLVnMXGs6omsv+8YJBMsOxiNrDuT3z/hW54S1W6l8QPb3Vw580OyIAGRgpHQ5yMZ9KvXuk2Ul79ra3jacfxEf06VPoFhY22oPPHAiysCCw9/T0pQepVRe6U/iKk7w6Mtrs88367N/3c8dax9ZXVbbxLod3rK2rW63Con2bIYO3AJz1HNdr4g0K2122ihuJJY/KkEiPE21lYe9ZUPhCzS9gvLi5vLySBt0YuJcqrdjgAc1tY5rlKBBJ8RL5CetiP8A0IVn+P7YxeHCwPC3MRP5mtzVfClpqWp/2gbm7t7jZsLQS7cj8qj/AOEetl0m4064lnu4JuSZ33MPoafLdWYuezujmPFcn/FL3GWHzKoX3NdfYgixtgwwREgx6cCuWt/BsCXMX2m8u7q3ibMcMr5UY6Z45rsVxwKxidFR3sWYXC9BmrSyg8OpFS2UEEcBlfk1FPeRyHYqAYqna5lYVpUTleageaQDB4Bpg4BbvnpSSEyD5uKVhibExuZySe1RyqFI2mgBScA8invamUblcZFNaCdyOKR8nmoNSkLLGp6k5qTy2jchjVK6/wBeB2AoYRJbcdKn1EY0a8OM/uWqO3HSr00fmWFwmM5iYfpUlnnlvKzujEcKlZN1bXd5O1wtwsSg/LuOK0rZmWQrjhVwPzNRzae11dLIzKEUYCk8VIzPstX1W0m2NNBKg612Njd/aLYSkAt3xXJjQ/ssE21xIWOc46Vs6U7QWZT24poCprutXkamG2dYs9yMmuftoI7wl7y/JfP93p+tbt7aG6uo5RgEU6HQbWGOQtKT5nJBH8qQFixieG2MRYOmMq3rWn4UuhbeItMldwA7eWc+/FUIE8qERKflXgUzRoZD4j0yIDLfalIz/vZpge3XIyDWJeLwa3px8tY12vBpiOVaVoncbu5p1rP948Gp7+0QkMOC3Wq6QCEbQM5qLt6G8UtzS08llY1o7CTnNU7GAxrk1dQbSc1tHY5pO7EHXFTKg7tUeMN0qTcvGVqhHEXYx421MZ/5Zx/+gite3rHuuPG2p/8AXOP/ANBFbFvWRZr2nUVuW3QVh2nUVuW3QUAX1qSo1qSgAPSoX6Gpj0qF+hoAy7rqa4i8P/FZketmP/Qmrt7rqa4yZA/jViRyLIY/76anHcT2LC5Rx6VJ8x+YU548c0sTAfKelb7mRZgjEw5PNWxbhazhmNwVPFXonzHkmokikyK5iRUwPvE1d09v3flrnIqpCBNdAE8A1rwwpFkjHNZstCkZPX615D4vsRp/iWcIMRzqJF/rXr+0AkZ61xHxE0ozadFfxDL2xO7H901LKPOEYrIDnitN/Lmhz7cVis4POeKswSllC54HapGURZ+fO5Izk1malpCFiAMH2roohiQsDznNF7D5hDd6LAc/osr2s6xXsIltx/ERk10sX9gzWweaBY3Z9u3HbPX8qzFiw1WQq4ztFCA1joWgtNGROoQtggSU+503w/p6ByEk5xgNk1hMmXyOlPwrDHH4mgBbu9soXuFgtEKFB5bAd65X7JPf3O6bhB0UcV0cqpnHAqJUGcKPxoYEcOmIIuFAIFaNgAhALcKOCfWnsfLh/CoI/lU/nQBPPNlhzmqrsSCScUjuKr3EmE60Adz8M9NNzq8+oOPkgXap/wBo16wgO0jNcv4C09bPwpZsBgzL5re+ea6oqODniqQiIqQcE1WuIsDcnWrUqZIYGowMAnrTEZuXdvcVLtDdRSXETqxdelNSXK4NAEbx7TkVEsjRt1qxcl1s55F6pEzD6gE1xsd3rFgthe39zHc2t2drKFw0ZOSMevSlcZ2sMm5c55psiktmuHN7rUllPrVvdrHDGzmO1K8Mikjk+pxTNY8WXMdzcz2upxW0cVrHPHBJGT5hKhsZx74qGUj0GAhxhutRveWcd2ts91Ckx6RlwGP4VRW8c6OL/AVvIMhAPQ4zXjlr4ei1nwVrfimeWRtQiuC8b7uQFI4/UUrjPefJUuWY8AVXtbuzvZZBb3MUzxnDBHBIrhNS1K81T4LC8im2zPbYkctgkAkHn8K4bwzNpI8W+G/+EfaeGbYovfNO0Of4gM9aTA9zu7iKGJ5ZZAkaDLMegFOku4La0895EWLGS7HAxXNeKd1zDZaYh+e+uUUj/YU72/Rah8YeGP7djsRcXflaXZ5kuIxnL4HHSrpsiaOosbq2vUNwkySxZwCjZFS3VxZrD5jukSjjcxwK8m+GawSeK9bTRmf+yQE2o7YO7nnFM+Lmm63FbG9e9H9meYoSBeCDx1/GtebS5FtbHrm0QQmaZuAM57YqvFqEV5Ck8MivE3KkdDWT4taaDwtIiyfvrlVtogDyWfC/1pupaJex+F0stKvEtrlFUBz2HequKx1umXUVxHKsUiuYztYKc7T6Gs+e+tFv/skl1EtwekZcbj+FeffB03NvZ+LUlkMlxFKMtnOW2vzXApa6Pe+EdV1nUL4r4gW6chGfDA54GKz5irH0HNcR265kkSNR1ZzgVANSsWYKt7buzHACygk1zVlp8Hjf4f6Wupl2E0KO7A8lgBz+dcJpng3TLv4jLZ6SJPsWmHzLmYnO5x0UfjVXFY9juLqG1hM1zMkUXTc7ACkinjnhWWF1kjb7rqcg/jXlvxNa0j8V6KNZMj6R5b7oozk7uOcVa+EjK0WtfZJG/s77V/o8bt8yjHp27U1LWwW0ueiXR/dHPHFZ8OCmARmtSUCSMhvSsMxlJDtPGaiqtDWg9bEN4xV8etGlnbcZqO4JaQK3WpLFNtyRUQ1sa1NEzdZsrmmKwIpWGI8UyNcV1nnjmUHmq9xHtUnHFXNu4YFRXgAgxRcVjDkO1x9ascbc96qynLj61Z6RisTplsi3G7smCSBQ6YXK0kUMjoCKm8mVV9aT3J6FfzCBzUE8hd1GcUk+4SHJCmo8OylsAkVSRJLIoixhuTUkBkjbcORWZ+8fDEHINattE3lhycCnIFuMuZMsDjk1myHdcsfwrfa0Vl3k9BmsBfmmZh0LGoLSL1uOla1sgb5T0IxWZbjpWxaLyKQzy+RDDdXUW3BSYgD2qe2tvPDMRwOpo15J7fxDc+bE0as+VJHB+lVGvXhs32dzSGOu7uCCQW6jzJW52jsKkgibyXODz0FYSgxu0u79+x5bPSrUep3kUflEBuc5oAuSSmKMkRMzjnNaOnSWup2pkjZdy8MpPINYC3NwXLSSHaf4e1JC4tLz7VCcK5w4Hr60AbkxEZxgYFO8J5n8bacc5USE4+grPubjIOe/NdX8O/DN99vh1qcKtttJi55bPFAHp0wytZF2vBrakHy1k3S9aYjnrsfMoxUSALMuRVi7XDA+lVA5+0KPeoXxGy/hmup454p6nNMUbl3Gn7u2K6DlHn3NKM556VGKkByMUDOJusHxtqeOnlx/+giti3rHuf8AkdtT/wCucf8A6CK2LesizXtOorctugrDtOorctugoAvrUlRrUlAAelQv0NTHpUL9DQBl3XU1xVwSPG/HX7GP/Qmrtbrqa5HaD43ckdLIf+hNTW4nsaHDr05qB0IPFTsDE/t2pHORkDmtrmdhkZyMdxU6nYeehqpko2TU+4y4AFTIaLtrH+839q0lI9aqWgCoEY4q6saL3rJloBgEkmqmoW6XdnNE4ykikEVd+UgrSBV24pFHzxdRG1vJ7Y/8s5GUfgajjkKPkVqeLoPs3im/jHQSbh+IB/rWP1wRUjLqSbj6DPNWS2Vx2rPiJP0q0pLDFAD/ACN+eaaYyoI3DIqVAwOc01k3tz3oAqycJjcKXC7BinNbgmn/AGcKgI5oAiWIs3PSpBGqU7oPSm5yOetAAW3cVExwCBTjxz61DIwVfc0ARu2ciqczb2xnirDkKpPc1BGnmzpGOWYgUAfQnh1BH4c06MHpbpj/AL5FavGNuar2MKW+nWsQ/giRfyAFWhtDAmqQiOTK8Co8nG3vTp5MMNtV2uQsoDDrTEO3Ago1UpU2PntVx153DoaYQJFIagCCXMtlNEnV42QZ9wRXNWPh/V5pLKLVri2NnZksqQglpD2znpgV0R3Qtg/dqzF8wzSGcdc+GdWSO4022vYF0uZ2bLKfMQMclR26k1FeeH777fciyWyFtPAsB84EsgChcjiu3IyaqywkZNS0O5Fbackeirp5fcBCYtx78YzXjnnaromg6t4ROl3Tz3NwfKkRcoVY9c/gK9pibBwanaNXIJUE+uOaloo8+8Q+G78fCa10qzQvcW6K0kanluSSP1rmYFk8Ta54ag0zQp7FtPEf2mWRNo+XGee/SvZ4j5cgB6VY2IJSUVRn0FFriOVMT3njYyFGEFhbkISOC7ccfgTVDxdrOs6DcWN3a2bXemMzJdxouW9v61103Mnygc9eKVB5nyuAQOxpw3FLY8t8ERXF1481HX7XT5bDTnjEaxyDaXb1xW78WILq/wDBojhiaVzMp2oMnrXZSiNWCqoH0FNm5whGRW/LoZ31OcvzJqPiLR7Rgxgt83UhxxlR8o/PFdBMvmKdpNWLeK3Vcso3U5pogNqx496oRxHwrtrqyvvE5mgZDNdKY94wGwG/xFcV4jihu7zUrRvCE8OtyzFEkj5iIP8AHn1r2u0YJc5AAFad2iugcIu7H3sc1m4lJnJ6TZTeHfBUNrt3z2ln91ecuFzgfjWH8LtPmtvD093dxOl3eTs77xg47V3RGRg0AADgAD2qrE3PK/G0FxpfxA0/XbnTpr/TRCY9ka7tjfT8asfDSxum1TW9YNk9nZXcgEELjB46nH416WyhhhgCPcZqPAAwAAPQUKOtx30Gv9xqxXbazVtN9wj1rDmUrO2elTV2NKHxGbcsVuAavWPM4NQXMIYqaktz5UqkVnTZtWRvgAqM0hABoVt0YpM11nnipIA9RX3MWaXaRLmi4XdEaAOckP7z8aurygqrcLtk/GrQOEFYLc6Z7ImFy8YABwKd9ukHVuKiMLsu7FQlc/KeK2tFmF2M+W6uD5kmBUskESDCXH4VX+zAOSDStbgDljSktdBpi+UdpxKMUiXrx/us5FMWHIxupDDj7nJpqPcG+xdfUGELL6iqFuOlNkDBfmFS246VnNJPQuF7GlbjpWzaL0rJtx0ratF6VBRm+M9LF74ceVUzLbkSAgc46H+deUqySQOhOGHIr3wwrNbvEwyrqVI/Cvn7UkNjrN3bgYEcpUA+lJjRl3Fld28sc0Uu9W5ZTWxDFauAXnmjz2KA/wBaFcSIARxTJEP8IpDK+oqqRstpJLI/QM+AKjsbaSFFM8u/f1FWvLH8f5U2RwF+nSgBZnaeZY4xlnYKor6D0aw/s3RrSzPWGJVP1Ar5/wDD0ZuvFWnQ4yDOpI/GvpCmhMhccVm3S1qP0rPul4piOevF61nZAnU+9a14vWsUn96v1qH8RrHWDRtr/qqdjpTY/uU6ug5x2MCnjrTB0p69aQHE3Rz421P/AK5x/wDoIrYt6x7sY8banj/nnH/6CK2LesyzXtOorctugrDtOorctugoAvrUlRrUlAAelQv0NTHpUL9DQBl3XU1yPJ8bOB/z5D/0Jq6666muRDovjllY4LWQx/301C3E9jZeLemDVUHy22mrbgjnNNnhRot4+9WyIKrIG5Ip0LbGGBTIyxODVtdqpyvJpPUC7GFYq7DirnGM1nWtxg7GHy+9asZVkz2rNlohHByR1qThR0p4wwPHSoLm8t7SHfPIqegJ5NSUeQfEu3WHxKZ0HEqLu+uMVyCPzgjivQvGFudT0+W4VSzoxccc4rznOV3CkxltG2nHap4s5NUYpAw2t1qdZSoxnikBeRx0JOKVpQpxjPaqiyKAT1NJ5460AWjMNuD/ACpGkKpg4qssgNOaRPWgB7MCoGc5pvOziofOz92pEk4+bpQAoICfN0qux3HJp0koOc8CoHfd06UARytwa3vB+kG9vftsq/uYTx7tWbpWkz61qCwRKQg5duwFepW1nDp9nHawLhEGPqfWmkI6nS7o3Vmi9Wj+U1oAbjjHFcObu5ssyW0hQjk471etPF0iEC6iDD+8tMDqHC55FULqIN869RRb6vZX4AimUN/dY4NTiPcaYiKzkeaMqy9O9OZcdKZPI8SlYQefQU2J8KFkf5j2oAdOieUXY4CjJPoKzbDXtLup/s1vfQSynoquCavXin7Dd5PHkSf+gmuE0mO8t/Dn2k3OmQIsTFHiZfMBz3qblHoK85qOSaISiEsPMYZC55Irzu11+91HQ7ae61P7JJPeiKQZ2eUvAx7Z6/jSpq17G93FFeNMtvFcLBcMclgu7ac98YFK4HesuGzU8Mm4YNeea3canazW1oL6U7LU3HmGYJufI65IyBnpSNqt7Fr9vJNdvszGm2GQEAkHIZM859cVIz0SfZHE0jHCoNxPoK85/wCFssJmuRo8p0ZZvJ+2c+uM12uvs58OagI/v+Q2PyrzBBD/AMM7SE48wtz9fM/woGeh6/4itvDugSaxKDMp2iJV/jLHA/nWJ4e8fXGo69FpepaU9hPcR+ZBnOHH41leNZRH8I9KhuIi9zceSkRzja/Bz+QNY2lLqukfEPQ38QOLl5YCluynOziknaQPY9N8S6k+l2MUkKK88sqxxqe5NY/iTxdJoVxa2VvZte6lcj5Il6fWrWqg6j4z0+zHMdlE1zJ/vMcL/wCgmrN+1q12YLaS1TXTCfs/mY3D0/CuoxM/wl4qHiY3Mcls9reWrbZoW7VB4h+IOnaNqFtp8BW6u5Z1ikQf8swTjJ/SsT4ZLcweKdfsNRUvqoYvLIDkNzU3xR0e0s20S+jt4o7mXUolZ1ABbqefyqeZ2HbU7jVtS/snSJb7ALooKg9yelQ+IfGi+GvC9ld3kBmvroBUgj7sQCf51neJS1/e6RpnXz5fMkA/uIB/UitTX7nQdP0+PVddRCtm26DcMnd6KO5ol3EjH8MeOm1vVpdJ1DT30/UEXcI2z8wxnvUXiTx9LpOsnSdL0x9Qu44zLMBnCKPpWd4Ss9V8R+MpfGuoWjWdsyFLSJxhmQjAOPpTfCm3/ha/iX7T18k4z6bhn9M0ruw7K51fh/xVZ6/4fOqoDEseRMjdUI61xx+LB+0Gf+x5v7IEvlfauevr6VJ8K4lm0/xDFIM273ZHPQj5s1ma7OviORfBnhOyBsYZc3Vyq/u0OeQDTu7BbU9IvNZsLHS11K5uFjtGUMJD0IPSuT0DxbF4plvJIYPLhifahPVh2NdfFotodKttMuIkngiRY9rjIOBjNeZ+AIUgu9cjjUBI7oqoHYAmlUvYuk7SO1flDVYSlXUn1q6VyM9qrTxBkyKxgzpmrs3YJN8CMPSpSf5VS00k2oFWwRuxntXXF3R5slZ2HjGQajuDiM0vO7FJOpMZqhGDcg78+9TqCyCmSgljxxmp1HyDHpXOt2dMtkW47hFjCmq0qxSMSpxUWBmpIlRm5OKpMyZWG5GPBNIMyE8GtHKqCoUH3pgXYchav2jFylDy2XNQiRo2NahQk5KVBPbiQjA201UvuJxM6SQuFz61Ztx0qG5hMEiAkHI6ip7ftWcndmsdjUtx0rateMViwMFAJOBVhtQZV2wD5v7x7VIzoJ763sYPNnkVABxnvXh/jSFo9fkvVXEN186n36f0FdlqMU11cp5jM4JwSTV650i31Gz+yXMYZMcHuD6ikxnlENwNuakN4CcZxXRXvg2fT5ztHmQk8OP61Vfw3u5xikBim5DNjOahnmB4Fbw8OSKcKpZj0AFdDofgtIJBd3y7mHKRHt7miwGf4R0KWzUatcLtmbmFT/CPWvR7TxjAX8q7jMbDgsOlZ0kJPbis5rB2mll8tmUYGFHJNUI75L23mtzPHMjRAZLA9Ky11a0vZGjglDOBnB4yPauasoWliuLUkxTHgxnjitOOC5NxbS3EUcKWyEblPL9P8KAK51JLq5eEIVK55+hrPykkoMbhgGIyDnkGr0sEEUzPE/zzKSDj1JrlGur6LxEtnaWzR2EBzM8iYDknlgf14qZbo0g9GjuIuUp1MgIMeQcg0/rW5gOFPXrTRxSr1pAcVc/8jrqf/XOP/wBBFbFvWRd/8jvqf/XOP/0EVr29ZlmvadRW5bdBWHadRW5bdBQBfWpKjWpKAA9KhfoamPSoX6GgDLuuprh7sf8AFcBu4sx/Nq7i66muQIz44c7N2LEfzamtxPY1reQvGRJwT0qUAA8mq1taSvIZJG2IDVpmiYEJz71qyCKVRkMg6VLGyyKCw+anxmMcHnNRzJ5bBh0pDBl/eDHTNaMd1FBFulcKo9aw7jUIkU7Pmf0FZMkk1026Rzj07VLGjc1HxOkalLRCzd3bgCuMv9SlnuA0jmR2NSai5HyrwBUNvbiaaCT+6eaixVzoY0V4gjDIIwRXnHiXw9NpN088KlrOQ9v4PrXpCfKARSyRx3MLRSoHRhgg96GgueMeWc5BqzF8wwetdLrPhKW0laezBkg6lO61jC2OflHTqKmw7lYxMDxULow7VsR2pbqDmntp5btRYLmDukBwKP3hPOK2H0s54prWJH8FFguZiBs1Ng7cmryWDL8xHFI1uzHAHFFguZZUseas2Gl3GqXSW1uuSfvN2UVd0zQrrULrYo2x5+aQjgCvRNL0y10q2EVunP8AE56safKFyvpmnQ6LaiCFMk8u/djU8t1z0q5Iu5aybtHEnAxVJE3HNOGUhhwRWQsxDshHetVUyoz3rMC5vJlC52nGaTQxQzDlQQfatWx169tMAt5iDs1Vxbbow2OO9N8odqAOvsNdtLvCs3lSHs/+NLd4ikD/AHiehFceID1FddpUQl0qISEk88mgC0rCeDaxHzDBHtWdH4Y0mNs/YYgc56VaYC0lBL7j2FWlkMibiMUhmNq3hiyvmjfyUAEokkGPv4wP5Crkel2BgWIWsYRUKAY7HqKvmZFGGIA9WOKhkIgbJICnuaQyK402yvPK8+2SUxfc3DpUU2k2TXS3X2aMzqMB8cirvmpGu5mAXuScCkjube4yIZo3x12sDipYyHYrq8cgyrDBHqK4BPhP5t0bYaxKNGM/nG02++cV38h2yhAwyR0zyanhnUSKhIDHoPWkMxPFXhm18RaN/ZchMIQhoXUfcI6Vzmi/D6XT9Yi1PVNTe/nt02QKRgKK9ClngFxteWNSOzMAapyzxyS/upFcA8lTmpaBFHTtJa11S/1CaQPJdFQMD7qqOB+ZNY/ivwX/AG/e2+oWd69lqFuMJKBkEe9dXHICcHrT2FdMbNGL0ZyXhTwg3hh7m6a8a6v7k5lmIxmrPiXw3/wkqWKzXRQWtytxwM7iM8frXQkUdB2qrIV2Zf8AZWfEA1JnBVLcQxp/d5JJ/Hj8qyfF/g5vGCWsLag1qkDFsBN2Se/WumMuDg9KbuYMG7dqGrqwXMDw94A1Dw/qUd7L4glvolUr5DptXkY9e1U/E3gKTVtZOq6bqTWF1IhimIGQ6nivRrWQS2+3viqkqFHIqUlsNvqc3ovhW30PwzJo9tM2ZVbzJyOSxHWuNtfhJeWLMbXxPNCrNuZVhxk/nXqLEDrUJmBbAHFPlQrsZZW72dnbwPKZWiQKZD1Ygda53R/CMeiyalJHOZTeSmXBXG3Jziuo3MRwtJtkJGEp6ArnPglcxsKhfhcGtu6sGlyyrg1mXVlMkZJjJrNQszd1LosWc8Eduq7vmzVpip+ZTXOYd/kSNg1aFtFfRYBRsGtYyWxzyi9zWRs9RRKyqpy2Kp3DXaJhYuTWVM14DmUECm5JCUGy2+0SEE8GmfaMDavOKz5Jii8vk0+DL1ns7o1vdJMvpmT60hVlbmo5pPs0PmbgAO5qD7VdXCyJDCQ8TKSW5Dqc5x6VW+pG2hYk1OGxgmuJTlIRlwvJH4VHJ4l88aZNZQRvZ3jqjSM2GTJx0x/Wozpga9luQflljCSRkZBxnn9aW3sILS3igiQbIjlAexzmpafUa8inp/iK+m8YX2mzBPs6KTEFHTH/ANauf13X/EFj4j1QWMKz2scQAVjgRnBO78ga7OKGJblpxGizMMM4HJqSSwt5EnEkSsJxiX1YVNguch/blwul6GLgeZeXznOB0A6/0rZOoeVP5McTyuv3gvapJ/D1tNqthehmVbJGSOIDjnHP6VhS22uaH4hvbiKwfUbG8IdfLfDRHABHPbihjR1kF5HJaec+6NR1DDkVoxRxsAd+AelcP4q1W7s4dNsLWBGvr5l/dueE+uKof8JZrv8AbunaLfabFA8km5nRyQVAzxSuM9P+xxyEHfyD6VZECj/lp+lee+K/GlzpktvpulwiXUJ8sQx4RAM5Na/hPxJJrfhuO+nAWZSySBTxlaa1A65o0ZNrEEehFU30mBjlXwPTFeb6d428V63PdHTLCxe3hnaPEjkMcH610eveKp9DvtJtmtS5vZlibLYK59KAsdVb6fb253A5f1Iqdo1Y8vWJcaubcgNE3PvXGeJ/H+qaJrlrb21ilzb3EZKrkhiR1waLjsejTNHHbSzI4kKA8D1rHV7qHTk1NbsMThnjI4x6Vwel+NNVsDbX2qad5Wl30zox5zGd2Oa75dHjO1lExhJ3CPd8ppCNcQQTSxXZ4cDI/GieXdOoYDaB8rbufyqlNPPCufIbaPes271RkjaRId0oHAJpgadzIoGcdOlc1rFs1+r28d8YJWQ5RTyc1ctZ77Urkw+QFRYVbfjqxzkfhUNl4du7iSG71SDbfQOVV42IDqD8pI+mKhptmsGkjf0x82kcbkFwACR3q5/FWfDa3EEwwhxV3zdpw6kH1rZbGMtyU9KcOtMR1PTmpMA0yTiLn/kddT/65x/+giti3rHuf+R11P8A65x/+giti3rMs17TqK3LboKw7TqK3LboKAL61JUa1JQAHpUL9DUx6VC/Q0AZd11NcmpA8bSZ/wCfIf8AoTV1l11NckCP+E5ZcdbIf+hNTW4nsbVzIZLJkXg47VlWsxtztkzya1WdV4Aqq1qjMZGwQBnFapkMke5iRA3JJ7CqE93JN8hOE9KghuQ85jI71Dr19Do2myXbjc/3Y0HV2PQCpeg0YmqeJrLStRWydJJHyokZOke48Zq7rOr2+jWqtNlpJDtjiT7zn2rkpbWK3vIY9UkA8n/iYak5P8Z+ZU/DgYpt4l7dxLeXEbLqeqkW9lCetvE33mx2O3Oam47HTwXEOp6fFeQqdkgzhuoqzpsY8xqraOHVp9Ois3S1slWNZmXHmPznHrWhBH5c2emaaQrl9ML1OAKZZXUF7CtxayCSJicMOhrB8R3kswh0WyYi6vPvsOscfdv510Gn28FpaxWsCBI4lCqAOwosO5ZKl1Kr1NYmo+HouZ48JMeoHQ1ugFGB6UkwLqXAyRTsK5yK2ODh02tVUXuntffYluUM+du3Pf0+tbOvXhs9CurlwBIq4j9dx6VzcWlFLrRtKgQF7XZd3cgHIb72CfUn+dS1ZlJ3NT7PhuRxStbA9BWu1uGHFRCIIrFuFUEsT0AosI5vVbqDTbdZJlZmY7UjXqxq7pNva6hpY1aZ/IsQpZ2bqMdf5VhXok1FZdY25Mr/AGPTYz3/AL8n64z7VpKLe4sF04vjw7oqf6TIfu3Uq8lR6jNIZ0Ph3V7DV/NisraSBIQCBIMblPQ/jWqJ188rjFYvg6xmi0yXU7pdl1qDecykfdU8qv4CugW1jLGViBgZqltqJ7iN6ioZIfOHvXM3fiqzn8Ux2jalHbWdkuZcPjzXPRfcAZ/OuvRkeNZE5RgGUjuDSGUfsZWMgmq9pZgCWRuS7ZzWpcDcuFzk8Vmajey6dHbRW9q9xPcTLGqgcKOrEntgA0gLEcIUFT0NMNoOq1deLuF7c1EV2c54pDIFiUDbjmt/TVEdkmfevO73xJaf8JMIP7QjhtbIZmw/+sc/w++K9F09lmsYypyCMilcBbuBWtrifJDJE7A+hAJrh/CV8t3fQu+tahcSkEvDIFEfX6V304DW8sGceYjJn0yMVy9lomraYYle/ilt48gIIwGIz64pMZB8SopJvDsEUMzwtLcom9DgjJrK1XWrmbwFeadfSFdXsJ4YJmBwXAkUb/xH866TX9JvNb021gj2ho7lJTuOPlB5ql438GT65NDe6a6R3QdVmB4EsYYHn6f0pMZT15JtY8TaX4dknkisjAbq4EbbTKBgBc9cZNQ+IdCtvCkNrrmitLayQzrHNGJGZJUbjBBPWtvxFoGoT3VjrGjug1CzUoY3PyyoRyv6Csqax8R+J7m1ttVtotP0+CUSyorhmmYdBx2qWMqeNF1Obxfps2lyyLPb2H2kRqeHwzZBFW4tdj1fxJ4UvLaQiOdZDJHnodpyD9DXRS6bK/i+11NQv2eKya3IzzncSP51z48Gz2fj2HV7R1Gn5eV4s/dkYEHA9yc0AZGqPo03xF1pdZhubhFRPJWJmwvr0NdZ4Xt9LW0lk0q3lgiL4ZZC2SfxNZraf4k07xVqWo6VbW08N4qj964BGK6PRn1eWGU6vbQwyA/IIm3ZFJjRayPMznFTknFUijPMcdqsIeMZ6VpSl0Imuokkm0cVXE5Z9uamlXA6daqMApz3rpRkSSqQRzmnRMSNpOfanRW8lwueQKtxW8VvhicsKVwHWE3ly7Wq9dR7hvXpWRNOBcDAxWxaTCaHYTUPuUjJuM8EVagjQoCADmi6h2EqRVe2kKP5bcUmCNNVXHCinBRUQlVerCg3ES9XAqSifC+gpCisMMoI96i+1wYz5i/nR9rg/wCei/nRZgItjaq24Qru9asbUPBUflUAvIT/AMtF/Og3sA6yLTswuSyhFQswGAO4rCu7uC6DR+UpA796u3t7HLEY0fJPHFUlsig3Lg560bbieuxiz6RAwMisc+hNU0/dPtFdI1qrZEikfSqw0VJJNyuMe9PQV2YUiJPLiXLRkbShPBrbtp447Uxqo6YFS/8ACP5bO4VNJYJZwdiTQrIHdla2i4Yt0NJNbDkgVciUeWOKcVNXuIxmQrQkjKeeRWrJArAjbyaoS2xTpUuPYdyVZ0ZcYFRS3HGEJFVJFYHjinxxM3apAry2cFxcx3MsKPPH9xyOV+lVV8NxT+Io9ZdnMsURRE/hGe9dDDaBeW61ZVAowKrlFc80Hw71K91S81a81WSC8kYiEwgYCehzmp/AmnXmi6brtjqKOFikeSJyMb8qOR+Vejle2Ko3ETJMCpxmhxXQfMeMeDIfDPko+sanf2WomfOImKqRnjNdv8U722s/EfhW5lI+zw3STSEf3QwJ/SuyfRUm2yPbwMeoJjBqdtFtbsL9tSKYL0EihsfnWajpYu5hDxP4d8UztbabJ5kyLvIAxxwP6isPxL4Vm1CKznsjsuraYOjN6dxXdw2OmWTk2dlCjkY3JGAakNvJN1GB6UxD7S1stX0yO2vbWCZUwWRl+Xd6j8a2fLQAKqgAcAAdKwbaRdPnIbgGtL+1LfqG/SnYC40SOpVlUg9iKybnw7ZzybiCPoasf2tb5+8fyp6ajC3fiizC4+zsIrKHZEOPfvU5Ue1VmvoRzu4pr38SjJNKwFkgAdqr3EMUiYIBzUY1GBh94UvnRvyrDigDOkga3fIPyVahG/GO9V53a4lwpyorUsIAqBj0FVfQnqeeXy7PHOqL6Rx/+gita3rM1Mg+P9XI6bI//QRWnb1CKNe06ity26CsO06ity26CmBfWpKjWpKAA9KhfoamPSoX6GgDLuupri52KeONw6izH/oTV2l11NcbMQPGzA97If8AoTU1uJ7G4rrIN3ejcGQgL1FVY5DC49DVzzgfmAGK0aIMG18O3NrerfTakWjRmZojnBHp+Fcnbs2s+ILzWru6J0fS5G8pW6O4Azj2HArpfFeqTtDBolhzf6gSob/nlGPvMf5fjSjQLS30ZdI2FrUJsbsX9SfqaVrj2OC8LaTf+ML+71i4l8qxe4MuG/jIPA+g4/Kl+13yTPq0Mv2q6eQ2WmIRneScM/0AzzXU+IbyPQ/D1roGjwbbm7/0eAIOEB4LH3rJ0q407TZJNYm+e204Gy063H3ppPulvxP86i1ir3JbxtYspLawW/e71W4UH7PHwqAdWY9hzVe1m1Urq015qcYtrDbumjzt3YyVB744rU8FSre2uoeIL+SOO8nmKOrNjykXov61Vke18Zayui6YAmj2snnX0qDAmkPRR/jVCOf0DUtVtReeITYvcJMrM007BAqAnG3PJ4xWnJPrFxLZ2em30s15PGssm8bVgQjqx9farPiC+tLq7mtZnEWi6WwRoI/v3MoAIQDsOgqtoupWcXg3U9Vv5xDc3gkLBT86Hnao+nFAFvSbbWbjxBc6TNrbTGCASmVCeCSBt+tEs2uXusXFlo+pFobVMXN05IRG64HqcDmsvT9Zi8L+C/OtQbrWdQQyHByVB/iY+gFXrDTnsvCiPqXiCNNPm/fSxQRYllZv4d27+lIZz2s6nf6hb2X2m5MjyzuiLGOJNhwGA9zmu98PeGr6ON5pbxxcXEZM7D++R/T+lYHhprC+1G61/U40srLTFFvZ2x5KKBnJ9WOa7jTNbu7rRUuns/sizMWiQnLeXn5S3oSMHFOKuJ6BqGi3VzKjw3xgURlWVR1PrXJaxY39xqUXh2HUGmkuQHuGAx5UQPOT7nArtdQ1mDTNFm1C5OREuQo6u3QKPqcVm+EdKlt4J9W1E51G/bzH/wCmafwqKGugkzz2/iutY8croukTNHBZRrCpH3Yhj5j9avahpP2WeLw8t+sdhbw+fduc4VRyM+5/rXc3VlpXhiDUNYhgIaT97Mw5Zj6Vwn2ea+s7G51E+U2u32+cE/diBG1M+mMUrDuWIbjxK2kTa4L1bSxt4t8MdwPmmVRxkdt39ab4lY6pZRXCatILq4CLHp0Tc729fQYBNXPEVknijxNaaPa3bizgXddCI/KoHIH1zik03S9K0jxndTTSYt9LtRJvmbLO7cbvwAI/GhjRl3nh6PwzFZ2lmguNZueRH1PuxPYDOK0YpNb03WLCw1DWI9kyGWXYf9SoPc+lWfDGr2esalrniO+lSDZiCESHlIwCcj6k1xc2h3GozRzNe3DXOqTsIA3GLcNjc3seaT8hmpfeN7wx3jae81xb2jkLNtOGHqW9Pauj8Gf2/wCIdD+2Xs3kw+arQu33mUdfwqbXrCwg03TvCGlxxxJeFRPKcDbEvLMT64Bpi+OVg1q10XR9LWbTCDbxyNL5YcgckHB4AB+tTs9QJri81jVrO5TSGjitbV2LXkzY8wgdFHXHvXNana6hqPhyx1K41CcSXLNFFaIT+8bJGR7V13hcGw1nVPDjlJ7eNVuYmBztVyQUP4imTS2Z8dXMl7JHDZaJaIYo+g3PkkgfgBQBBY+AYtP02yjilWK8VMzzbdxdj1/Wuyso3tIERpC+O9ZXh/Ub/WrKXUbm3FvazSE2iH7/AJfQM316/jW1Gc/KelFgLmRJhhThtPB5qm05t4ZXAzsQsB9BXJ2Pi7U2exmuIrF7e7mMQjikPmJyeentQM6q6Wfz1MYOPatFM+Uu/hqwPGV7c6d4Tv7q0k2XCJ8j+hrnbbxPqFx4R1NrhvJ1fTrZxKPVgpw49j1pNjPQeF4qGWPPzAVx+q69qMmm6JpunOq6lqmAZ2GRGgGWbHc/41W1XTdb8KWg1e31ya+SEg3NvcIAHUnBIIPBqWM7ZelLjiuF8Z65qlqdEudE+b7SvnGI/wAa4Bx+tX7jxH9uTw1dWEm2K/u0SVe4HGVPuDkUhnURgiT2qzIuIy6/jXnevXc8/jttLbW20y1S0EoYAHcxxxz9a6TwxB5QuQuuvqaMAMED5D+FAjTRMFmPemq6pL1qztURkE8iqKqGlY1KfKx2ui44DJTYIoc75CMjtTIXOSppkyEfMtdcXdGDVmXXmJGFGFqPr1pkBaRRgc1aWJUyZWwfSjYCt9lM7Zp1vKYZ9uehpsk7uxROF9RVcjy2znJpiN+RBcQ7lGTWFe7oWyODV+wvOdrcCp7y1WUbuxqdijLgUSIHd8U26ERX92STT3t9sZCmmQblQgrmlyhcjgVWGCOam8lOmOtEUR3kmrDKMVYiEW6DtTXhjAJIqWmyLuXb60CIbe2DSbuwrSA7DpWaplg7fLVuG7R8A8Gs5JmkWizsB6jio5bdFQuDjHWp1YOOCCKgvZBFZyEnGRSW4PYorerv2rJzTbiWSUgFSQKyIV3Etg896vzxXFtbLKHyprTl1IuWUkGMFacJEPeqEV/JKVCpnHWppLmEYAQmTvT1EW9wHekbYwwSM1R88NIA4K0huIjJt3EkUASz2iFgOKIYVB25HFI8kZQOWPFWrW1juIzKGIUDrRsMRduOGzikaSMd+aqvdpFIVjXdjg1DPchXU7CA1Ai/5y4zULs03CDJFRSXG5o4I1ALd6dc2tzZRiYN9aQEjXjxqqO+CO1SWc8U8+0v8x7VkXDebGlweveltJVivVlIIBp8ug+Y6tIETkChlHUUsMqzQ71PFMkljiHLCsiytd24lXIHNUI1UZUjmrMt+SSsa/jUEURZ9zVURSHi3UnOBTtirxipNopMc1ZI0hFGTVNplklxjIq66B1INVBC8THaM0mBcQWkny8Kahu4xGP3b5PtTFhaSTLcVZS03MOcnNTylXH6bbs4BbvWhdzi1iCDrUiBbSEE4zismaRrucgdKe4jirht3jTUm9Y4/wD0EVs29Y1whj8aakh6iOP/ANBFbNtUFGvadRW5bdBWHadRW5bdBQBfWpKjWpKAA9KhfoamPSoX6GgDLuuprjJh/wAVxz/z5j/0Jq7O66muJuiR424/58x/6E1NbiexsyoCOKjhk2ttbpSo+/ANPkjGM9DWxmKNOtRqB1BYlNy0Yj8w8kLnOBVlolkjKn7x71WtpjuCE1bP3gRU7D3Mf7LHb3azTqpdD8jMASPpUVp4S0SC+GoQ2o83cXXcxZVY9SFPArYuLVLwAHgg0kl3b24W3jXdjgmm9RLQw5/BWh3d480ls4MjbnRJWVGPuoOKv2mj2OixmOwtUgiZtzBB1Naa4I3CgOJAVIpWKMM+HNGk1JtS+xobpjuLMSRu9cdM1Un8I6M929w9hGWcknOduT1O3pW8VEbkMMipGQOo2nOKNBXOf0/w7pGnrKlvZRr5qlWLZYlfTnoKitPCWiWl2swsyxU5RZJGZV+ik4rakXaemCKF+dcnqKdkK7KT+EtFm1Br57TLuwdl3nYW9ducdq15LdJYiG7DgUyCX+BqnJxS2He5i3GlRX2xbqIPFFIJFU9Nw6fWtdNjqMHgcUt2hnttqHaR6d6radayxBmmyEHc090BYkhhnjaKVQ6HgqwyDWdqWkWd9bfZbqBZIBjaOm3HTBHStdkQtlTkU3aJAVP50gMvT9IsNLtTFZW6Qg8sRyWPuTyaqXvhrSdUvUub213yrgEhyAwByAwBwfxrWx5UhDHilK5G7pQBnz+EtDurpbmbT4ywAGFyqnHTKjg1ffQrG4ulu1t0SdYhCrD+FB2A7VPBJkbTVjftH9Kloow9X0HRb4wi8geSWIbQySMhweoODyKkuPC+jX+nQWklmiQwkGIREoUPsRzWp9iid/NbPrimQu7TEMAqDpUsCto/h/TdEEq2UJVpiDJI7l3bHTJNV9U8J6PqeoJeXlp5kqgKSHIDgdAwB561uYGMinLiRSDSKI1jQRKiKAqjAUDAA9BVaRNh9KsK2xthpZY9wxQBTmUz2c0Q+8yMo/EVylt4QS1tNNkigVb+3n8x3DHkEnP9K67aVbp0qTgjPekMy/GlvNe+Er+3tomkkdflVRya57xv4evpdLOpaREWvDa/Z7mFR/rUK7enqP6V3kThuD1qbcF6Umhnneq2OoWdtoWq2UBlvNNGHgPV0YYYD3pdY1688V6d/Y+l6TdRyXJC3Es67ViXOT9TXf3ESyJuCjdUdk8rZEiYAqbDOYvtJmj1vw1HDE0kFmhjd8cAAAc1h3/hy/0vxvpb2MJfSJL5bllHSBs/N+HU16YwAPFMYB1NFgPOdeto4vH7397os2oWb2axpsj3BXGP/r10fhm5s5HnjsdGm08ABm3xbA9byNsbB4qYue3SkBFLEShYfjVNEKISBmtDJYEdM1AT5aMpHNJoaZSjkAkOeKtjbIhxVCI+Y7AipoSyS7e1XTnbQmcb6k4ufIQqqjPrTG3yjczHJpzqp+bGSKSJZJztUY966DIiXduwnJqykSxN5lweewpwMdmpAAaQ96r4Mp3SEk0AK0gMu5BgVrWk4kQI1ZfAHSkimZHyM4pNXA07iDYSQMg1V2gdKv20yzx7WPNQzwmM5A4pJg0VgKQrx1NLmgnjFMCPFFLg0maYgbkc81C0Ck5HFTZooGQASxHKMcelR3Uj3CbH/SrR9jTSAeoosBmLGyLsU/nT5ZJ5gLfqKumJD0GKZ5JDbgcH1oEZ9mxtJ3jYdehqXT2jhvi04yCeCaneBmYMeSKJYd6g7MEU27gX7p7J252k+ornUwbyQJir6xKOGUk0iWcSOWGcnrSVkD1GSFBp7hsbs1e066hi07axHNVXhgMZXDHNRxQQgYIbAPSh2YakU8ah3khbjrimSzGS3jJTlTWmYrYqSI8cdKYWVsKIBge1FwsU3t5R5dzGM4qxPdz3kIjK47GrBkl2hVG1fYU3ynbq3Wi4yF7CMWaxsw3deKVIYRCEKbmHQ1OIMdeaeEAOcYoAiQzKmxDtX2o8ot94kmpulLjPNKwDFjVRwKdk07GaNvtQA3mlFLgUYoAUDIpQMUgIp4UscCgBAhLAY5rShhWKPzHHNFvbqi73qjqF/kFFPApbjIr+6Mj4B4qhFIySZBNOim3HJXdU4niByYRinsI465Yv411Jj1Mcf/oIrYt6xrllfxrqTKMKY48D/gIrZt6zLNe06ity26CsO06ity26CgC+tSVGtSUAB6VC/Q1MelQv0NAGXddTXGTKzeNiAM/6EM/99NXaXdca+R43bH/PkP8A0Jqa3E9i3uMb5qcSb+aSSIkbqhVtj89K2MyRlP3h1FXLeYOoz94VGpQrUJJjk3L0pAX+SxqubWFWMxOT6VKH3oGX8acMFeVNIZBbyu8hD4Ve1WGXacKc1QmgkFwJAxCCrUV15x27eB3psB7pvX3qBSV4PWrBPOKo6tL9msJplPO0gfU0gMyPWGn1UwlR5TEqrVZ1C4a0tJJkGSvY1zy3KLa24WN1mjk3sxHBrd1VxPoksi/xKDQmDRJ9qf8Asn7WMb9m7FWLDUBLpQup8DClmx7VkrKg8PYLA5jx1poV/wDhGBsz9wk/SgC0mpardqbi2t1EK9ASMtWnb376tp/K+U6Nh1NUbWZ30GM2ckYkUDO49PWnaJfSXkM4mALIwGVGM9aSGXPtrwWzLHH5jjoPWsyfW9Rt9pm09U3HAy3WtGeHyF8wfWs2wnOs61JJKMx2w2qO2abEi3qV61vbRER7riUgKvvUWmahLNcvaXUYjlUbuDxima+CZLW3XAd3BV/7tVbKKW01x4pXE0jx/fFK4zoCux8ryKsoRIlV4nyu3vTgDA3rQwRZVsEDFU7q3czh0b5epq4HB5xTlZSpDKakZHbTCQmMKfrU/wB3iqMrymZY4ExWgsLrCC5+akMjdcjI60kUnIDdakLYIGKjdcfMBSGMuWSKOSVjtRVLMfQCq9rcJLCssZ3RuMq2OopdSG/Rr318h/5V579tubW50+RrqQwpFGojifDITuzlCPmB45B7VLdij0roQy1ZTDqMV5lBql1Fe36tdzStLHMY3ifK/LnAKkAqR071b1TxBOY5f7Mui4+ywh2RuF3MoJz2OCfpSuB6EM5xiqb36zIwtfm2uUbHYjt+tcFBeXzRRWNxqLQ2DXYV7hJd7INrHaWwB1ArpfA4A0SYiY3A+1yYlYcsPlo3Aw/EPjXVrXXf7D0HThe3sUYluCzABc8459sVu+EfFUfibRPtrRG3nhYpcxHnYw61yOjyJbfGLxIbkEM0MZTPpso+GMojtvFV/szaC7mkRfUAk4/KpQyvP8TtYkEuswaMD4fhm8p5S438nGcV6RFqMUumC+BIiMXm88cYzXgK6ZqFx4Fvtchvo4tMF0rvpueG+cd/xr1nUdQ874f2LwJ5b36xwog7ZPP6A0hltfFEmn+CpNdv4mlYsxijQclckKP0rn9L8e61/blhaa/owtINTx9mdGBI3dM12k0+maLoUK6jJHFaQqseZFyM44rzTxKt1pvxB0PV7u6j1DT7iZfssS8GJTjGBTYHZeI/FFj4VtXmug5lYHyo0Unc3YZ7VD4X8QT+IdEh1GWMRvISCo6DFbPiyyhfw/qZliRyttIQWGcHaa4XwXdiw+GZue6CQL/vHAH6mp2A6fS/EDtY6tqF4R9jt5WWHA5KqBn9TXJw/E3WIBDqd1ojRaJcSbI5gwLYzjOK6/TbK30/w5aw3O0p5Zkm3dDnk5/OuIvppPiJqkOjaPFHaeH7J/3lw5A3kf3RWsZXViHGx2PivxUnh3SI7qKA3N1csEto/wC8T0qh4Y8Y6hea6+h6/YCzvjH5sW0ghx1xx7Vl/ESJbbVfCu7P2WK+iBJ7AMP6U7UFN18atJjt8EpbNvIPbaa0b1IsavjTx5aeGo/s0atLfMAVj2nAHqT0q9qni9dH8GWupi1ae6uUXZCgz8x/pVL4qQ2i+B7wrCjTK6HzMcjn1q3pt9pem+E9Jk1SeKJZIlWMyKSC2PpTu7h0Mzw1421geJYtH1/TRaTXKeZAVYHj3xXqMNwk6bH64rxDy73S/i5YPqNwl99sGLdgcGFSeBj2r1tXKHIpJXB6F2a3KnK1z/irVZdD8NXuowpvkhTKg+tdHBdBxteq2r6RDqenz2sozDMhVhR5AfNlr8TfFEF+txJqMk0e7LQucoR6Yra8W/FS/vbmNNCne1twgLOOGLEcj8K5Txd4UvPCetS2dwpaAnMEwHDr2/HsaxIIJbmeOCCNpJZGCoijJJPaseaS0NLLc9t+GnjLUtdtr+11BjNNbReakp6n2NZi2Au/Cd54ql1GddWjuCVk8w/JhgNmK63wB4OPhXR2a4KtfXIDS46KP7tcoZfB91qv2qSw1iG0ku9rE7RbGUdyAc9a11tqR1NW38aa5IL6f7NCLSwgR5S33mZkBwPzqGLxrr1rI0epfYAZLD7ZEyH5VyuQDxXVy6dpUR1C3tpbYXmoIN0MjjDYUAcdcYArjPD/AIOthqs0GryWkYe3NstslzvcnpxkDGOwp6hoSWvjzWhp16rxxS3UUsKRO6FAd7AcgjPeur8J6zqWpTapZatHCt1YSIrGH7rBgSP/AEGq8PhTw3FcParcFrklHdDMCxKEMOPwra02HTY9Rvp7KaN7i52tOFbP3cgfTqaauJ2NLFFLg0Y4qhFe4ube18szypEHYIu84yT0Apl3eW1jCZ7uaOCEcF5DgD8a4Hx5e295qzWDzuhsrdrhNiM2ZsfKOBVrxRqI1j4f6bdxRrKZbmDMZONxz901Nx2OsstU0zUndbK9t7krywicNilvNV0vTXWO8vbeByMhZJACR9K5CwiltPHdgbjSY9NWW3dI/JfeJTlSd3TGPp3NXvC9hZ6vNrd9fwpNctfSQHzBnai4CgenHP40XYWOrFxb+QJxNGISu7zCw249c9KWGeK4j8yCWORP7yMGH5iueGg6VcaRHYw3bSWUFwziLf8AfIbPl59M8Vm+Gr1LC48Qy3Fo9kkGJfsud21eeRj14p3Cx2fnR+d5O9fN27tmeceuKa17axtskurdH/utKoP5E1w3hzUbefxy1zNdiS5u7NhsGcJ8ykL+QNMvoLrTtT1LWL/RILm0+0hhKZvnVNqjgdOoPelcLHfTXUFugeeaOJT0MjhR+tJJdW8KhpbiGNW6M8gUH6E1w2ttdan4w8i305NQjjs1kSOaQog3c54B55rW0tNIvfBcM9zbsbO1iZmSdtzJtHIz36UXCx0cV1bT7vJuIZdoyfLkDY+uDSQ3dtcllguIpSvDCNw2PriuJtdMisfBOrajGn2SS+j3AJk7FzhQPrmq/hUTW3ia0S404aaZNPIQeZu+0NkfMfQj+tFwsegLeW32j7OLiLzv+ee8bvy61Y7V5FqU0Wn2ku+xuf7cjv2kFzjKkFzt+bOMbcDHtXrtNMGhlOHSl4qSKBpGGBQAxIi7YFaEFskS75DTljS1TLEZrPur7zCVU8VO4Dr+/wCCqcCqFvGlyxDtg1P9geVN5YUCxaMZDDIqkIjEAiYqR9KCgJ21eWPfABKyhuxqpIjRsQwx6Gi4WOJmTZ4y1FfSKP8A9BFbVvWNcc+NNS/65xf+gitm3rMs17TrW5bdBWJadRW3a9BQBfWpKjXtUlAB2qJ+lS1E9AGbdCuLumWHxxbhh/r7QqpPTKkn+tdvdLXHeKdPmuIIru0H+m2b+bFj+L1X8aANYKPJxiqTqKfpeowappaXdswKMMMO6N3U+4NT+WGiyRmtUzNopxNzipmHFQlQDkcVZhcMMEAmqEMhlML4PQ1aackAquailgyucHPtSW0uw7GFJjLAdZB844qlM8r3AjgTavt3q4c/w1JE/lkkKN2OtJMGHkOkS+YRuqle2UV9EsUkjKobJC96hF1K+osJCSM1f2IxyGosFyne6fBJbmMKApGOByKihtIksPszEugGOetagVQcHkGqs0flvx900AYMnh2JSAs0vlE52ZrXhgRYRBgbANuParLjMQIqqSc8HmmhGf8A2DBHKds0yxk8oDxWrZWcNjHJ5AJWQgnPbFIv7zgnmp4pRG2xhxSaHceW85CrDjFY0Fg+nXD/AGfcRI245rc46gVIHVAW2gntRcClf6XHe28fnsVccqynkVDYaXBZTNK0ryysMbnPalj8+e6LOTtFW1VHY4YHFFguEyCNt6GlQiRcnrUiohO0kVGyCJ/akxjo5GjfBAxU3m4PSoHXzBxxT45Ao2kZNSxlmNwCWCjdWc95P9uwxO30q6H46YqG4hMqjYPm9akZOJFbkYNPDhu1U4oxakCVuT71bwMZBGKBjZFBOMAowwQah/s2xeRZTaQmRBhX2DIFWkAYYNIP3bY7UhmX/Z1tHcvJHaxK7ffcIMt9akh02xjieOOzgRXG1lVAAw96utjccd6iDbX5qWUhiabYpbm1NnB5BO4x7Btz64qzDDDaxeVbwpFHnO1BgUNhgCKejjoRSA5XxJ4BsPEmopqIvLqxvAnlvLbsBvX3yK0dE8N2XhzSE0203G3AO9pDlpCepNbbcdKZNE1wAuce1AHn/wDwqPRpZ38vU9QSwaTzGslkGwnOcdOlddLoNpPNp2S0cOnktFCv3ScYGfpz+daoENogQ9TS8EZzRYDK1zRbTWdOmsLxS8Eo5wcEH1Fcvo3wy07TtTtr241C9v8A7Lj7PFcOCseOnAFd4oDA7qbt2H2pWGR31qmoWE9pKSEnjaNiOoBGK5WHwZaWGjwaKk8ptopRKWbGXwc4PtkCuw9KSeNZAGH3hQ1cDmNZsBqFlLZPI8aSLsLJ1A9q4y3+FVrahWg1rUY1BzhHAH6CvRb2Fiw4oEflwfNUJWYyjrfhux8SaKunXpkAUKUlQ4ZGHQis/wAOeCrTw1ey3y3dze30ieWJ7hgSq+gwK3YrsoMY4q6pWZM10xkpGMk0Y2vaJBruizaddO6JKQSydeKg1Hwpp+reG4dGufMMUSARyKQHUjv0reaIkjuKdjAxWlkTc4/Qfh7Y6LqaalNfXeoXUa7YmuGBCD2GK6/mlozQlYBB8pzmrsF3tADciqeaOOpoauBH4o8Mad4u0aSyuV2sRmOVesbeorivAnwyXwxK9/qZWe/3ERYHyxj1HvXexXDRnitCG6SUYfGaz5dblX6Gc4wD9DXkUNrq9x4bPhkaNcLLJqDSG4cYRU3ZzXt0torjKEVTaJkJBzT3FseK3WiXkOoXFk2n3UmsNeo9vfAnaIQqjr+BrQPhS6+0yagLaT7b/bpkWTnPk+Z1+mK9XI4oHAo5QueNW2kXq6xbWy6fdLrUepGaa+JOxocnPPoRx+Ndr4B0L+zNMuZ54GjvJ53LlupXPH9a7DIPFBwBQkFyP+VB9qXqMdqFXcCoqhGZZaLbWd5e3R/eyXchdy4BwP7o9qzJ/BlpNoEmlJdzxRG5FxE643RkHIA46V0x6haGHzBR0o0Gc7YeFFs9RivrzU7zUJ4VKwmcqAmevCgc8Cobnwp5uo3N1Yapd2BueZo4tpVmxjOCDg4FdS+MimxjDHIosBgSeFLQ6Lbadb3FxbG2cSRTowL785LHIwcnrxU2l+Ho9Nlup5rmW9musCWSYDBA6AADGK2gMsQaNpU4J4oAx00Cxh1tdUihRJREYtqoAOoOfrxVC68IrdS3CNqt4LK4lEsltlSM9wCRkA46V0xBH0pMc8UWC5i6l4cW9vYry1vriwuEj8ktCFIZOwIIPSnf8I3aJ4abQ45JVt2TY0hOXb1J9zWzS9qLAUbvS7e80mTTZNwgeMR5U4Ix0I9+KzNN8MCyv4bu51C4vpIIjDD5oUbFPXoBk8DmugpQMnFAHN/8IlG1yDLqV1LaLOZxavtKhs5xnGcZzxXSKpbpU8doznpVtYY7dctjNK4EENoWIZhgVM88VsMLyarz6gSpWPgVQLs5y3Wize4Ek9w8rZJ49KrGPMm4H8Kk68dqXgVQhfNcDANRyu5XO80tDAFCKAKxkkfbljxWjFcJJFsm5YdKoPAyxhgay9b1YaHpnnffu5j5dtFjJdz7elJ7AjDtpheeJ9ZuU5jEwhU/7owf5V0FuOlYmi6f9gsY4WbfKfmlc/xOeSfzrft1rMs1LQc1t2wwtZFovFbVuMKKALS1JTFp9ABTHFPprDIoApXC5FZF1HnNb0i5FZtxF1oA4W70m6sNQm1LRnWKeXmeBuI5/r6H3pYvF9rH+51OGfTZe/modh+jDj9a6O4gIJ4rOntkkBDorD0IzQm1sFrlY63ozqHTV7E5/wCnhP8AGmprWlZz/a1h/wCBKf41DJpVoTn7NF/3zULaTaf8+0f/AHzVc7J5UbEfiPR04bV7H8LlP8aa+t6HKpkTWbAEdQbhAf51jHSbT/n2j/75pP7JtP8An2j/AO+aOZj5Ublvr2jkYbWLDHvcoP61Mdd0YNxrOn/+BSf41zv9k2n/AD7R/wDfNH9k2n/PtH/3zS5mHKbN7rGisAY9X05SepW5T/Gki1vQ7fC/2xYse5+0J/jWP/ZNp/z7R/8AfNH9k2n/AD7R/wDfNPnYuVHRHWtEB41nTv8AwKT/ABpf7b0RxtbWdO+v2pP8a5z+ybT/AJ9o/wDvmj+ybT/n2j/75o5mPlNg61o6yFf7ZsCvtcp/jTpNV0UIWGs6cSB2uU/xrF/sm0/59o/++aP7JtP+faP/AL5o52LlRqLrWkLz/a1h/wCBKf41Mdb0ZkB/tfT8/wDXyn+NYv8AZNp/z7R/980f2Taf8+0f/fNHOw5Tbh17SQcNrGn497pP8amOuaPkf8TnTv8AwKT/ABrnv7JtP+faP/vmj+ybT/n2j/75o5mPlOin8QaI8DJ/bWngAZOLhOf1rOt/E+hpLsXULPB6kzL/AI1nf2Taf8+0f/fNH9k2n/PtH/3zRzMOVHRnXNEJB/tnTsf9fSf41Idd0NhzrWnf+BSf41zH9k2n/PtH/wB80f2Taf8APtH/AN80rsLHQjXdHSQr/bWnEev2pP8AGlfXNEPTWNOz/wBfSf41zv8AZNp/z7R/980f2Taf8+0f/fNK7HY6ePxBomMNrGnf+BSf40//AISHRQcDWdNx/wBfUf8AjXK/2Taf8+0f/fNH9k2n/PtH/wB80tQOgvtX0SVkb+29Oz7XKH+tXIdX0GGLDa7prH/r7j/xrk/7JtP+faP/AL5o/sm0/wCfaP8A75o1GdZ/wkGiL01nTf8AwKj/AMacviHQ5E+bWtNH/b0n+Ncj/ZNp/wA+0f8A3zR/ZNp/z7R/980WYHUHxBoobA1nTsf9fSf401tb0T739s6aT/19R/41zP8AZNp/z7R/980f2Taf8+0f/fNKzC51Ca/ovfWdO/8AApP8acde0QdNa03P/X0n+Ncr/ZNp/wA+0f8A3zR/ZNp/z7R/980uUfMdaviDRcc61puf+vuP/GnL4g0TcP8Aid6b/wCBcf8AjXIf2Taf8+0f/fNH9k2n/PtH/wB80+Vhc6q91nQpl3DXNNyPS7T/ABqGHxRo24AavY7enNyg/rXN/wBk2n/PtH/3zR/ZNp/z7R/980uULnXnxBohGRrem59Ptcf+NIdf0Nl+bW9N/wDAuP8Axrkf7JtP+faP/vmj+ybT/n2j/wC+aOVhc6n/AISDRg2P7a03H/X2n+NSf8JDogwDrWm/+BSf41yX9k2n/PtH/wB80f2Taf8APtH/AN80coXOpuNe0No+Na03d/19J/jUUuu6GLQ7tY04nHQXKH+tc3/ZNp/z7R/980f2Taf8+0f/AHzRyhzGtBrGjOjA6vp4PbNyn+NLba9pKTbTrFjjOP8Aj4TH86yP7JtP+faP/vmj+ybT/n2j/wC+aIwswbudQuv6LznWtO/8Ck/xpp17Rf8AoM6d/wCBSf41zP8AZNp/z7R/980f2Taf8+0f/fNaczI5Tpf7e0X/AKDOnf8AgUn+NL/bui/9BnTv/ApP8a5n+ybT/n2j/wC+aP7JtP8An2j/AO+afMw5Tpv7e0X/AKDOnf8AgUn+NH9vaL/0GdO/8Ck/xrmf7JtP+faP/vmj+ybT/n2j/wC+aOZhynTf27ov/QZ07/wKT/GkOvaL21rTs/8AX0n+Nc1/ZNp/z7R/980f2Taf8+0f/fNHMw5Tq4/E2kRD/kNad/4FJ/jVpPFeguuJdZ04dv8Aj5T/ABriv7JtP+faP/vmj+ybT/n2j/75qbsdjuH1vw6wyNd0wH/r7T/Gqz61oYyRr2mH2F3H/jXIf2Taf8+0f/fNH9lWn/PtH/3zRdhZHUf2/ojHH9tad/4FJ/jQdd0Qc/21p3/gUn+Ncv8A2Taf8+0f/fNH9k2n/PtH/wB80+ZisdQNe0Vuus6aP+3pP8aDr+ijhdZ07/wKT/GuX/sm0/59o/8Avmj+ybT/AJ9o/wDvmjmYWOp/t/RF/wCYzpxJ/wCnpP8AGkTXtFyd2tadn/r6T/GuX/sm0/59o/8Avmj+ybT/AJ9o/wDvmjmYWOnXXdFD86zpv/gUn+NK+u6JuBXWtO/8Ck/xrl/7JtP+faP/AL5o/sm0/wCfaP8A75o5mFjqJdd0RlBXWtO3f9fSf40ia/opX59Z07/wKT/GuY/sm0/59o/++aP7JtP+faP/AL5o5mFjpzr+ioeNZ04j/r6T/GnDXdEIz/bWmj/t6T/GuW/sm0/59o/++aP7JtP+faP/AL5o5mFjpzr+jdDrWnf+BSf40n9v6IBk6zp2P+vpP8a5n+ybT/n2j/75o/sm0/59o/8AvmjmYWOxj1rQSoLa5pn/AIFx/wCNWBr3hyNcjW9LJ/6+o/8AGuG/sm0/59o/++aP7JtP+faP/vmldjsjsZvFmjAYTWNO/C6T/GqMniPSXOW1qw/8Ck/xrnP7JtP+faP/AL5o/sm0/wCfaP8A75oTCx0J13Rv+gxp/wD4FJ/jQNd0b/oMad/4FJ/jXPf2Taf8+0f/AHzR/ZNp/wA+0f8A3zT5mKyOh/t3Rv8AoMad/wCBSf40f27o3/QY0/8A8Ck/xrnv7JtP+faP/vmj+ybT/n2j/wC+aOZhZHQ/27o3/QY07/wKT/GmS+INDSFmfWdPA9rhCfyBrB/sm1/59o/++aculWoORbR/980czCyJpvGVsR5OkW0uozf3whWJfqxwD+FZ1rp082ovqmpzfaL5xhT/AAxL/dUdq1Y7ZUGFUAegFWY4Palq9x7DYYunFaVvHyKjih6VpW8HSgC1bR9OK1YlwKq28WKvIOKAJFFOpAMCloAKKKKAI2FV5YsirZGaYy0AY80HXis+W1roniBqrJbCgDnXtz6VCbfnpXQPa+1Qm1HpQBhm39qT7P7VtG0HpSfZB6UAYv2f2o+z+1bX2QelH2QelAGL9n9qPs/tW19kHpR9kHpQBi/Z/aj7P7VtfZB6UfZB6UAYv2f2o+z+1bX2QelH2QelAGL9n9qPs/tW19kHpR9kHpQBi/Z/aj7P7VtfZB6UfZB6UAYv2f2o+z+1bX2QelH2QelAGL9n9qPs/tW19kHpR9kHpQBi/Z/aj7P7VtfZB6UfZB6UAYv2f2o+z+1bX2QelH2QelAGL9n9qPs/tW19kHpR9kHpQBi/Z/aj7P7VtfZB6UfZB6UAYv2f2o+z+1bX2QelH2QelAGL9n9qPs/tW19kHpR9kHpQBi/Z/aj7P7VtfZB6UfZB6UAYv2f2o+z+1bX2QelH2QelAGL9n9qPs/tW19kHpR9kHpQBi/Z/aj7P7VtfZB6UfZB6UAYv2f2o+z+1bX2QelH2QelAGL9n9qPs/tW19kHpR9kHpQBi/Z/aj7P7VtfZB6UfZB6UAYv2f2o+z+1bX2QelH2QelAGL9n9qPs/tW19kHpR9kHpQBi/Z/aj7P7VtfZB6UfZB6UAYv2f2o+z+1bX2QelH2QelAGL9n9qPs/tW19kHpR9kHpQBi/Z/aj7P7VtfZB6UfZB6UAYv2f2o+z+1bX2QelH2QelAGL9n9qPs/tW19kHpR9kHpQBi/Z/aj7P7VtfZB6UfZB6UAYv2f2o+z+1bX2QelH2QelAGL9n9qPs/tW19kHpR9kHpQBi/Z/aj7P7VtfZB6UfZB6UAYv2f2o+z+1bX2QelH2QelAGL9n9qPs/tW19kHpR9kHpQBi/Z/aj7P7VtfZB6UfZB6UAYv2f2o+z+1bX2QelH2QelAGN9n9qUW/tWx9kHpThaD0oAyFt/ap47Y+lai2g9KmS19qAKUNtjtWhDB04qaO3AqyqAUAJGmBU6ikC0/pQAUUUUAFFFFABRjNFFADCtNKVLRQBXMY9KaYhVnFJtoArGAelJ5A9KtbaNtAFXyB6UeQPSrW2jbQBV8gelHkD0q1to20AVfIHpR5A9KtbaNtAFXyB6UeQPSrW2jbQBV8gelHkD0q1to20AVfIHpR5A9KtbaNtAFXyB6UeQPSrW2jbQBV8gelHkD0q1to20AVfIHpR5A9KtbaNtAFXyB6UeQPSrW2jbQBV8gelHkD0q1to20AVfIHpR5A9KtbaNtAFXyB6UeQPSrW2jbQBV8gelHkD0q1to20AVfIHpR5A9KtbaNtAFXyB6UeQPSrW2jbQBV8gelHkD0q1to20AVfIHpR5A9KtbaNtAFXyB6UeQPSrW2jbQBV8gelHkD0q1to20AVfIHpR5A9KtbaNtAFXyB6UeQPSrW2jbQBV8gelHkD0q1to20AVfIHpR5A9KtbaNtAFXyB6UeQPSrW2jbQBV8gelHkD0q1to20AVfIHpR5A9KtbaNtAFXyB6UeQPSrW2jbQBV8gelHkD0q1to20AVfIHpR5A9KtbaNtAFXyB6UeQPSrW2jbQBV8gelHkD0q1to20AVfIHpR5A9KtbaNtAFXyB6UeQPSrW2jbQBV8gelHkD0q1to20AVfIHpR5A9KtbaNtAFXyB6UeQPSrW2jbQBV8gelL5I9Ks7aNtAEAiA7U4JjtU20UYFADAtOC06igAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/9k="
				}
			],
			"education": {
				"title": "College",
				"id": "tradle.EducationNL_123"
			}
		},
		"tradle.Collateral": {
			"_t": "tradle.Collateral",
			"street": "Grootmeesterplein",
			"houseNumber": 45,
			"city": "Utrecht",
			"region": "Utrecht",
			"postalCode": "3554",
			"country": {
				"id": "tradle.Country_ecccd57aee4a2a420e316764d456a13acf0b4db9b4f47f0fd9c1511aa34da446",
				"title": "Netherlands"
			},
			"message": "",
			"houseValue": {
				"value": "350000",
				"currency": "€"
			},
			"kindOfConstruction": {
				"id": "tradle.KindOfConstruction_ebfaf2960a666a09f793eae0f5210f41a9e72eacd84241730efe60395204dd40",
				"title": "Existing house"
			},
			"kindOfHouse": {
				"id": "tradle.KindOfHouse_6ef25efa7a7b59ed7aecaac948209af1c7de5363ccdf93bd1152e3cec7cf607e",
				"title": "Semi-Detached"
			},
			"restructuringCosts": {
				"value": "50000",
				"currency": "€"
			},
			"yearTheHouseWasBuilt": 1990,
			"rented": false,
			"purchasePrice": {
				"value": "350000",
				"currency": "€"
			},
			"valuedPrice": {
				"value": "400000",
				"currency": "€"
			},
			"energyLabel": {
				"id": "tradle.EnergyLabel_0b9486e61931a4eebc3ace780626f049e0c0d7d88567629aceb892571bc9ab09",
				"title": "C"
			}
		},
		"tradle.PropertyOwnership": {
			"_t": "tradle.PropertyOwnership",
			"dateNotarized": "11/14/2016",
			"photos": [
				{
					"url": "data:image/jpeg;base64,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PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPDAADDBACBCDCAAQQAQQQSDDDTTTDDDDDQAQQAQQfcddfdcdcffffdedfccdfffffffffffffecccfcccceddb/PPPPPPPPPPPPPPPPPPPw3//AP8APjD3vCDCCe6CCS/C/vP3/wD/AP8A/iCCCCCCCyiWu++CSKCCW+2+++CCCCCCCGG2We++uCCS++G2+CCSifo8888888888888888888//AP8AuLLcMN//APDCKeOSCCTf/wD/AP8A/wD+4hnjgprjilqglqsgpnrgghnvvvuggggggghnvvvstuutjikvjktstrs5PPPPPPPPPPPPPPPPPPPF/wCNrLI7rLfuPc5KIII//wD/AP8A/wD/APtoghvsggksslvtjkowutsgigvvvvgggggggggksvvgokussvjmtigggtg1PPPPPPPPPPPPPPPPPPPF62nlTIAPHN48xzzzyy288873++xx+4x/5318972/78//APO8vef/AL/HH333v73/AP8AvfOOcuNLLK5b6JaeYYIJNTzzzzzzzzzzzzzzzzzzw+LL8saFWmFwu35iyxjj5JqJpwxp694tpA3VwTapwwiTQT5ZYbbIq4oIa56rp5a4LjaKrILLbpIps213Tb4ppTzzzzzzzzzzzzzzzzzzz+r4oI2QSovvvaQoq7pYpb6J5Y4KfdPNei54JYyQMSwCxIIJYr7/AGvSaKqOeq2GGqS+64Jwsm6as3KCG3CyqDY8888888888888888888/DuOyCE6u+mi2Cyi6yn3P2+gMMmoeCm62eOiym+Sieu6yaeuWmCafyuCyqqmyXSyKiiemmOnCuyI04mLeKiDo8888888888888888888Tr+iQseOOscUezXiCzT6me2C6+u27SWOGCqqCiqCOAwepVtDX7DK2SiujLPPzLOSCOi+qiX/LqoOEeic+6KDo8888888888888888888LX+SqcKKykWsKKyGeqmvxde1VAgBtx8ck/zZHc4owU4A9K5c3clsFYiWU0dYgZhO6uKVVymm61WueWyISm2/o8888888888888888888hzvriUauumAKhEQd4w0wMAKc9RBTx1s6SxN0da6kk4Aea5au1ZqE0g/wCYrpPCjxPfMSthlGFIDEmsmmjMprl6PPPPPPPPPPPPPPPPPPPBad9ggkoAhsJONPmnPkDoOu9uCD5mBm9w4mjLEApM9+91qXBdKM03m4nI/ZP6CWU5pk8faSMtSGmulKodth1+PPPPPPPPPPPPPPPPPPPFYRwgoTblmmOlTIGBELWmyqQro43n49fyJKgFIPTsezY5+PHzMsuILr1Zy9COJ6b4hjMGslnvYKiguIqKgl16PPPPPPPPPPPPPPPPPPPFaUworfTjpmAhQJvki9EqJ0lpisgVmHzwxKgLjJIJOVyMweesqHtM5xH1TB8kQQ8OdCxnOF5karkqHHoKwl15fPPPPPPPPPPPPPPPPPPNRQxhudYpkhEld5VzX5VCBrks6f8A/msy9lDjggSaAiSziBQezjWQmnXMG3UdO2GKDSAdPfN8TuwpJZ6rSoJbdTzzzzzzzzzzzzzzzzzzylOtZ5njaNSLIWDFYxzZQTVj5P1dsGGZJjSscKz5jzQ89RiufNixLOcMNMftEY04y6TV9lHHAlzo446KkIrNvXzzzzzzzzzzzzzzzzzzwEusKBkH68rLB7WYi6RZCLSr6mP8x7jIb4pJiDATiCxFCDgzxGusvs6qC42uNeiYwIwllE2II4BKL6j6xaoKtTzzzzzzzzzzzzzzzzzzzMesMzwIboKSJokm62MZIz66AAqNApBtOjzQDIKisbQTyryBIrjhTuMtjCfl+J7R/ahfmu+fLjRD6ThZnb4qtTzzzzzzzzzzzzzzzzzzw9+/MwgIOab7qrpTOARLRZOIwS/J7PZYlNwySBSCTiRhTITZDrUiL0td9Enm/T+tBaIBufSpnLi5KIJbRb4Lvzzzzzzzzzzzzzzzzzzzz/P95z4s8rYATQQjCCr6CLfv/I1FddKmT3M93KvzL8t38Ku+UMXF3EWXN1dUEPeXeBDv88zorwO4Kb651b6L/wA8888888888888888888jDX/U/auOeQmm60iK4Xak+AWYK2EWGA6eeBc91eZSb0mIe22ugoOUYuWiwQ8Ob7Vx2M6xcRkQMcNse6grHjv8APPPPPPPPPPPPPPPPPPPCw955GWslmkN4eoohVNz3PeGvww1qVlOl1XFsPJ1Um7DukPjlMAq70Ep83vLnljBC75DYCiCy0UplFFsK4w3/ADzzzzzzzzzzzzzzzzzzwcP+tBoyZaYZ2OeM009mdc/rrbb46qa5hmTsYTI/RK2+/bZ+fd3uobpCCYCzg7yixtSeSSRsTd6rjQD42MMNdTzzzzzzzzzzzzzzzzzzwMP+fAgpqZpb95D4AezgI+lAagSQgB6BTb4E7JXLOU8mFjuwQHXVqxT45qSm4p/joSBKfocwK+7CgggIMssP9zzzzzzzzzzzzzzzzzzzwNf+vgS8OsqxDbzcOuyTK766BKaJQqfYqQHmPQFGAnE1eIQooN1Upb5bK7pziChQrf8ATvlzc4Pqa2MoGvj3P/8APPPPPPPPPPPPPPPPPPPA3wqiEnx3sijCur5w81+gKKAPAFMLOAr0weyeuJLv2zyDphO35SaR2sGFMn62UqhD58bTad8aWuAGCKhd/wD+vzzzzzzzzzzzzzzzzzzzwP8ADn486eaqey7nSTnAlfUUcMSIYEUokbvlBFYmwgCSMsIA6S1xWNI640AcgIIE0EP7fLd7S7+i+CyaeVb/AP4/PPPPPPPPPPPPPPPPPPPA/wAKaDZLIJLY+98ufu8OYrzL0ihTDippTAN1Wk2n7aPdnP6U0FlpRwT7rRgGCgkww8820Kynlt0wJJbLGv8A/Td8888888888888888888D/AAg6lnll0xqiUaOz5+ez05fzcTVa0zT960ec5z15/wCP8N8cnm3f3DTQDShzhxRRZ+tcthBsKPcJyjgiVP8AvTc8888888888888888888D/AAl7LkrimoY8x8A632Q5upT36cfSbzYUxbdZkV4+z/Yzx7yzRX441WL110dg0m7U530R0ywm4zjqNKh3/wD9vzzzzzzzzzzzzzzzzzzzwP8ACemXHGyPuDvbU7uSn/LDX1/LTsnfIbLwZbnbtHDLFXBm7vfjHjr0a8IQqAQ+ylnflBtnVzvEaiWiSf3z3r88888888888888888888b/AFquFv4ww3j+hj+2+9OGCNGNoJEvMsHulbFQ6p6ph/156lB9HTY5qs/6OrKIx1wuDxx01V2G4jiiliB+w969PPPPPPPPPPPPPPPPPPPP+1vvG++jlmOMP9l2hqGhgAJBDKCIHDEwbbwff46p3f8A98Odeunl+p6ON9BwRwTCKITtO/p5Cuar6whjMMNPdTzzzzzzzzzzzzzzzzzzz+trrrrpLOLTwTSBMrTwYJJ4bYBhBMRqCNVMRq6toPmeo8RpQ+kYwG63UZKf2Yq5YIBiR59TwvKaaQyyMMMP9Tzzzzzzzzzzzzzzzzzzz8P7455ZJMMZzSTS57RTjr77Zqhp7q6YT2zrQYKRtOOPv838OfcBhJqTxWHqFmwSp7hhTYoQBMqq7ogjsesNdTzzzzzzzzzzzzzzzzzzz+v6p6qYOIpzCzhRTIiTxabZJy5q4OpA3utturX80gt8WcU2UeYMieY+HnWXc7564IRSQuRRLvoLLDS6NOMN9zzzzzzzzzzzzzzzzzzzz8/a4YeI8o7Rgxj4C4JRQTxgEqrQSQxAPnHld2nm3v8Ab/1lNpxEGOVyFR+CyZyiGiPAQ/8A3C2sz/liKCO6w06/PPPPPPPPPPPPPPPPPPPP/wCsO6JcYJphqigyTZ4wRxiTRzBjzxzhCX0U0kPoHHnfl1nVEs5AhaMjf4bF2U2lNzCjaCQAzNrZJyBLvMNevzzzzzzzzzzzzzzzzzzzz/8Av/WUOO3Ps3kwqqK4Ya6KGKSuKueOkKbn/EeOuOWRlPU6aMP+miL24Pj3vS+2iXGIU440EITGymEYexvf/L88888888888888888888DD3/uMSeWTgIoSQIwoIshelP8AfeZ6kPstDIPgFFBhPKPLCLF4SzfbYnbwHOPPyvGhoMLAMDyn5svsBKHV/wD+vzzzzzzzzzzzzzzzzzzzw8d+PaqJJ68ASwjpy47By5zOFozhhKCD6b6YghAwzSS6QCAQutF7b9jHYDI1d1XBpRDgqQRJQ4L6BDAAUMN+vzzzzzzzzzzzzzzzzzzzz/8A/wC7mgky0kHMqPoJMGGJlykr+E7NBMQddh4CByJM9D2BxmKAbS7TTVaHhcO+Cd1rtJnlFBDgxkuFIEPQ8/w9PPPPPPPPPPPPPPPPPPPO8/24ps1h91H1MHGuHFIFA0fMkoH6LDMh+PenZY/uprAiWDvPgfoDt+udtIIspHygwAGqisBNbmqimDBQ1/4/PPPPPPPPPPPPPPPPPPPAw865gho0xmMPkGOvDOAKH6pkxCKGRcQHDm3rs8BJ9HMnDDFJaW2uX4OZBoFHA9cIqAOFteMgCsgviJES16w1PPPPPPPPPPPPPPPPPPPKww1zqhlhy9OmpDEprFPMd4fHPk3dd+BRmmnASFOwvFFHHMDojZr1693elrPWM3qK6pJo5GJKJlmjEFOZ/wAMNTzzzzzzzzzzzzzzzzzzz8sNdZYa+5ogRy8h8+QsaQJ5qhwyCbJQzpemJKpqbK5Ztr7b6Z2DXRigLTzd44WILCTfOMJsJPK7bJohW8+NNTzzzzzzzzzzzzzzzzzzz/8AD26ymSWqsvuuc1vnvLoIoMoUoUAm0E0CzTnuKPzDHTWCCqqW/wDEn2dLFnat6khrbYexwhf95sslkgvV/wANdTzzzzzzzzzzzzzzzzzzz/8A/OGuCCgOU2/gthjHbvnCzPf43TzbHbrE8CUGigKcC6GAAZuEuQnamCZb+VgxHhf4Lzn7HaZWOuqKmvX/AA11PPPPPPPPPPPPPPPPPPPEwwlspgHpvpivG7N8WH6/EkLDAt5IIAxLKAMLsgNAiCBFhNfJugvvLIherOxAJDUvwonGPYQcaojqmuh//wCNdTzzzzzzzzzzzzzzzzzzwMMJrZ6zSCbI88forWbMMRyIxR7iRAzgxSRT4iZDSqwQRHh4y5jDUDooI7hBwyyLhPttjsU8aia644DSXesd9TzzzzzzzzzzzzzzzzzzwMM7qhLZRjgY/UtSfUUe8CBthyzJDJiBxn3UA7RBrKK5575iYoDCQESyZ6hDXBmEQE2f8h2vKjAzQChjGuM/dTzzzzzzzzzzzzzzzzzzwMNbKb7DJSC7tZhyvvcGOCgjxgb6jqQQ1hBp7q6bDIpJCq4rDLbLLyj7Iowoq6q4jkvW3dVttkyghSRymMMv9Tzzzzzzzzzzzzzzzzzzw8tZLDrKoypbwLru0OaeLgZyiLawoC4bxzhBC6ZhiZALYhSKZKbvKAqiBAT5YSjDz+TOHkGA12GgACRwcMP+tzzzzzzzzzzzzzzzzzzzz8NZbIojzh2aSrAdvlSzPz0yQ5bbALRDhQDwYzLQq4D4qARITRKzazD6ZS4RohQwS+z+POFKjUWTBhzg8Nf/AL88888888888888888888TL+W+CA8M1aGsu8eR8w2mMgqeSEigAcEIUgiogw8Y8kkUcIA4Ysww0Qo0YAcswq8jXtAM8PDP0Ig8UI3//AP4fPPPPPPPPPPPPPPPPPPPG41kqkuBdNvN5oOFFnv8ATzCA7iriaTDiwY4q5DEBb5zp4hBLLa4QQzqYYpLpL4KuY+8b9yODEBKAgwiR9/8AvB88888888888888888888HD+KaUkkUuKAWOer8++g0g0cSc4cgcM0KSOuLieeieiKKmOKWu6WmeiquzCO/7wcAcKmOOYMacUwE0MPX/AP6/PPPPPPPPPPPPPPPPPPPH5w/sgBHGMnEqDivh+J72CSMEGFAKMEEKnvkJInJNEPCLCCrPp8LQjttdc6qh9AEOpprmhkjNijLHEEN6Y/8Avzzzzzzzzzzzzzzzzzzzw8NIqxa4/wCuCSKkZ5weKXo77ZLPqT7zL3skIkYIYFoRJtP9k0fBpZhAoQgkqPbaqliWor7wq8OKg0QA4Nlbj/8APPPPPPPPPPPPPPPPPPPCw/qsxoniuCAmsH0xCsgQEcWVBXSZNKCaNFc6JFIlJiLGttvvvPEtrsvprqmlrlDKJzUa2w3gqDCNEECYww//ADzzzzzzzzzzzzzzzzzzy8tZY2BG1cyI5Zwb6y/lMS2edNfs98JtPMc6sP8ADi7v/fjHn/Xbq7jO8biT+OmO2EeJJBFf9ogw4AA8I73PDfU8888888888888888888/v2GGmUAI6eIoqDnjBpJshxrFDDl1sd1VFqtZZ1lJhdJp9RZVthgIcophJ8A0SIGE4AYscg00SCyw04jv/AD13PPPPPPPPPPPPPPPPPPPP63gvqGIGYsjLKnHizYVWqfXcTTVbYXXcYV6eWRURw2FBHKBUdnJQzfAsBLhDs4gmCmgKJIqetiHDHCGd/wCPdTzzzzzzzzzzzzzzzzzzzevYao6ywAoyA4+LAIr1boXU3EPGGh3GHXxw5SGnA3T3AhCThjTjzjQQxQhBRW7YA0mIDBZCvRwzAyCgnusNdTzzzzzzzzzzzzzzzzzzwtcNJph2VkoSy6o6iJWXA5E11303kyH1Xz4IliWVSWQ7oqBIAQQKgAygjRTj2576KT46Cijb3LhChiwTAu8NdTzzzzzzzzzzzzzzzzzzz9tbKbjyjTopJ81LSEp7Bz40lkIEc6eXD3GjH0FXH3H4qY7YwbIYr6qIYa751lqzIphZaj3KHdKQTRDiWMNv9zzzzzzzzzzzzzzzzzzzzsPooYIhiSIiNqLGG4ShD5ogVdrEA06n04QFiZwSrpzqIVdLoYq46J5r7hY7shwbA8sDQG8wd67DTCjQUsMf/TzzzzzzzzzzzzzzzzzzzsOqIbSpixjzXiBGmwyTyIwQByyExhzD4i6Ahy7QRgJYxAR6DQyABrBThRDRAoK4iXPDdcmu9igiQzijGs//APU8888888888888888888fLqGyYg8I8QyyPe7GmYweqZ4W6077ie00+YiEaOUg8Mwc8UkUU0MMQygc0AQIgykQubOi2cnMNE08YEjrPP/U88888888888888888887LqWOaKWKKEPw2ZNr20QycVGUgm02AY0QtYk4ACSo4wIOyEqUcooQ4diEGC+SgdoYenzCMMIA2ywk8qf8A/wD/APU8888888888888888888frii6ySiCS17X/ABY/mx7JmuuupMfkpMomr3houEhNitvivhkSgZXeSYoIFQfemkIU72a0x+z7BvtPFEg/7y31PPPPPPPPPPPPPPPPPPPP610jsAvujrU8c4a7VbKLivPvMHTsLp8LJANjjIFMDHKApKddcU8vLGXYls6/aqYV451TU461CBoIhinv/wD/APU8888888888888888888/7G+SGlemqUtDLvskuyIW1l99ONVVh1NZf3rr3rnDSiuWPO6cpLLPimrFtpRTf6UXdnnZ5rH8+qAsO+J//AP8A9Tzzzzzzzzzzzzzzzzzzz+uuwxRy4KKncleNJ7v5wIwgSDWlm1X22vPuY59r6556qLYJrWqoBrJpNK5S2A9sm+/+HAQcdy7Zo5jd/f8A73U8888888888888888888/rqqmowHDKceDWzN75rSqyi4SqKu+iygkqUUk6EE+KAGYo6V3hNie8Ug3IpjF6aMz7tDsDDjgeeeGU+AX/AA11PPPPPPPPPPPPPPPPPPPF66vjnvkq2nH6547yUHLnLgHjnhnrobhrGqDpEynEmgIJpF2c2fSQPX/hTe+2ANrL/wAfXUXnOjooJILizMMdNzzzzzzzzzzzzzzzzzzzxe9cZjqY7qYABtp/dIyRx+IQJ4RSpWK5S7DACyoEiJIxhzwNO3vdlRBiJAejCQA15CskNTeusBbaLnRRA9MMNzzzzzzzzzzzzzzzzzzzwTtdJ3xap4YQTCyMfKDwgWYxY4SZEZ6erhp4pIpTqvaaJ2bNviLbrccZ58m+mdbX/hyTrNL6gyIZpoSBv+sMPzzzzzzzzzzzzzzzzzzzwDtcKRSRqJ5GxyDQbQAQBAghwbQ7QLXElLYpGWiS1mHHlhJBWAdOnQZ/hcgT69G0HSpzTddS7yo54ZrwtOP8vzzzzzzzzzzzzzzzzzzzyPddpGYrr69h76rcuBgLbAI6Iihjoor6FpIJIgsBJv0EF0FgaXrJyseUVaXxSEh2kyyhzZTAZyPpp7ZZOMPevzzzzzzzzzzzzzzzzzzzy1derUgbus/3B764Xiwz8ZT7MBqxjoZqwS5QCfZ6uzEWX+D8HPMvgxexu7yDmmHDUxAjLvASRj4Karro88PePzzzzzzzzzzzzzzzzzzzytcNa3KbveN3ixrADBDzKAsZfJqK/UNrqtHudqF00qRCSLvW8Z/ZuY1MrLGB3iHWGZ5KKyTo6hpp7LqaPed8vTzzzzzzzzzzzzzzzzzzz8utJRaJ7ca03BiRQxzZXm3ExBwxUEHqA+vvNsdtOtqpjKI7pQ5bN0hLLuNuAGk8SwAgA5qAfzrJJCSMNcN+Pzzzzzzzzzzzzzzzzzzzz+vtYm7boJrVHIRj7TRyCq6LIJ6Lr4L4Tg2dEEFn0V0M0WqKI+b2p3+etoMGX1NyjjwxzT4gNx4I76TIrMMMPzzzzzzzzzzzzzzzzzzzytNONXLorZOERyoZBjxywLbKgH4zRqa4HwHVVmyXxXEW0VKqJpzx+PopJupzKPXGggzoYCzjgT47arIdnc899TzzzzzzzzzzzzzzzzzzwkUteQqaqqYz+gSNBi84gft5gTgh05YIhr3Z6qglJm2G1r9v2Y5lMT5uo45/2+2lgheYaQgRIR54ZBQKl+Nv9TzzzzzzzzzzzzzzzzzzxH30cmrKbrpkDSp/wjhixepJMop+X/d/8UEkGe418duvP3up3J7XJkcD7mgEzTgWSjAwZ7Traz55qTBind899TzzzzzzzzzzzzzzzzzzwHW2Nmyyso7SByT/AMocy0QgHo80PNeZt9Xvednjpt5XZzbmZLvEAaO8AQkY8f8A0S5J5EuCnBKDNo2NNPG939/1PPPPPPPPPPPPPPPPPPPKQcS/6Y17+yBKvFc1PlFJkhAoMP41CAnjhsfX9lk2nIboLAof+h9mJLMOHNiKFFNJXCWe4SXzTnjoFgt/3711PPPPPPPPPPPPPPPPPPPPwUQ/KihogpTcFy60ouMAkptmkriAgumAtBGoorIrhTHSExAmlDIuKtHmmiqqsPg89G/5zWcadpikthk//wB/9Tzzzzzzzzzzzzzzzzzzz+/teiI/kM/++NzWOIMXz3Mmn1V1AHF3xTQ4TCaCbgKQygAzw4r7SSiAyCRQBJCg+v8AbvbP1vUqc0Mkm2X/AP8A9zzzzzzzzzzzzzzzzzzzz/v+sF64X11dMO9efOOtF5pz6SkFYh394oiBDCihyqTZZCiR2GzQbKaowqaa/vqrO+v/ADLLDzd6MU4ojf3/AP33fPPPPPPPPPPPPPPPPPPO861wborukif7QrFR61wCAIOMJCNHFDNHnKuhHFoiKpvFrOvtsoksALNFKBEABGByw48xIc/4UiqhKBk8d/8A/wA8888888888888888888HD3TkKzTe6thJZYT/9zIUsJ7nSPHFamsOIoKiosuvp5aGcyHRFZJWqS33zKXbzzUzRPng83LtamqMK3LJXjDo8888888888888888888THXjX8mGGKhjnlzp/hXUAU8Q0Ic84lQscQ0uYIkYhHQuU4YO6fn26QUY0YgUYAMDrt1vX3Np4SaymGC3N3LDg8888888888888888888DLXHH4MM6W53PfjjoDTAW+0GsiX3mKWweV/mS+JRx55Ui1eytfbDW0X3+0qvSyqlftdHD3l9RSS+0i63/XXvA8888888888888888888LDXzrE8kqH3zDPbbpHpsvsRgE88wUV+g82xSav5GCjwKE6GEZxlaTM6SgAKSasQv5xldRjvR5CuOe+Drh7X/o8888888888888888888/rXDLUICO+5gu1JHBkwM24oWKOGA4sSiT0zJCimC1JleetZeyPOs80wEIZOaU0hPlp9pJJRMwoSK6qCn1/XTp8888888888888888888/7XPxo4O2uhXKjzYloM4qEYMw84QM0UoysWl5lA9cCyAgEIQYs8YIcQk82WvHyKk6JRfrZxgAs2amyu+TnrDh8888888888888888888//AA84SJrtlnB7fHiuAyefcceLSXdSYVZQbSX9VSIwAjceojUZQdfUEc9medJNVVabRX6tg1ScfLmrlkop2x/3fPPPPPPPPPPPPPPPPPPM/wCu+cBoYYzxleZYZzXXgbHnUxH/ABmpv6Hd0NwVpxhtRwxZd99dFcn3pRrjP4OMwzlbpO8kZdRm2XKKTIb7bT18888888888888888888H/AKy+xJvqrHYNXFCvmKKxYhCJEkBEBFHPMNANAANBYBNEIMjrlpoiksxsoktulhNbQLHgkPG62SiierhYw4z3fPPPPPPPPPPPPPPPPPPN/wCvfYCIb7ByRzp5Ic1pDMc1p7OvH+UgqyDzbfOtsng2kU9JAIQKBX86OdFfOD1+tSLq4QLo3/TqZorCTdtf/wB8888888888888888888DDr/T4eqCoEw/xpYUhAHkvtsvnDDOI2ZcUYEYYMYv5p4AQI0Ms2XfPw4vvZJc13/YU2auiWeDiqWKqz4/7/wD+fPPPPPPPPPPPPPPPPPPAw147/MqprPsER/w64ziKpH/ewx+Eqa/yHDFMHMFAw/ITq/8AsfSXl/8AGE9z7VvTTYHQkOLTUE4tGeeGfsj7rPB8888888888888888888DDXXDw6avgQvlSMITVowc+4NnXjyq7jL/ZClsQAKMYUocMYwnrzPDifAc7fT/86Q24X3B97qBkyq/KHuDXX+p8888888888888888888fzX/vyi2K0q7t8vqx94UoeaDjf1T3da7fo0wAMAoyka2o+kIybBFnnPPLBlx9GGJxlzF3ZzHBsK62Eo/XLfep8888888888888888888/PXLH2uUe02FhDf/Jfy0EfP/nN9hDEvIkKk8yMc2s8Yw6aUIgQNnujb1LLd5xlIhME37bTFnJkCrGmLD/v6SB8888888888888888888H/AH81TNgpvMusWaTUcNhl46OEby1Xu30GODBsFGAEDRHBG4JEC4A870yT66R+8xbXbWZe6V7jiZ72+m6b16ggfPPPPPPPPPPPPPPPPPPA36w52MEk3JNkvL5zjrpl+Vgx6VV0YestNvZye24b68W8aT37bz+6bRZVZRR12czcFfy3w4Nn3Hmup81d14ggfPPPPPPPPPPPPPPPPPPA0y75yDn/AJEUhTSzjARzESSYpRwDgQjCyDQXTiAVTRyURg5bLuhYfudSASo/OsN88G2WNs0s6gWdftt6jv8ACCB8888888888888888888vLnXFyyyqb5daS22SGECu4IUAcg8UAWuaG2Gmo4YQkMMM4E+m2K+GeeWqOCOj7J/vRwFs281F5H7XnLEHvCKB8888888888888888888r/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RSlKUpSlxSlLilLilLjuZmZXgfrv6H3al2TKUv8AKR4KXFKUpfbf0Pv+L41f0Pv+L41f0PuKXNLvfopfivwUbONX9HX8G/yKM41f0VKKyURkZGRkZRRRRRRRRRGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZCMjPJ5PJHie6PIsWr+mEJsCIhPZMQhCEIQhCERERERERERERERERERERERERERERERBEREEEEEEEEkEEEYRE2f+of92f8AxM/9QAAAAAAAAAAAAAA3f+Qv/8QALBABAAIBAwMDBAMBAQEBAQAAAQARITFBURBhcYGRsaHB0fAgUOHxMEBgoP/aAAgBAQABPxD/APjurySvJK8k7x7zvHvK8krySvJK8krySvJK8krySvJK8krySvJK8krySvJ7zvHvK8krySvJK8krySvJK8krySvJK8krySvJK8krySvJK8krySvJK8krySvJK8krySvJK8krySvJK8krySvJK8krySvJK8krySvJK8krySvJK8krySvJK8krySvJK8krySvJK8krySvJK8krySvJK8krySvJKckpySnJKckpySnJKckpySnJKckpySnJKckpySnJKckpySnJKckpySnJKckpySnJKcynJK8ynJKcyvMpzKcynMpzKcynMrzK8yvMrzK8yvMrzK8yvMrzK8yvMrzK8yvMrzK8yvMrzK8yvMrzK8yvMrzK8yvMrzK8yvMrzK8yvMrzK8yvMrzK8yvMrzK8yvMrzK8yvMrzK8yvMrzK8yvMrzK8yvMpyQb/ALyv/Sv6mv8Axv8AmdLly5cvpcuXLly+lwet9L63Lly5cuXLly5cuXLly5f8BcuXLly5f8gXL/kC0tLS0vBy8vLy8vFRctFR2P6d/wDvr+mf43/K/wCVf/Df9VX/AMVRjGM0f3f/APAn/wA1/wDu9B/mx/lcuH9Bf9VrK/hUrpfVjNH93/8Awh/5X/5v/hUr+FSpXSutSutdHrXS4QPW5cuXLly//vv+B/7V/Cv/ADrrUrqnVjNH93/t6/8Ae/8A0f8A4z+Vf+FSv/Ev+mv+Vf8Aw1/8TGM0P3f+0rpX/vf8D/4q/wDlqH/lX9UP/wBFSv8A0roxjNL+rJUrpUqVKlSpUqVKlfxP/O//ALjqdK/jX8U61/8ABX86/u3oxmh+7/1VQOtQP/SfiROlSulS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Lly5fS/60mj+ov8AlX8yV/C5cvrUr/yf4kuXLly+ly5cuX1uXLly5cuX/G+ly5cuX1uX0uXLl9L63L6XLly5cvpcvpcuXLly+t9b/hcuL/I/8q/9a/8AC5cvodWXL6sro0/01v8AwQV/5AF9F5aJG5mWwP4Cv5AroqBKlSpUqVK61/CpX/jfW5fS/wCVy5cvpcvpcv8AlfW5cJcv+V/xvpcuXDrcuPW+t/0BCH/kazT/AE1eJXiV4leJXiV4leJXiV4lOJTiV4leJXiV4leJXiU4lOJTglOCU4JTgleCV4JXgleCU4JXgleCV4JXgleCV4JXgleCV4JXgleCV4JXgleCV4JTglOCU4JTglOCU4JTglOCU4JTglOCU4JTglOCU4JTglOCU4JTglOCU4JTglOCV4JXgleCV4JXgleCV4JXgleCV4JXgleCV4JXgleCV4JXgleCV4JXgleCV4JXgleCV4JXgleCV4JXgleCV4JXgleCV4JXgleCV4JXgleCV4JXgleCV4JXgleCV4JXgleCV4JXgleCV4JXgleD2naPadg9pXg9p2j2leCV4JXgleCV4JXgleCV4JXgleCV4JXgleCV4JXgleCV4JXgleCV4JXgleCV4JXgleCU4JTglOCU4JTglOCU4JTglOCU4JTglOCU4JTglOCU4JTglOCU4JTggV//AB2f/9k="
				}
			]
		},
		"tradle.OtherCollaterals": {
			"_t": "tradle.OtherCollaterals",
			"insuranceCompany": "Achmea",
			"statusOfInsurance": {
				"id": "tradle.StatusOfInsurance_a17cfd28e656a0a02713122409134ac32a5bf8d9",
				"title": "Existing Insurance"
			},
			"typeOfCoverage": {
				"id": "tradle.TypeOfCoverage_f26194465e83e4affbf081457ed00e28e8bda4e8",
				"title": "Yearly Decreasing"
			},
			"startDate": "4/11/2015",
			"yearsOfInsurance": 40,
			"amountToTransfer": {
				"value": "200000",
				"currency": "€"
			},
			"policyNumber": "123WEI7H",
			"insuredAmount": {
				"value": "300000",
				"currency": "€"
			},
			"endDate": "4/11/2040"
		},
		"tradle.ObligationsDebts": {
			"_t": "tradle.ObligationsDebts",
			"kindOfObligation": {
				"id": "tradle.KindOfObligation_a816b43df17930057c5be9375210330e3a0041db",
				"title": "Personal Loan"
			},
			"creditLimit": {
				"value": "200000",
				"currency": "€"
			},
			"paymentPeriod": {
				"id": "tradle.PaymentPeriod_7180e859d3faa6081961c743a1a56d2f6f8fc9a1",
				"title": "Monthly"
			},
			"endDate": "4/11/2026"
		},
		"tradle.LoanPart": {
			"_t": "tradle.LoanPart",
			"amount": {
				"value": "200000",
				"currency": "€"
			},
			"interestType": {
				"id": "tradle.InterestType_2b7612be5a8b2a0aa73fa67d9961491db5aaddc6",
				"title": "30 years fixed"
			},
			"interestPercentage": 5,
			"monthlyPayment": {
				"value": "5000",
				"currency": "€"
			},
			"monthlyPremium": {
				"value": "2000",
				"currency": "€"
			},
			"repaymentType": {
				"id": "tradle.RepaymentType_8b0b9c9b60d7567e3b2fe04d612b2140c96a7620",
				"title": "Linear"
			},
			"duration": 30
		},
		"tradle.Income": {
			"_t": "tradle.Income",
			"sourceOfIncome": {
				"id": "tradle.SourceOfIncome_7976cfa7c1e8009078d41dcce5086bed3717d2d7",
				"title": "Employed"
			},
			"nameOfEmployer": "Lindt Inc",
			"residenceOfEmployer": "US",
			"kindOfEngagement": {
				"id": "tradle.KindOfEngagement_14e3bce57cc1cf405b627fed4a3ae00977520581",
				"title": "Fulltime Employee"
			},
			"startDate": "4/11/2014",
			"grossYearlyIncome": {
				"value": "200000",
				"currency": "€"
			}
		},
		"tradle.MortgageDetail": {
			"_t": "tradle.MortgageDetail",
			"loanType": {
				"id": "tradle.LoanTypes_c1dc0d95e7ca43ccc6fe74a5ec2c92d139876b39",
				"title": "New Mortgage"
			},
			"startMortgageDate": "4/12/2016",
			"commercialProduct": {
				"id": "tradle.CommercialProduct_10989b6af5f7317fd251384714b904f74a8f0e26",
				"title": "Obvion"
			},
			"mortgageGuarantee": {
				"id": "tradle.MortgageGuarantee_0a351c343e0bf74ba4c21c18e79d8e6f7a6e6b1b",
				"title": "No"
			},
			"totalAmount": {
				"value": "250000",
				"currency": "€"
			},
			"intermediary": "intermediary",
			"notary": "notary",
			"duration": 30
		},
		"tradle.ORV": {
			"_t": "tradle.ORV",
			"startDate": "4/11/2015",
			"endDate": "4/11/2015",
			"insuredAmount": {
				"value": "1000000"
			},
			"typeOfCoverage": {
				"id": "tradle.TypeOfCoverage_f26194465e83e4affbf081457ed00e28e8bda4e8",
				"title": "Yearly Decreasing"
			},
			"beneficiary": "Eunice van der Linden",
			"nonSmokersTariff": true,
			"bankAccountNumber": "123456"
		},
		"tradle.AboutYou": {
			"dependants": 1,
			"residentialStatus": {
				"title": "Living with parents",
				"id": "tradle.ResidentialStatus_2e980aba65b66702cb2f7fa92f9575b4f3d4f6eb_2e980aba65b66702cb2f7fa92f9575b4f3d4f6eb"
			},
			"maritalStatus": {
				"title": "Married / civil partnership",
				"id": "tradle.MaritalStatus_36dc78aac69ade995b595079c57cdd5d954f16ac_36dc78aac69ade995b595079c57cdd5d954f16ac"
			},
			"nationality": {
				"title": "American",
				"id": "tradle.Nationality_3adb8e0d4833c55d836d7fb3b8c2891da3d07216_3adb8e0d4833c55d836d7fb3b8c2891da3d07216"
			},
			"countryOfBirth": {
				"title": "US",
				"id": "tradle.Country_b424fcc35801022868a5285956805e8e9e0bb31a_b424fcc35801022868a5285956805e8e9e0bb31a"
			},
			"taxResidency": {
				"title": "UK",
				"id": "tradle.Country_754ced1dd19fb8d61987952060b02fa0cb6d7041_754ced1dd19fb8d61987952060b02fa0cb6d7041"
			},
			"fundAccount": {
				"title": "Cash",
				"id": "tradle.HowToFund_928ac6d8a07b31d14735cfd7fa45949d1a4844c7_928ac6d8a07b31d14735cfd7fa45949d1a4844c7"
			},
			"purposeOfTheAccount": {
				"title": "Spending money",
				"id": "tradle.PurposeOfTheAccount_3cbe03f6a729ff73b608bc0fa24494844466e17a_3cbe03f6a729ff73b608bc0fa24494844466e17a"
			},
			"emailAddress": "mark@tradle.io",
			"phones": [
				{
					"number": "12345123456",
					"phoneType": {
						"id": "tradle.PhoneType_4b3d018c5085bc93de73405760a5d2fbcbef6c78",
						"title": "Mobile"
					}
				}
			]
		},
		"tradle.MortgageLoanDetail": {
			"purposeOfMortgageLoan": {
				"title": "Buy your first home",
				"id": "tradle.PurposeOfMortgageLoan_8b8b536b72fcf7b9d4d632209e28da56fe412f12_8b8b536b72fcf7b9d4d632209e28da56fe412f12"
			},
			"propertyStreetAddress": "34 South Hill Road",
			"region": "Gravesend",
			"city": "Kent",
			"postalCode": "DA12 1JX",
			"country": {
				"title": "UK",
				"id": "tradle.Country_754ced1dd19fb8d61987952060b02fa0cb6d7041_754ced1dd19fb8d61987952060b02fa0cb6d7041"
			},
			"propertyType": {
				"title": "Right to Buy",
				"id": "tradle.PropertyType_5b129ede14b65b25afcf72ac3727d78d0b9d8257_5b129ede14b65b25afcf72ac3727d78d0b9d8257"
			},
			"sizeOfProperty": "2700",
			"totalAmountRequired": {
				"value": 100000
			},
			"totalValueOfProperty": {
				"value": 500000
			}
		},
		"tradle.LicenseVerification": {
			"licenseNumber": "VAYNGRIB729049J09UR 24",
			"surname": "Vayngrib",
			"givenName": "Mark",
			"dateOfBirth": "4/2/1979",
			"dateOfIssue": "6/10/2012",
			"dateOfExpiry": "6/11/2022",
			"issuingAuthority": "DVLA",
			"holderAddress": "34 South Hill Road, Gravesend, Kent DA12 1JX",
			"entitlementCategories": "B,BE,C1,C1E,D1,D1E"
		},
		"tradle.UtilityBillVerification": {
			"issuedBy": "United Utilities",
			"firstName": "Mark",
			"lastName": "Vayngrib",
			"city": "London",
			"country": {
				"title": "UK",
				"id": "tradle.Country_754ced1dd19fb8d61987952060b02fa0cb6d7041_754ced1dd19fb8d61987952060b02fa0cb6d7041"
			},
			"postalCode": "DA12 1JX",
			"billDate": "10/10/2015",
			"region": "Kent",
			"street": "34 South Hill Road"
		},
		"tradle.YourMoney": {
			"employer": "SBC",
			"howLongHaveYouWorkedHere": 5,
			"monthlyIncome": {
				"value": 100000
			}
		},
		"tradle.ApplicationForEResidency": {
			"firstName": "Sim",
			"lastName": "K",
			"countryOfBirth": {
				"id": "tradle.Country_b424fcc35801022868a5285956805e8e9e0bb31a",
				"title": "US"
			},
			"message": "",
			"citizenship": {
				"id": "tradle.Country_b424fcc35801022868a5285956805e8e9e0bb31a",
				"title": "US"
			},
			"dateOfBirth": "05/05/1986",
			"sex": {
				"id": "tradle.Sex_cebcb4db2796c1906d67793d6f00d977fce9f8ca",
				"title": "Male"
			}
		},
		"tradle.ContactInformation": {
			"country": {
				"id": "tradle.Country_b424fcc35801022868a5285956805e8e9e0bb31a",
				"title": "US"
			},
			"message": "",
			"streetAddress": "1023 Broadway",
			"city": "New York",
			"postalCode": "10001",
			"email": "a@a.com",
			"confirmEmail": "a@a.com",
			"telephone": "212-222-3333",
			"pickupLocation": {
				"id": "tradle.Location_f8bef5eeb1ed75d9edf69f93a9f4aa3121e85d21",
				"title": "USA, New York"
			}
		},
		"tradle.IdentificationDetail": {
			"typeOfIdentityDocument": {
				"id": "tradle.IdentityDocumentType_ee443d15603d7e12b7dd2c2a5c804973733d4c41",
				"title": "Other ID document/ID card"
			},
			"message": "",
			"documentNumber": 123234,
			"issuingAuthority": "US Dept of Sate",
			"dateOfIssue": "4/26/2012",
			"dateOfExpiry": "4/26/2022",
			"issuingCountry": {
				"id": "tradle.Country_b424fcc35801022868a5285956805e8e9e0bb31a",
				"title": "US"
			}
		},
		"tradle.CompanyInformation": {
			"legalName": "Transpacific Underwritiers Inc (123456ABCD)",
			"tradingName": "Transpacific Underwritiers Inc (123456ABCD)",
			"r_street": "1234 Broadway",
			"r_city": "Montgomery",
			"r_country": {
				"id": "tradle.Country_b424fcc35801022868a5285956805e8e9e0bb31a",
				"title": "US"
			},
			"r_postalCode": "36105",
			"r_region": "AL",
			"t_street": "1234 Lincoln St",
			"t_city": "Montgomery",
			"t_country": {
				"id": "tradle.Country_b424fcc35801022868a5285956805e8e9e0bb31a",
				"title": "US"
			},
			"t_postalCode": "36105",
			"t_region": "AL",
			"p_street": "1234 Broadway",
			"p_city": "Montgomery",
			"p_country": {
				"id": "tradle.Country_b424fcc35801022868a5285956805e8e9e0bb31a",
				"title": "US"
			},
			"p_postalCode": "36105",
			"p_region": "AL",
			"coverHolderContactInformation": "Phone 334-222-3333",
			"webSite": "tu.com"
		},
		"tradle.ProfessionalIndemnity": {
			"name": "Transpacific Underwritiers Inc (123456ABCD)",
			"periodOfCover": "from Sep 28 2015 to Sep 28 2016",
			"coverBinding": true,
			"piInsurerName": "Aardvark Insurance Company",
			"startDateOfCover": "09/28/2015",
			"expiryDateOfCover": "09/28/2016",
			"currency": {
				"id": "tradle.Currency_efb585b2d312810c60a9d3b75d80be980b2b9ff9",
				"title": "US Dollar"
			},
			"message": "",
			"limitIL": {
				"value": "1000000",
				"currency": "$"
			},
			"limitAL": {
				"value": "2000000",
				"currency": "$"
			},
			"deductible": {
				"value": "10000",
				"currency": "$"
			},
			"policyCoverActsOfDishonestyByEmployees": true,
			"fidelityInsurancePolicy": false,
			"additionalLinesOfPIcover": false,
			"detailsOfAdditionalLinesOfPIcover": "No details",
			"numberOfPIclaims": 1
		},
		"tradle.Licences": {
			"name": "Transpacific Underwritiers Inc (123456ABCD)",
			"territory": "Alabama, USA",
			"regulator": "Alabama Insurance Dept",
			"licenceName": "Alabama Insurance Licence",
			"licenceNumber": "123876",
			"nameOfLicence": "Alan David Jones",
			"expiryDate": "09/29/2017"
		},
		"tradle.KeyStaff": {
			"title": "Mr",
			"firstName": "Colin",
			"lastName": "Jonson",
			"role": "Issuing documentation"
		},
		"tradle.Financials": {
			"accountingPeriodFrom": "9/28/2015",
			"accountingPeriodTo": "9/28/2017",
			"theseAccountsAre": "Management Accounts",
			"currency": {
				"id": "tradle.Currency_efb585b2d312810c60a9d3b75d80be980b2b9ff9",
				"title": "US Dollar"
			},
			"companyLegalStatus": "Inc"
		},
		"tradle.IndividualOwners": {
			"firstName": "Trevor",
			"lastName": "Maddison",
			"nationality": {
				"id": "tradle.Nationality_3adb8e0d4833c55d836d7fb3b8c2891da3d07216",
				"title": "American"
			},
			"message": "",
			"startDate": "9/28/1996",
			"shareholding": 100,
			"dateOfBirth": "9/28/1971"
		}
	};

/***/ },

/***/ 1652:
/***/ function(module, exports, __webpack_require__) {

	const staticData = [
	  __webpack_require__(1653),
	  __webpack_require__(1654),
	  __webpack_require__(1655),
	  __webpack_require__(1656),
	  __webpack_require__(1657),
	  __webpack_require__(1658),
	  __webpack_require__(1659),
	  __webpack_require__(1660)
	]
	const resources = [
	{
	  _t: 'tradle.ResidentialStatus',
	  status: 'Home owner (with mortgage)'
	},
	{
	  _t: 'tradle.ResidentialStatus',
	  status: 'Home owner (without mortgage)',
	},
	{
	  _t: 'tradle.ResidentialStatus',
	  status: 'Tenant (private)',
	},
	{
	  _t: 'tradle.ResidentialStatus',
	  status: 'Tenant (counsel)',
	},
	{
	  _t: 'tradle.ResidentialStatus',
	  status: 'Living with parents'
	},
	{
	  _t: 'tradle.MaritalStatus',
	  status: 'Single',
	},
	{
	  _t: 'tradle.MaritalStatus',
	  status: 'Married',
	},
	{
	  _t: 'tradle.MaritalStatus',
	  status: "Married with prenuptial agreement"
	},
	{
	  _t: 'tradle.MaritalStatus',
	  status: 'Civil partnership'
	},
	{
	  _t: 'tradle.MaritalStatus',
	  status: 'Living together with agreement'
	},
	{
	  _t: 'tradle.EducationNL',
	  education: 'Elementary School'
	},
	{
	  _t: 'tradle.EducationNL',
	  education: 'High School'
	},
	{
	  _t: 'tradle.EducationNL',
	  education: 'Vocational Secondary School (Junior)'  // LBO
	},
	{
	  _t: 'tradle.EducationNL',
	  education: 'Vocational Secondary School (Senior)'  // MBO
	},
	{
	  _t: 'tradle.EducationNL',
	  education: 'College'                               // HBO
	},
	{
	  _t: 'tradle.EducationNL',
	  education: 'University'
	},
	{
	  _t: 'tradle.IDCardType',
	  idCardType: 'Valid Passport'
	},
	// {
	//   _t: 'tradle.IDCardType',
	//   idCardType: 'ID Card'
	// },
	{
	  _t: 'tradle.IDCardType',
	  idCardType: 'Valid Driver Licence'
	},
	// {
	//   _t: "tradle.IDCardType",
	//   idCardType: 'Residence permit'
	// },
	{
	  _t: 'tradle.SourceOfIncome',
	  sourceOfIncome: 'Employed'
	},
	{
	  _t: 'tradle.SourceOfIncome',
	  sourceOfIncome: 'Self-Employed'
	},
	{
	  _t: 'tradle.SourceOfIncome',
	  sourceOfIncome: 'Alimony'
	},
	{
	  _t: 'tradle.SourceOfIncome',
	  sourceOfIncome: 'Income Out Of Renting Or Leasing'
	},
	{
	  _t: 'tradle.SourceOfIncome',
	  sourceOfIncome: 'Pension'
	},
	{
	  _t: 'tradle.SourceOfIncome',
	  sourceOfIncome: 'Pre-Pension'
	},
	{
	  _t: 'tradle.SourceOfIncome',
	  sourceOfIncome: 'Old age benefits'
	},
	{
	  _t: 'tradle.SourceOfIncome',
	  sourceOfIncome: 'Insurance Policy / Pension (Out Of Insurance)'
	},
	{
	  _t: 'tradle.KindOfEngagement',
	  kindOfEngagement: 'Fulltime Employee'
	},
	{
	  _t: 'tradle.KindOfEngagement',
	  kindOfEngagement: 'Temporary Employment'
	},
	{
	  _t: 'tradle.KindOfEngagement',
	  kindOfEngagement: 'Flex Encome'
	},
	{
	  _t: "tradle.KindOfConstruction",
	  kindOfConstruction: "Existing house"
	},
	{
	  _t: "tradle.KindOfConstruction",
	  kindOfConstruction: "New house"
	},
	{
	  _t: "tradle.KindOfConstruction",
	  kindOfConstruction: "Build it your self"
	},
	{
	  _t: "tradle.KindOfHouse",
	  kindOfHouse: "Detached"
	},
	{
	  _t: "tradle.KindOfHouse",
	  kindOfHouse: "Semi-Detached"
	},
	{
	  _t: "tradle.KindOfHouse",
	  kindOfHouse: "Terraced house"
	},
	{
	  _t: "tradle.KindOfHouse",
	  kindOfHouse: "Appartment"
	},
	{ _t: "tradle.MortgageGuarantee",
	  mortgageGuarantee: "No"
	},
	{ _t: "tradle.MortgageGuarantee",
	  mortgageGuarantee: "NHG"
	},
	{ _t: "tradle.MortgageGuarantee",
	  mortgageGuarantee: "Gemeente Garantie"
	},
	{
	  _t: "tradle.KindOfObligation",
	  kindOfObligation: "Partner alimony"
	},
	{
	  _t: "tradle.KindOfObligation",
	  kindOfObligation: "Revolving Credit"
	},
	{
	  _t: "tradle.KindOfObligation",
	  kindOfObligation: "Personal Loan"
	},
	{
	  _t: "tradle.KindOfObligation",
	  kindOfObligation: "Overdraw"
	},
	{
	  _t: "tradle.KindOfObligation",
	  kindOfObligation: "Credit card"
	},
	{
	  _t: "tradle.KindOfObligation",
	  kindOfObligation: "Partner alimony"
	},
	{
	  _t: "tradle.KindOfObligation",
	  kindOfObligation: "Shopping credit"
	},
	{
	  _t: "tradle.KindOfObligation",
	  kindOfObligation: "Private Loan"
	},
	{
	  _t: "tradle.KindOfObligation",
	  kindOfObligation: "Study Loan"
	},
	{
	  _t: "tradle.PaymentPeriod",
	  paymentPeriod: "Monthly"
	},
	{
	  _t: "tradle.PaymentPeriod",
	  paymentPeriod: "Quarterly"
	},
	{
	  _t: "tradle.PaymentPeriod",
	  paymentPeriod: "Half Yearly"
	},
	{
	  _t: "tradle.PaymentPeriod",
	  paymentPeriod: "Yearly"
	},
	{
	  _t: "tradle.EnergyLabel",
	  energyLabel: "A"
	},
	{
	  _t: "tradle.EnergyLabel",
	  energyLabel: "B"
	},
	{
	  _t: "tradle.EnergyLabel",
	  energyLabel: "C"
	},
	{
	  _t: "tradle.EnergyLabel",
	  energyLabel: "D"
	},
	{
	  _t: "tradle.EnergyLabel",
	  energyLabel: "E"
	},
	{
	  _t: "tradle.EnergyLabel",
	  energyLabel: "F"
	},
	{
	  _t: "tradle.EnergyLabel",
	  energyLabel: "G"
	},
	{
	  _t: "tradle.StatusOfInsurance",
	  statusOfInsurance: "Existing Insurance"
	},
	{
	  _t: "tradle.StatusOfInsurance",
	  statusOfInsurance: "Temporary Coverage"
	},
	{
	  _t: "tradle.StatusOfInsurance",
	  statusOfInsurance: "To Be Arranged"
	},
	{
	  _t: "tradle.TypeOfCoverage",
	  typeOfCoverage: "Equal Over Time"
	},
	{
	  _t: "tradle.TypeOfCoverage",
	  typeOfCoverage: "Yearly Decreasing"
	},
	{
	  _t: "tradle.TypeOfCoverage",
	  typeOfCoverage: "Linearly Decreasing"
	},
	{
	  _t: 'tradle.PropertyType',
	  propertyType: 'Freehold'
	},
	{
	  _t: 'tradle.PropertyType',
	  propertyType: 'Leasehold'
	},
	{
	  _t: 'tradle.PropertyType',
	  propertyType: 'New build or converted properties'
	},
	{
	  _t: 'tradle.PropertyType',
	  propertyType: 'Shared equity'
	},
	{
	  _t: 'tradle.PropertyType',
	  propertyType: 'Shared ownership'
	},
	{
	  _t: 'tradle.PropertyType',
	  propertyType: 'Right to Buy'
	},
	{
	  _t: 'tradle.PropertyType',
	  propertyType: 'Buy to let'
	},
	{
	  _t: 'tradle.PropertyTypes',
	  propertyType: 'Single Family House'
	},
	{
	  _t: 'tradle.PropertyTypes',
	  propertyType: 'Condominium'
	},
	{
	  _t: 'tradle.PropertyTypes',
	  propertyType: 'Duplex'
	},
	{
	  _t: 'tradle.PropertyTypes',
	  propertyType: 'High Volume Home'
	},
	{
	  _t: 'tradle.PropertyTypes',
	  propertyType: 'Vacation Home'
	},
	{
	  _t: 'tradle.PropertyTypes',
	  propertyType: 'Farm'
	},
	{
	  _t: 'tradle.PropertyTypes',
	  propertyType: 'Land'
	},
	{
	  _t: 'tradle.PurposeOfMortgageLoan',
	  purpose: 'Buy your first home'
	},
	
	{
	  _t: 'tradle.PurposeOfMortgageLoan',
	  purpose: 'Move home'
	},
	{
	  _t: 'tradle.PurposeOfMortgageLoan',
	  purpose: 'Find a new mortgage deal'
	},
	
	{
	  _t: 'tradle.PurposeOfMortgageLoan',
	  purpose: 'Buying to let'
	},
	{
	  _t: 'tradle.PurposeOfMortgageLoan',
	  purpose: 'Borrowing more'
	},
	{
	  _t: 'tradle.Language',
	  language: 'English',
	  code: 'en'
	},
	{
	  _t: 'tradle.Language',
	  language: 'Dutch',
	  code: 'nl'
	},
	{
	  _t: 'tradle.HowToFund',
	  howToFund: 'Cash',
	},
	{
	  _t: 'tradle.HowToFund',
	  howToFund: 'Check',
	},
	{
	  _t: 'tradle.HowToFund',
	  howToFund: 'Direct to Bank'
	},
	{
	  _t: 'tradle.PhoneTypes',
	  phoneType: 'Home'
	},
	{
	  _t: 'tradle.PhoneTypes',
	  phoneType: 'Mobile',
	},
	{
	  _t: 'tradle.PhoneTypes',
	  phoneType: 'Work',
	},
	{
	  _t: 'tradle.CommercialProduct',
	  productType: 'Obvion'
	},
	{
	  _t: 'tradle.CommercialProduct',
	  productType: 'Basis'
	},
	{
	  _t: 'tradle.CommercialProduct',
	  productType: 'Compact'
	},
	{
	  _t: 'tradle.CommercialProduct',
	  productType: 'ABP'
	},
	{
	  _t: 'tradle.RepaymentType',
	  repaymentType: 'Annuity'
	},
	{
	  _t: 'tradle.RepaymentType',
	  repaymentType: 'Linear'
	},
	{
	  _t: 'tradle.RepaymentType',
	  repaymentType: 'Interest Only'
	},
	{
	  _t: 'tradle.LoanTypes',
	  loanType: 'New Mortgage'
	},
	{
	  _t: 'tradle.LoanTypes',
	  loanType: 'Second Mortgage'
	},
	{
	  _t: 'tradle.LoanTypes',
	  loanType: 'Additional Mortgage Within Existing Contract'
	},
	{
	  _t: 'tradle.LoanTypes',
	  loanType: 'Coming Form Other Mortgage Supplier'
	},
	{
	  _t: 'tradle.LoanTypes',
	  loanType: 'Change Mortgage Construction'
	},
	{
	  _t: 'tradle.InterestType',
	  interestType: '30 years fixed'
	},
	{
	  _t: 'tradle.InterestType',
	  interestType: '15 years fixed'
	},
	{
	  _t: 'tradle.InterestType',
	  interestType: '10 years fixed'
	},
	{
	  _t: 'tradle.InterestType',
	  interestType: '5 adjustable'
	},
	{
	  _t: 'tradle.InterestType',
	  interestType: 'Variable'
	},
	{
	  _t: 'tradle.ContractType',
	  contractType: 'fixed'
	},
	{
	  _t: 'tradle.ContractType',
	  contractType: 'self-employed'
	},
	{
	  _t: 'tradle.OwnershipStructure',
	  ownershipStructure: 'Sole Proprietorship'
	},
	{
	  _t: 'tradle.OwnershipStructure',
	  ownershipStructure: 'Partnership'
	},
	{
	  _t: 'tradle.OwnershipStructure',
	  ownershipStructure: 'Limited Partnership'
	},
	{
	  _t: 'tradle.OwnershipStructure',
	  ownershipStructure: 'Limited Liability Company (LLC)'
	},
	{
	  _t: 'tradle.OwnershipStructure',
	  ownershipStructure: 'Corporation (for-profit)'
	},
	{
	  _t: 'tradle.OwnershipStructure',
	  ownershipStructure: 'Nonprofit Corporation'
	},
	{
	  _t: 'tradle.OwnershipStructure',
	  ownershipStructure: 'Cooperative'
	},
	{
	  _t: 'tradle.ExemptStatus',
	  exemptStatus: 'Exempt'
	},
	{
	  _t: 'tradle.ExemptStatus',
	  exemptStatus: 'Non-Exempt'
	},
	{
	  _t: 'tradle.FormationType',
	  formationType: 'Corporation'
	},
	{
	  _t: 'tradle.FormationType',
	  formationType: 'Foreign Financial Institution'
	},
	{
	  _t: 'tradle.FormationType',
	  formationType: 'Fund'
	},
	{
	  _t: 'tradle.FormationType',
	  formationType: 'Government'
	},
	{
	  _t: 'tradle.FormationType',
	  formationType: 'Investment Advisor'
	},
	{
	  _t: 'tradle.FormationType',
	  formationType: 'NGO Charity'
	},
	{
	  _t: 'tradle.FormationType',
	  formationType: 'Partnership'
	},
	{
	  _t: 'tradle.FormationType',
	  formationType: 'Sole Proprietorship or Individual'
	},
	{
	  _t: 'tradle.FormationType',
	  formationType: 'Special Purpose Vehicle'
	},
	{
	  _t: 'tradle.FormationType',
	  formationType: 'Trust'
	},
	{
	  _t: 'tradle.AddressType',
	  addressType: 'Physical'
	},
	{
	  _t: 'tradle.GovernmentIdType',
	  governmentIdType: 'U.S. Employee Identification Number'
	},
	{
	  _t: 'tradle.Regulator',
	  regulator: 'U.S. Securities and Exchange Commission'
	},
	{
	  _t: 'tradle.Exchange',
	  exchange: 'U.S. NYSE'
	},
	{
	  _t: 'tradle.Sex',
	  sex: 'Male'
	},
	{
	  _t: 'tradle.Sex',
	  sex: 'Female'
	},
	{
	  _t: "tradle.EResidencyApplicationType",
	  eResidencyApplicationType: 'First e-Residency application'
	},
	{
	  _t: "tradle.EResidencyApplicationType",
	  eResidencyApplicationType: 'Expry of documents'
	},
	{
	  _t: "tradle.EResidencyApplicationType",
	  eResidencyApplicationType: 'Data has changed'
	},
	{
	  _t: "tradle.EResidencyApplicationType",
	  eResidencyApplicationType: 'Lost, destroyed, stolen'
	},
	{
	  _t: "tradle.EResidencyApplicationType",
	  eResidencyApplicationType: 'Unusable'
	},
	
	{
	  _t: 'tradle.IdentityDocumentType',
	  documentType: 'National passport (issued by your country of citizenship)'
	},
	{
	  _t: 'tradle.IdentityDocumentType',
	  documentType: 'Other ID document/ID card'
	},
	{
	  _t: 'tradle.IdentityDocumentType',
	  documentType: 'Republic of Estonia ID'
	},
	{
	  _t: 'tradle.IdentityDocumentType',
	  documentType: 'Foreign passport (not issued by your country of citizenship)'
	},
	
	{
	  _t: 'tradle.Location',
	  location: 'Offices in Estonia'
	},
	{
	  _t: 'tradle.Location',
	  location: 'Australia, Canberra'
	},
	{
	  _t: 'tradle.Location',
	  location: 'Austia, Vienna'
	},
	{
	  _t: 'tradle.Location',
	  location: 'China, Beijing'
	},
	{
	  _t: 'tradle.Location',
	  location: 'Canada, Ottava'
	},
	{
	  _t: 'tradle.Location',
	  location: 'France, Paris'
	},
	{
	  _t: 'tradle.Location',
	  location: 'Latvia, Riga'
	},
	
	{
	  _t: 'tradle.Location',
	  location: 'UK, London'
	},
	
	{
	  _t: 'tradle.Location',
	  location: 'USA, New York'
	},
	
	{
	  _t: 'tradle.EResidencyMotivation',
	  eResidencyMotivation: 'Location independant international business'
	},
	{
	  _t: 'tradle.EResidencyMotivation',
	  eResidencyMotivation: 'Bringing business to Estonia'
	},
	{
	  _t: 'tradle.EResidencyMotivation',
	  eResidencyMotivation: 'Using the technology of secure authentication'
	},
	{
	  _t: 'tradle.EResidencyMotivation',
	  eResidencyMotivation: 'Living in or visiting Estonia'
	},
	{
	  _t: 'tradle.EResidencyMotivation',
	  eResidencyMotivation: 'Fan of e-Residency'
	},
	{
	  _t: 'tradle.ResidenceType',
	  value: 'Primary Residence'
	},
	{
	  _t: 'tradle.ResidenceType',
	  value: 'Second Home'
	},
	{
	  _t: 'tradle.ResidenceType',
	  value: 'Investment Property'
	}
	]
	
	const data = {
	  getResources() {
	    staticData.forEach(data =>  data.forEach(r => resources.push(r)))
	    return resources;
	  }
	}
	module.exports = data;


/***/ },

/***/ 1653:
/***/ function(module, exports) {

	module.exports = [
		{
			"_t": "tradle.PurposeOfTheAccount",
			"purpose": "Benefit Payments"
		},
		{
			"_t": "tradle.PurposeOfTheAccount",
			"purpose": "Bills / Expenses"
		},
		{
			"_t": "tradle.PurposeOfTheAccount",
			"purpose": "Capital Raising ( Scottish Widows Bank )"
		},
		{
			"_t": "tradle.PurposeOfTheAccount",
			"purpose": "Inheritance"
		},
		{
			"_t": "tradle.PurposeOfTheAccount",
			"purpose": "Probate / Executor / Trustee"
		},
		{
			"_t": "tradle.PurposeOfTheAccount",
			"purpose": "Salary / Pension / Other Regular Income"
		},
		{
			"_t": "tradle.PurposeOfTheAccount",
			"purpose": "Savings"
		},
		{
			"_t": "tradle.PurposeOfTheAccount",
			"purpose": "Spending money"
		},
		{
			"_t": "tradle.PurposeOfTheAccount",
			"purpose": "Student"
		}
	];

/***/ },

/***/ 1654:
/***/ function(module, exports) {

	module.exports = [
		{
			"_t": "tradle.EducationDegree",
			"educationDegree": "B.S. - Bachelor of Science"
		},
		{
			"_t": "tradle.EducationDegree",
			"educationDegree": "B.A. - Bachelor of Arts"
		},
		{
			"_t": "tradle.EducationDegree",
			"educationDegree": "B.B.A. - Bachelor of Business Administration"
		},
		{
			"_t": "tradle.EducationDegree",
			"educationDegree": "B.Arch. - Bachelor of Architecture"
		},
		{
			"_t": "tradle.EducationDegree",
			"educationDegree": "LL.M. - Master of Laws"
		},
		{
			"_t": "tradle.EducationDegree",
			"educationDegree": "M.S, - Master of Science"
		},
		{
			"_t": "tradle.EducationDegree",
			"educationDegree": "M.A. - Master of Arts"
		},
		{
			"_t": "tradle.EducationDegree",
			"educationDegree": "M.B.A - Master of Business Administration"
		},
		{
			"_t": "tradle.EducationDegree",
			"educationDegree": "M.Arch. - Master of Architecture"
		},
		{
			"_t": "tradle.EducationDegree",
			"educationDegree": "PhD. - Doctor of Philosophy"
		},
		{
			"_t": "tradle.EducationDegree",
			"educationDegree": "M.D. - Doctor of Medicine"
		}
	];

/***/ },

/***/ 1655:
/***/ function(module, exports) {

	module.exports = [
		{
			"code": "AD",
			"country": "Andorra",
			"_t": "tradle.Country"
		},
		{
			"code": "AE",
			"country": "United Arab Emirates",
			"_t": "tradle.Country"
		},
		{
			"code": "AF",
			"country": "Afghanistan",
			"_t": "tradle.Country"
		},
		{
			"code": "AG",
			"country": "Antigua and Barbuda",
			"_t": "tradle.Country"
		},
		{
			"code": "AI",
			"country": "Anguilla",
			"_t": "tradle.Country"
		},
		{
			"code": "AL",
			"country": "Albania",
			"_t": "tradle.Country"
		},
		{
			"code": "AM",
			"country": "Armenia",
			"_t": "tradle.Country"
		},
		{
			"code": "AO",
			"country": "Angola",
			"_t": "tradle.Country"
		},
		{
			"code": "AQ",
			"country": "Antarctica",
			"_t": "tradle.Country"
		},
		{
			"code": "AR",
			"country": "Argentina",
			"_t": "tradle.Country"
		},
		{
			"code": "AS",
			"country": "American Samoa",
			"_t": "tradle.Country"
		},
		{
			"code": "AT",
			"country": "Austria",
			"_t": "tradle.Country"
		},
		{
			"code": "AU",
			"country": "Australia",
			"_t": "tradle.Country"
		},
		{
			"code": "AW",
			"country": "Aruba",
			"_t": "tradle.Country"
		},
		{
			"code": "AX",
			"country": "Öland Islands",
			"_t": "tradle.Country"
		},
		{
			"code": "AZ",
			"country": "Azerbaijan",
			"_t": "tradle.Country"
		},
		{
			"code": "BA",
			"country": "Bosnia and Herzegovina",
			"_t": "tradle.Country"
		},
		{
			"code": "BB",
			"country": "Barbados",
			"_t": "tradle.Country"
		},
		{
			"code": "BD",
			"country": "Bangladesh",
			"_t": "tradle.Country"
		},
		{
			"code": "BE",
			"country": "Belgium",
			"_t": "tradle.Country"
		},
		{
			"code": "BF",
			"country": "Burkina Faso",
			"_t": "tradle.Country"
		},
		{
			"code": "BG",
			"country": "Bulgaria",
			"_t": "tradle.Country"
		},
		{
			"code": "BH",
			"country": "Bahrain",
			"_t": "tradle.Country"
		},
		{
			"code": "BI",
			"country": "Burundi",
			"_t": "tradle.Country"
		},
		{
			"code": "BJ",
			"country": "Benin",
			"_t": "tradle.Country"
		},
		{
			"code": "BL",
			"country": "Saint Barthélemy",
			"_t": "tradle.Country"
		},
		{
			"code": "BM",
			"country": "Bermuda",
			"_t": "tradle.Country"
		},
		{
			"code": "BN",
			"country": "Brunei Darussalam",
			"_t": "tradle.Country"
		},
		{
			"code": "BO",
			"country": "Bolivia",
			"_t": "tradle.Country"
		},
		{
			"code": "BQ",
			"country": "Caribbean Netherlands ",
			"_t": "tradle.Country"
		},
		{
			"code": "BR",
			"country": "Brazil",
			"_t": "tradle.Country"
		},
		{
			"code": "BS",
			"country": "Bahamas",
			"_t": "tradle.Country"
		},
		{
			"code": "BT",
			"country": "Bhutan",
			"_t": "tradle.Country"
		},
		{
			"code": "BV",
			"country": "Bouvet Island",
			"_t": "tradle.Country"
		},
		{
			"code": "BW",
			"country": "Botswana",
			"_t": "tradle.Country"
		},
		{
			"code": "BY",
			"country": "Belarus",
			"_t": "tradle.Country"
		},
		{
			"code": "BZ",
			"country": "Belize",
			"_t": "tradle.Country"
		},
		{
			"code": "CA",
			"country": "Canada",
			"_t": "tradle.Country"
		},
		{
			"code": "CC",
			"country": "Cocos (Keeling) Islands",
			"_t": "tradle.Country"
		},
		{
			"code": "CD",
			"country": "Congo, Democratic Republic of",
			"_t": "tradle.Country"
		},
		{
			"code": "CF",
			"country": "Central African Republic",
			"_t": "tradle.Country"
		},
		{
			"code": "CG",
			"country": "Congo",
			"_t": "tradle.Country"
		},
		{
			"code": "CH",
			"country": "Switzerland",
			"_t": "tradle.Country"
		},
		{
			"code": "CI",
			"country": "Côte d'Ivoire",
			"_t": "tradle.Country"
		},
		{
			"code": "CK",
			"country": "Cook Islands",
			"_t": "tradle.Country"
		},
		{
			"code": "CL",
			"country": "Chile",
			"_t": "tradle.Country"
		},
		{
			"code": "CM",
			"country": "Cameroon",
			"_t": "tradle.Country"
		},
		{
			"code": "CN",
			"country": "China",
			"_t": "tradle.Country"
		},
		{
			"code": "CO",
			"country": "Colombia",
			"_t": "tradle.Country"
		},
		{
			"code": "CR",
			"country": "Costa Rica",
			"_t": "tradle.Country"
		},
		{
			"code": "CU",
			"country": "Cuba",
			"_t": "tradle.Country"
		},
		{
			"code": "CV",
			"country": "Cape Verde",
			"_t": "tradle.Country"
		},
		{
			"code": "CW",
			"country": "Curaçao",
			"_t": "tradle.Country"
		},
		{
			"code": "CX",
			"country": "Christmas Island",
			"_t": "tradle.Country"
		},
		{
			"code": "CY",
			"country": "Cyprus",
			"_t": "tradle.Country"
		},
		{
			"code": "CZ",
			"country": "Czech Republic",
			"_t": "tradle.Country"
		},
		{
			"code": "DE",
			"country": "Germany",
			"_t": "tradle.Country"
		},
		{
			"code": "DJ",
			"country": "Djibouti",
			"_t": "tradle.Country"
		},
		{
			"code": "DK",
			"country": "Denmark",
			"_t": "tradle.Country"
		},
		{
			"code": "DM",
			"country": "Dominica",
			"_t": "tradle.Country"
		},
		{
			"code": "DO",
			"country": "Dominican Republic",
			"_t": "tradle.Country"
		},
		{
			"code": "DZ",
			"country": "Algeria",
			"_t": "tradle.Country"
		},
		{
			"code": "EC",
			"country": "Ecuador",
			"_t": "tradle.Country"
		},
		{
			"code": "EE",
			"country": "Estonia",
			"_t": "tradle.Country"
		},
		{
			"code": "EG",
			"country": "Egypt",
			"_t": "tradle.Country"
		},
		{
			"code": "EH",
			"country": "Western Sahara",
			"_t": "tradle.Country"
		},
		{
			"code": "ER",
			"country": "Eritrea",
			"_t": "tradle.Country"
		},
		{
			"code": "ES",
			"country": "Spain",
			"_t": "tradle.Country"
		},
		{
			"code": "ET",
			"country": "Ethiopia",
			"_t": "tradle.Country"
		},
		{
			"code": "FI",
			"country": "Finland",
			"_t": "tradle.Country"
		},
		{
			"code": "FJ",
			"country": "Fiji",
			"_t": "tradle.Country"
		},
		{
			"code": "FK",
			"country": "Falkland Islands",
			"_t": "tradle.Country"
		},
		{
			"code": "FM",
			"country": "Micronesia, Federated States of",
			"_t": "tradle.Country"
		},
		{
			"code": "FO",
			"country": "Faroe Islands",
			"_t": "tradle.Country"
		},
		{
			"code": "FR",
			"country": "France",
			"_t": "tradle.Country"
		},
		{
			"code": "GA",
			"country": "Gabon",
			"_t": "tradle.Country"
		},
		{
			"code": "GB",
			"country": "United Kingdom",
			"_t": "tradle.Country"
		},
		{
			"code": "GD",
			"country": "Grenada",
			"_t": "tradle.Country"
		},
		{
			"code": "GE",
			"country": "Georgia",
			"_t": "tradle.Country"
		},
		{
			"code": "GF",
			"country": "French Guiana",
			"_t": "tradle.Country"
		},
		{
			"code": "GG",
			"country": "Guernsey",
			"_t": "tradle.Country"
		},
		{
			"code": "GH",
			"country": "Ghana",
			"_t": "tradle.Country"
		},
		{
			"code": "GI",
			"country": "Gibraltar",
			"_t": "tradle.Country"
		},
		{
			"code": "GL",
			"country": "Greenland",
			"_t": "tradle.Country"
		},
		{
			"code": "GM",
			"country": "Gambia",
			"_t": "tradle.Country"
		},
		{
			"code": "GN",
			"country": "Guinea",
			"_t": "tradle.Country"
		},
		{
			"code": "GP",
			"country": "Guadeloupe",
			"_t": "tradle.Country"
		},
		{
			"code": "GQ",
			"country": "Equatorial Guinea",
			"_t": "tradle.Country"
		},
		{
			"code": "GR",
			"country": "Greece",
			"_t": "tradle.Country"
		},
		{
			"code": "GS",
			"country": "South Georgia and the South Sandwich Islands",
			"_t": "tradle.Country"
		},
		{
			"code": "GT",
			"country": "Guatemala",
			"_t": "tradle.Country"
		},
		{
			"code": "GU",
			"country": "Guam",
			"_t": "tradle.Country"
		},
		{
			"code": "GW",
			"country": "Guinea-Bissau",
			"_t": "tradle.Country"
		},
		{
			"code": "GY",
			"country": "Guyana",
			"_t": "tradle.Country"
		},
		{
			"code": "HK",
			"country": "Hong Kong",
			"_t": "tradle.Country"
		},
		{
			"code": "HM",
			"country": "Heard and McDonald Islands",
			"_t": "tradle.Country"
		},
		{
			"code": "HN",
			"country": "Honduras",
			"_t": "tradle.Country"
		},
		{
			"code": "HR",
			"country": "Croatia",
			"_t": "tradle.Country"
		},
		{
			"code": "HT",
			"country": "Haiti",
			"_t": "tradle.Country"
		},
		{
			"code": "HU",
			"country": "Hungary",
			"_t": "tradle.Country"
		},
		{
			"code": "ID",
			"country": "Indonesia",
			"_t": "tradle.Country"
		},
		{
			"code": "IE",
			"country": "Ireland",
			"_t": "tradle.Country"
		},
		{
			"code": "IL",
			"country": "Israel",
			"_t": "tradle.Country"
		},
		{
			"code": "IM",
			"country": "Isle of Man",
			"_t": "tradle.Country"
		},
		{
			"code": "IN",
			"country": "India",
			"_t": "tradle.Country"
		},
		{
			"code": "IO",
			"country": "British Indian Ocean Territory",
			"_t": "tradle.Country"
		},
		{
			"code": "IQ",
			"country": "Iraq",
			"_t": "tradle.Country"
		},
		{
			"code": "IR",
			"country": "Iran",
			"_t": "tradle.Country"
		},
		{
			"code": "IS",
			"country": "Iceland",
			"_t": "tradle.Country"
		},
		{
			"code": "IT",
			"country": "Italy",
			"_t": "tradle.Country"
		},
		{
			"code": "JE",
			"country": "Jersey",
			"_t": "tradle.Country"
		},
		{
			"code": "JM",
			"country": "Jamaica",
			"_t": "tradle.Country"
		},
		{
			"code": "JO",
			"country": "Jordan",
			"_t": "tradle.Country"
		},
		{
			"code": "JP",
			"country": "Japan",
			"_t": "tradle.Country"
		},
		{
			"code": "KE",
			"country": "Kenya",
			"_t": "tradle.Country"
		},
		{
			"code": "KG",
			"country": "Kyrgyzstan",
			"_t": "tradle.Country"
		},
		{
			"code": "KH",
			"country": "Cambodia",
			"_t": "tradle.Country"
		},
		{
			"code": "KI",
			"country": "Kiribati",
			"_t": "tradle.Country"
		},
		{
			"code": "KM",
			"country": "Comoros",
			"_t": "tradle.Country"
		},
		{
			"code": "KN",
			"country": "Saint Kitts and Nevis",
			"_t": "tradle.Country"
		},
		{
			"code": "KP",
			"country": "North Korea",
			"_t": "tradle.Country"
		},
		{
			"code": "KR",
			"country": "South Korea",
			"_t": "tradle.Country"
		},
		{
			"code": "KW",
			"country": "Kuwait",
			"_t": "tradle.Country"
		},
		{
			"code": "KY",
			"country": "Cayman Islands",
			"_t": "tradle.Country"
		},
		{
			"code": "KZ",
			"country": "Kazakhstan",
			"_t": "tradle.Country"
		},
		{
			"code": "LA",
			"country": "Lao People's Democratic Republic",
			"_t": "tradle.Country"
		},
		{
			"code": "LB",
			"country": "Lebanon",
			"_t": "tradle.Country"
		},
		{
			"code": "LC",
			"country": "Saint Lucia",
			"_t": "tradle.Country"
		},
		{
			"code": "LI",
			"country": "Liechtenstein",
			"_t": "tradle.Country"
		},
		{
			"code": "LK",
			"country": "Sri Lanka",
			"_t": "tradle.Country"
		},
		{
			"code": "LR",
			"country": "Liberia",
			"_t": "tradle.Country"
		},
		{
			"code": "LS",
			"country": "Lesotho",
			"_t": "tradle.Country"
		},
		{
			"code": "LT",
			"country": "Lithuania",
			"_t": "tradle.Country"
		},
		{
			"code": "LU",
			"country": "Luxembourg",
			"_t": "tradle.Country"
		},
		{
			"code": "LV",
			"country": "Latvia",
			"_t": "tradle.Country"
		},
		{
			"code": "LY",
			"country": "Libya",
			"_t": "tradle.Country"
		},
		{
			"code": "MA",
			"country": "Morocco",
			"_t": "tradle.Country"
		},
		{
			"code": "MC",
			"country": "Monaco",
			"_t": "tradle.Country"
		},
		{
			"code": "MD",
			"country": "Moldova",
			"_t": "tradle.Country"
		},
		{
			"code": "ME",
			"country": "Montenegro",
			"_t": "tradle.Country"
		},
		{
			"code": "MF",
			"country": "Saint-Martin (France)",
			"_t": "tradle.Country"
		},
		{
			"code": "MG",
			"country": "Madagascar",
			"_t": "tradle.Country"
		},
		{
			"code": "MH",
			"country": "Marshall Islands",
			"_t": "tradle.Country"
		},
		{
			"code": "MK",
			"country": "Macedonia",
			"_t": "tradle.Country"
		},
		{
			"code": "ML",
			"country": "Mali",
			"_t": "tradle.Country"
		},
		{
			"code": "MM",
			"country": "Myanmar",
			"_t": "tradle.Country"
		},
		{
			"code": "MN",
			"country": "Mongolia",
			"_t": "tradle.Country"
		},
		{
			"code": "MO",
			"country": "Macau",
			"_t": "tradle.Country"
		},
		{
			"code": "MP",
			"country": "Northern Mariana Islands",
			"_t": "tradle.Country"
		},
		{
			"code": "MQ",
			"country": "Martinique",
			"_t": "tradle.Country"
		},
		{
			"code": "MR",
			"country": "Mauritania",
			"_t": "tradle.Country"
		},
		{
			"code": "MS",
			"country": "Montserrat",
			"_t": "tradle.Country"
		},
		{
			"code": "MT",
			"country": "Malta",
			"_t": "tradle.Country"
		},
		{
			"code": "MU",
			"country": "Mauritius",
			"_t": "tradle.Country"
		},
		{
			"code": "MV",
			"country": "Maldives",
			"_t": "tradle.Country"
		},
		{
			"code": "MW",
			"country": "Malawi",
			"_t": "tradle.Country"
		},
		{
			"code": "MX",
			"country": "Mexico",
			"_t": "tradle.Country"
		},
		{
			"code": "MY",
			"country": "Malaysia",
			"_t": "tradle.Country"
		},
		{
			"code": "MZ",
			"country": "Mozambique",
			"_t": "tradle.Country"
		},
		{
			"code": "NA",
			"country": "Namibia",
			"_t": "tradle.Country"
		},
		{
			"code": "NC",
			"country": "New Caledonia",
			"_t": "tradle.Country"
		},
		{
			"code": "NE",
			"country": "Niger",
			"_t": "tradle.Country"
		},
		{
			"code": "NF",
			"country": "Norfolk Island",
			"_t": "tradle.Country"
		},
		{
			"code": "NG",
			"country": "Nigeria",
			"_t": "tradle.Country"
		},
		{
			"code": "NI",
			"country": "Nicaragua",
			"_t": "tradle.Country"
		},
		{
			"code": "NL",
			"country": "The Netherlands",
			"_t": "tradle.Country"
		},
		{
			"code": "NO",
			"country": "Norway",
			"_t": "tradle.Country"
		},
		{
			"code": "NP",
			"country": "Nepal",
			"_t": "tradle.Country"
		},
		{
			"code": "NR",
			"country": "Nauru",
			"_t": "tradle.Country"
		},
		{
			"code": "NU",
			"country": "Niue",
			"_t": "tradle.Country"
		},
		{
			"code": "NZ",
			"country": "New Zealand",
			"_t": "tradle.Country"
		},
		{
			"code": "OM",
			"country": "Oman",
			"_t": "tradle.Country"
		},
		{
			"code": "PA",
			"country": "Panama",
			"_t": "tradle.Country"
		},
		{
			"code": "PE",
			"country": "Peru",
			"_t": "tradle.Country"
		},
		{
			"code": "PF",
			"country": "French Polynesia",
			"_t": "tradle.Country"
		},
		{
			"code": "PG",
			"country": "Papua New Guinea",
			"_t": "tradle.Country"
		},
		{
			"code": "PH",
			"country": "Philippines",
			"_t": "tradle.Country"
		},
		{
			"code": "PK",
			"country": "Pakistan",
			"_t": "tradle.Country"
		},
		{
			"code": "PL",
			"country": "Poland",
			"_t": "tradle.Country"
		},
		{
			"code": "PM",
			"country": "St. Pierre and Miquelon",
			"_t": "tradle.Country"
		},
		{
			"code": "PN",
			"country": "Pitcairn",
			"_t": "tradle.Country"
		},
		{
			"code": "PR",
			"country": "Puerto Rico",
			"_t": "tradle.Country"
		},
		{
			"code": "PS",
			"country": "Palestine, State of",
			"_t": "tradle.Country"
		},
		{
			"code": "PT",
			"country": "Portugal",
			"_t": "tradle.Country"
		},
		{
			"code": "PW",
			"country": "Palau",
			"_t": "tradle.Country"
		},
		{
			"code": "PY",
			"country": "Paraguay",
			"_t": "tradle.Country"
		},
		{
			"code": "QA",
			"country": "Qatar",
			"_t": "tradle.Country"
		},
		{
			"code": "RE",
			"country": "Réunion",
			"_t": "tradle.Country"
		},
		{
			"code": "RO",
			"country": "Romania",
			"_t": "tradle.Country"
		},
		{
			"code": "RS",
			"country": "Serbia",
			"_t": "tradle.Country"
		},
		{
			"code": "RU",
			"country": "Russian Federation",
			"_t": "tradle.Country"
		},
		{
			"code": "RW",
			"country": "Rwanda",
			"_t": "tradle.Country"
		},
		{
			"code": "SA",
			"country": "Saudi Arabia",
			"_t": "tradle.Country"
		},
		{
			"code": "SB",
			"country": "Solomon Islands",
			"_t": "tradle.Country"
		},
		{
			"code": "SC",
			"country": "Seychelles",
			"_t": "tradle.Country"
		},
		{
			"code": "SD",
			"country": "Sudan",
			"_t": "tradle.Country"
		},
		{
			"code": "SE",
			"country": "Sweden",
			"_t": "tradle.Country"
		},
		{
			"code": "SG",
			"country": "Singapore",
			"_t": "tradle.Country"
		},
		{
			"code": "SH",
			"country": "Saint Helena",
			"_t": "tradle.Country"
		},
		{
			"code": "SI",
			"country": "Slovenia",
			"_t": "tradle.Country"
		},
		{
			"code": "SJ",
			"country": "Svalbard and Jan Mayen Islands",
			"_t": "tradle.Country"
		},
		{
			"code": "SK",
			"country": "Slovakia",
			"_t": "tradle.Country"
		},
		{
			"code": "SL",
			"country": "Sierra Leone",
			"_t": "tradle.Country"
		},
		{
			"code": "SM",
			"country": "San Marino",
			"_t": "tradle.Country"
		},
		{
			"code": "SN",
			"country": "Senegal",
			"_t": "tradle.Country"
		},
		{
			"code": "SO",
			"country": "Somalia",
			"_t": "tradle.Country"
		},
		{
			"code": "SR",
			"country": "Suriname",
			"_t": "tradle.Country"
		},
		{
			"code": "SS",
			"country": "South Sudan",
			"_t": "tradle.Country"
		},
		{
			"code": "ST",
			"country": "Sao Tome and Principe",
			"_t": "tradle.Country"
		},
		{
			"code": "SV",
			"country": "El Salvador",
			"_t": "tradle.Country"
		},
		{
			"code": "SX",
			"country": "Sint Maarten (Dutch part)",
			"_t": "tradle.Country"
		},
		{
			"code": "SY",
			"country": "Syria",
			"_t": "tradle.Country"
		},
		{
			"code": "SZ",
			"country": "Swaziland",
			"_t": "tradle.Country"
		},
		{
			"code": "TC",
			"country": "Turks and Caicos Islands",
			"_t": "tradle.Country"
		},
		{
			"code": "TD",
			"country": "Chad",
			"_t": "tradle.Country"
		},
		{
			"code": "TF",
			"country": "French Southern Territories",
			"_t": "tradle.Country"
		},
		{
			"code": "TG",
			"country": "Togo",
			"_t": "tradle.Country"
		},
		{
			"code": "TH",
			"country": "Thailand",
			"_t": "tradle.Country"
		},
		{
			"code": "TJ",
			"country": "Tajikistan",
			"_t": "tradle.Country"
		},
		{
			"code": "TK",
			"country": "Tokelau",
			"_t": "tradle.Country"
		},
		{
			"code": "TL",
			"country": "Timor-Leste",
			"_t": "tradle.Country"
		},
		{
			"code": "TM",
			"country": "Turkmenistan",
			"_t": "tradle.Country"
		},
		{
			"code": "TN",
			"country": "Tunisia",
			"_t": "tradle.Country"
		},
		{
			"code": "TO",
			"country": "Tonga",
			"_t": "tradle.Country"
		},
		{
			"code": "TR",
			"country": "Turkey",
			"_t": "tradle.Country"
		},
		{
			"code": "TT",
			"country": "Trinidad and Tobago",
			"_t": "tradle.Country"
		},
		{
			"code": "TV",
			"country": "Tuvalu",
			"_t": "tradle.Country"
		},
		{
			"code": "TW",
			"country": "Taiwan",
			"_t": "tradle.Country"
		},
		{
			"code": "TZ",
			"country": "Tanzania",
			"_t": "tradle.Country"
		},
		{
			"code": "UA",
			"country": "Ukraine",
			"_t": "tradle.Country"
		},
		{
			"code": "UG",
			"country": "Uganda",
			"_t": "tradle.Country"
		},
		{
			"code": "UM",
			"country": "United States Minor Outlying Islands",
			"_t": "tradle.Country"
		},
		{
			"code": "US",
			"country": "United States",
			"_t": "tradle.Country"
		},
		{
			"code": "UY",
			"country": "Uruguay",
			"_t": "tradle.Country"
		},
		{
			"code": "UZ",
			"country": "Uzbekistan",
			"_t": "tradle.Country"
		},
		{
			"code": "VA",
			"country": "Vatican",
			"_t": "tradle.Country"
		},
		{
			"code": "VC",
			"country": "Saint Vincent and the Grenadines",
			"_t": "tradle.Country"
		},
		{
			"code": "VE",
			"country": "Venezuela",
			"_t": "tradle.Country"
		},
		{
			"code": "VG",
			"country": "Virgin Islands (British)",
			"_t": "tradle.Country"
		},
		{
			"code": "VI",
			"country": "Virgin Islands (U.S.)",
			"_t": "tradle.Country"
		},
		{
			"code": "VN",
			"country": "Vietnam",
			"_t": "tradle.Country"
		},
		{
			"code": "VU",
			"country": "Vanuatu",
			"_t": "tradle.Country"
		},
		{
			"code": "WF",
			"country": "Wallis and Futuna Islands",
			"_t": "tradle.Country"
		},
		{
			"code": "WS",
			"country": "Samoa",
			"_t": "tradle.Country"
		},
		{
			"code": "YE",
			"country": "Yemen",
			"_t": "tradle.Country"
		},
		{
			"code": "YT",
			"country": "Mayotte",
			"_t": "tradle.Country"
		},
		{
			"code": "ZA",
			"country": "South Africa",
			"_t": "tradle.Country"
		},
		{
			"code": "ZM",
			"country": "Zambia",
			"_t": "tradle.Country"
		},
		{
			"code": "ZW",
			"country": "Zimbabwe",
			"_t": "tradle.Country"
		}
	];

/***/ },

/***/ 1656:
/***/ function(module, exports) {

	module.exports = [
		{
			"_t": "tradle.Nationality",
			"nationality": "Afghan"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Albanian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Algerian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "American"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Andorran"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Angolan"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Antiguans"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Argentinean"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Armenian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Australian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Austrian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Azerbaijani"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Bahamian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Bahraini"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Bangladeshi"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Barbadian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Barbudans"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Batswana"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Belarusian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Belgian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Belizean"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Beninese"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Bhutanese"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Bolivian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Bosnian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Brazilian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "British"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Bruneian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Bulgarian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Burkinabe"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Burmese"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Burundian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Cambodian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Cameroonian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Canadian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Cape Verdean"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Central African"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Chadian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Chilean"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Chinese"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Colombian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Comoran"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Congolese"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Congolese"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Costa Rican"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Croatian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Cuban"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Cypriot"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Czech"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Danish"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Djibouti"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Dominican"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Dominican"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Dutch"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Dutchman"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Dutchwoman"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "East Timorese"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Ecuadorean"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Egyptian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Emirian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Equatorial Guinean"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Eritrean"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Estonian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Ethiopian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Fijian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Filipino"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Finnish"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "French"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Gabonese"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Gambian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Georgian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "German"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Ghanaian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Greek"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Grenadian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Guatemalan"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Guinea-Bissauan"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Guinean"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Guyanese"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Haitian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Herzegovinian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Honduran"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Hungarian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "I-Kiribati"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Icelander"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Indian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Indonesian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Iranian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Iraqi"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Irish"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Irish"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Israeli"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Italian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Ivorian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Jamaican"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Japanese"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Jordanian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Kazakhstani"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Kenyan"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Kittian and Nevisian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Kuwaiti"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Kyrgyz"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Laotian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Latvian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Lebanese"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Liberian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Libyan"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Liechtensteiner"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Lithuanian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Luxembourger"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Macedonian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Malagasy"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Malawian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Malaysian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Maldivan"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Malian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Maltese"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Marshallese"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Mauritanian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Mauritian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Mexican"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Micronesian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Moldovan"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Monacan"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Mongolian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Moroccan"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Mosotho"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Motswana"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Mozambican"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Namibian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Nauruan"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Nepalese"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Netherlander"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "New Zealander"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Ni-Vanuatu"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Nicaraguan"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Nigerian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Nigerien"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "North Korean"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Northern Irish"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Norwegian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Omani"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Pakistani"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Palauan"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Panamanian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Papua New Guinean"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Paraguayan"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Peruvian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Polish"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Portuguese"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Qatari"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Romanian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Russian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Rwandan"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Saint Lucian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Salvadoran"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Samoan"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "San Marinese"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Sao Tomean"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Saudi"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Scottish"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Senegalese"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Serbian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Seychellois"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Sierra Leonean"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Singaporean"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Slovakian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Slovenian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Solomon Islander"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Somali"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "South African"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "South Korean"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Spanish"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Sri Lankan"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Sudanese"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Surinamer"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Swazi"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Swedish"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Swiss"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Syrian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Taiwanese"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Tajik"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Tanzanian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Thai"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Togolese"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Tongan"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Trinidadian or Tobagonian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Tunisian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Turkish"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Tuvaluan"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Ugandan"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Ukrainian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Uruguayan"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Uzbekistani"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Venezuelan"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Vietnamese"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Welsh"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Welsh"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Yemenite"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Zambian"
		},
		{
			"_t": "tradle.Nationality",
			"nationality": "Zimbabwean"
		}
	];

/***/ },

/***/ 1657:
/***/ function(module, exports) {

	module.exports = [
		{
			"currencyName": "ADB Unit of Account",
			"code": "XUA",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Afghani",
			"code": "AFN",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Algerian Dinar",
			"code": "DZD",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Argentine Peso",
			"code": "ARS",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Armenian Dram",
			"code": "AMD",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Aruban Florin",
			"code": "AWG",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Australian Dollar",
			"code": "AUD",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Azerbaijanian Manat",
			"code": "AZN",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Bahamian Dollar",
			"code": "BSD",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Bahraini Dinar",
			"code": "BHD",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Baht",
			"code": "THB",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Balboa",
			"code": "PAB",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Barbados Dollar",
			"code": "BBD",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Belarusian Ruble",
			"code": "BYN",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Belarusian Ruble",
			"code": "BYR",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Belize Dollar",
			"code": "BZD",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Bermudian Dollar",
			"code": "BMD",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Boliviano",
			"code": "BOB",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Bolívar",
			"code": "VEF",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Bond Markets Unit European Composite Unit (EURCO)",
			"code": "XBA",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Bond Markets Unit European Monetary Unit (E.M.U.-6)",
			"code": "XBB",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Bond Markets Unit European Unit of Account 17 (E.U.A.-17)",
			"code": "XBD",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Bond Markets Unit European Unit of Account 9 (E.U.A.-9)",
			"code": "XBC",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Brazilian Real",
			"code": "BRL",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Brunei Dollar",
			"code": "BND",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Bulgarian Lev",
			"code": "BGN",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Burundi Franc",
			"code": "BIF",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "CFA Franc BCEAO",
			"code": "XOF",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "CFA Franc BEAC",
			"code": "XAF",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "CFP Franc",
			"code": "XPF",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Cabo Verde Escudo",
			"code": "CVE",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Canadian Dollar",
			"code": "CAD",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Cayman Islands Dollar",
			"code": "KYD",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Chilean Peso",
			"code": "CLP",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Codes specifically reserved for testing purposes",
			"code": "XTS",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Colombian Peso",
			"code": "COP",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Comoro Franc",
			"code": "KMF",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Congolese Franc",
			"code": "CDF",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Convertible Mark",
			"code": "BAM",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Cordoba Oro",
			"code": "NIO",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Costa Rican Colon",
			"code": "CRC",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Cuban Peso",
			"code": "CUP",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Czech Koruna",
			"code": "CZK",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Dalasi",
			"code": "GMD",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Danish Krone",
			"code": "DKK",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Denar",
			"code": "MKD",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Djibouti Franc",
			"code": "DJF",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Dobra",
			"code": "STD",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Dominican Peso",
			"code": "DOP",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Dong",
			"code": "VND",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "East Caribbean Dollar",
			"code": "XCD",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Egyptian Pound",
			"code": "EGP",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "El Salvador Colon",
			"code": "SVC",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Ethiopian Birr",
			"code": "ETB",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Euro",
			"code": "EUR",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Falkland Islands Pound",
			"code": "FKP",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Fiji Dollar",
			"code": "FJD",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Forint",
			"code": "HUF",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Ghana Cedi",
			"code": "GHS",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Gibraltar Pound",
			"code": "GIP",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Gold",
			"code": "XAU",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Gourde",
			"code": "HTG",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Guarani",
			"code": "PYG",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Guinea Franc",
			"code": "GNF",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Guyana Dollar",
			"code": "GYD",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Hong Kong Dollar",
			"code": "HKD",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Hryvnia",
			"code": "UAH",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Iceland Krona",
			"code": "ISK",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Indian Rupee",
			"code": "INR",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Iranian Rial",
			"code": "IRR",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Iraqi Dinar",
			"code": "IQD",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Jamaican Dollar",
			"code": "JMD",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Jordanian Dinar",
			"code": "JOD",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Kenyan Shilling",
			"code": "KES",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Kina",
			"code": "PGK",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Kip",
			"code": "LAK",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Kuna",
			"code": "HRK",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Kuwaiti Dinar",
			"code": "KWD",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Kwanza",
			"code": "AOA",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Kyat",
			"code": "MMK",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Lari",
			"code": "GEL",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Lebanese Pound",
			"code": "LBP",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Lek",
			"code": "ALL",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Lempira",
			"code": "HNL",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Leone",
			"code": "SLL",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Liberian Dollar",
			"code": "LRD",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Libyan Dinar",
			"code": "LYD",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Lilangeni",
			"code": "SZL",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Loti",
			"code": "LSL",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Malagasy Ariary",
			"code": "MGA",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Malawi Kwacha",
			"code": "MWK",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Malaysian Ringgit",
			"code": "MYR",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Mauritius Rupee",
			"code": "MUR",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Mexican Peso",
			"code": "MXN",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Mexican Unidad de Inversion (UDI)",
			"code": "MXV",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Moldovan Leu",
			"code": "MDL",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Moroccan Dirham",
			"code": "MAD",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Mozambique Metical",
			"code": "MZN",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Mvdol",
			"code": "BOV",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Naira",
			"code": "NGN",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Nakfa",
			"code": "ERN",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Namibia Dollar",
			"code": "NAD",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Nepalese Rupee",
			"code": "NPR",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Netherlands Antillean Guilder",
			"code": "ANG",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "New Israeli Sheqel",
			"code": "ILS",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "New Taiwan Dollar",
			"code": "TWD",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "New Zealand Dollar",
			"code": "NZD",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Ngultrum",
			"code": "BTN",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "North Korean Won",
			"code": "KPW",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Norwegian Krone",
			"code": "NOK",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Ouguiya",
			"code": "MRO",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Pakistan Rupee",
			"code": "PKR",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Palladium",
			"code": "XPD",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Pataca",
			"code": "MOP",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Pa’anga",
			"code": "TOP",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Peso Convertible",
			"code": "CUC",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Peso Uruguayo",
			"code": "UYU",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Philippine Peso",
			"code": "PHP",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Platinum",
			"code": "XPT",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Pound Sterling",
			"code": "GBP",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Pula",
			"code": "BWP",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Qatari Rial",
			"code": "QAR",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Quetzal",
			"code": "GTQ",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Rand",
			"code": "ZAR",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Rial Omani",
			"code": "OMR",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Riel",
			"code": "KHR",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Romanian Leu",
			"code": "RON",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Rufiyaa",
			"code": "MVR",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Rupiah",
			"code": "IDR",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Russian Ruble",
			"code": "RUB",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Rwanda Franc",
			"code": "RWF",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "SDR (Special Drawing Right)",
			"code": "XDR",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Saint Helena Pound",
			"code": "SHP",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Saudi Riyal",
			"code": "SAR",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Serbian Dinar",
			"code": "RSD",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Seychelles Rupee",
			"code": "SCR",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Silver",
			"code": "XAG",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Singapore Dollar",
			"code": "SGD",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Sol",
			"code": "PEN",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Solomon Islands Dollar",
			"code": "SBD",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Som",
			"code": "KGS",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Somali Shilling",
			"code": "SOS",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Somoni",
			"code": "TJS",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "South Sudanese Pound",
			"code": "SSP",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Sri Lanka Rupee",
			"code": "LKR",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Sucre",
			"code": "XSU",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Sudanese Pound",
			"code": "SDG",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Surinam Dollar",
			"code": "SRD",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Swedish Krona",
			"code": "SEK",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Syrian Pound",
			"code": "SYP",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Taka",
			"code": "BDT",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Tala",
			"code": "WST",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Tanzanian Shilling",
			"code": "TZS",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Tenge",
			"code": "KZT",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "The codes assigned for transactions where no currency is involved",
			"code": "XXX",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Trinidad and Tobago Dollar",
			"code": "TTD",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Tugrik",
			"code": "MNT",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Tunisian Dinar",
			"code": "TND",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Turkish Lira",
			"code": "TRY",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Turkmenistan New Manat",
			"code": "TMT",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "UAE Dirham",
			"code": "AED",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "US Dollar",
			"code": "USD",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Uganda Shilling",
			"code": "UGX",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Unidad de Fomento",
			"code": "CLF",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Unidad de Valor Real",
			"code": "COU",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Uruguay Peso en Unidades Indexadas (URUIURUI)",
			"code": "UYI",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Uzbekistan Sum",
			"code": "UZS",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Vatu",
			"code": "VUV",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "WIR Euro",
			"code": "CHE",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "WIR Franc",
			"code": "CHW",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Won",
			"code": "KRW",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Yemeni Rial",
			"code": "YER",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Yen",
			"code": "JPY",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Yuan Renminbi",
			"code": "CNY",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Zambian Kwacha",
			"code": "ZMW",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Zimbabwe Dollar",
			"code": "ZWL",
			"_t": "tradle.Currency"
		},
		{
			"currencyName": "Zloty",
			"code": "PLN",
			"_t": "tradle.Currency"
		}
	];

/***/ },

/***/ 1658:
/***/ function(module, exports) {

	module.exports = [
		{
			"_t": "tradle.Major",
			"major": "Business Administration"
		},
		{
			"_t": "tradle.Major",
			"major": "Entrepreneurship"
		},
		{
			"_t": "tradle.Major",
			"major": "Animation"
		},
		{
			"_t": "tradle.Major",
			"major": "Computer Systems Analysis"
		},
		{
			"_t": "tradle.Major",
			"major": "Neurobiology"
		},
		{
			"_t": "tradle.Major",
			"major": "Accounting"
		},
		{
			"_t": "tradle.Major",
			"major": "International Business"
		},
		{
			"_t": "tradle.Major",
			"major": "Finance"
		},
		{
			"_t": "tradle.Major",
			"major": "Digital Communications and Multimedia"
		},
		{
			"_t": "tradle.Major",
			"major": "Network Design and Administration"
		}
	];

/***/ },

/***/ 1659:
/***/ function(module, exports) {

	module.exports = [
		{
			"_t": "tradle.InvestingType",
			"investingType": "Stocks"
		},
		{
			"_t": "tradle.InvestingType",
			"investingType": "Bonds"
		},
		{
			"_t": "tradle.InvestingType",
			"investingType": "Investment Funds"
		},
		{
			"_t": "tradle.InvestingType",
			"investingType": "Annuities"
		},
		{
			"_t": "tradle.InvestingType",
			"investingType": "Bank Products"
		},
		{
			"_t": "tradle.InvestingType",
			"investingType": "Saving for College"
		},
		{
			"_t": "tradle.InvestingType",
			"investingType": "Insurance"
		},
		{
			"_t": "tradle.InvestingType",
			"investingType": "Commodity Futures"
		},
		{
			"_t": "tradle.InvestingType",
			"investingType": "Options"
		},
		{
			"_t": "tradle.InvestingType",
			"investingType": "Retirement"
		}
	];

/***/ },

/***/ 1660:
/***/ function(module, exports) {

	module.exports = [
		{
			"_t": "tradle.WealthItemType",
			"itemType": "Inheritance"
		},
		{
			"_t": "tradle.WealthItemType",
			"itemType": "Salary"
		},
		{
			"_t": "tradle.WealthItemType",
			"itemType": "Securities purchase"
		},
		{
			"_t": "tradle.WealthItemType",
			"itemType": "Securities sale"
		},
		{
			"_t": "tradle.WealthItemType",
			"itemType": "Investment"
		},
		{
			"_t": "tradle.WealthItemType",
			"itemType": "Liquidation"
		},
		{
			"_t": "tradle.WealthItemType",
			"itemType": "Other"
		}
	];

/***/ },

/***/ 1997:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, process) {
	const inherits = __webpack_require__(1130).inherits
	const lps = __webpack_require__(1981)
	const through = __webpack_require__(1213)
	const pump = __webpack_require__(1208)
	const debug = __webpack_require__(787)('tradle:wire')
	const stream = __webpack_require__(1998)
	const Duplex = stream.Duplex
	const duplexify = __webpack_require__(2007)
	const bindAll = __webpack_require__(1925)
	const Session = __webpack_require__(2020)
	const nacl = __webpack_require__(1372)
	const schema = __webpack_require__(2029)
	const noop = function () {}
	const ENCODERS = {
	  envelope: [
	    schema.Handshake,
	    schema.Encrypted,
	  ],
	  payload: [
	    schema.Request,
	    schema.Data,
	    schema.Ack
	  ]
	}
	
	module.exports = exports = Wire
	exports.nacl = nacl
	
	/**
	 * flow:
	 *
	 * A                    B
	 *      --> open
	 *      <-- handshake
	 *      --> handshake
	 *      <--> data/ack
	 */
	
	var INSTANCE_ID = 0
	
	function Wire (opts) {
	  const self = this
	  if (!(this instanceof Wire)) return new Wire(opts)
	
	  this._identityKey = normalizePrivKey(opts.identity)
	  this._handshakeKey = normalizePrivKey(opts.handshake || nacl.box.keyPair())
	
	  bindAll(this)
	  duplexify.call(this)
	
	  this._ack = opts.ack || 0
	  this._session = new Session()
	    .identity(this._identityKey)
	    .handshake(this._handshakeKey)
	
	  if (opts.theirIdentity) this._setTheirIdentity(opts.theirIdentity)
	
	  this._debugId = INSTANCE_ID++
	  this._debug('identity', this._identityKey.publicKey.toString('hex'))
	  this._debug('handshake', this._handshakeKey.publicKey.toString('hex'))
	
	  this._encode = lps.encode()
	  this._decode = lps.decode()
	  pump(
	    this._decode,
	    through.obj(processEnvelope),
	    through.obj(processPayload)
	  )
	
	  this.setReadable(this._encode)
	  this.setWritable(this._decode)
	
	  // set to `true` when the counterparty
	  // has authenticated themselves to us
	  this._authenticated = false
	
	  function processEnvelope (data, enc, cb) {
	    try {
	      var payload = decodeEnvelope(data)
	    } catch (err) {
	      self._debug('skipping message with invalid envelope', data)
	      return cb()
	    }
	
	    switch (data[0]) {
	    case 0:
	      return self._onhandshake(payload, function (err) {
	        if (err) self._debug('failed to process handshake', payload, err)
	        cb()
	      })
	    case 1:
	      return cb(null, payload)
	    default:
	      return cb()
	    }
	  }
	
	  function processPayload (data, enc, cb) {
	    self._session.decrypt(data)
	      .then(function (result) {
	        const payload = new Buffer(result.cleartext, 'base64')
	        try {
	          var msg = decodePayload(payload)
	        } catch (err) {
	          self._debug('skipping message with invalid payload', data)
	          return cb(err)
	        }
	
	        self._receiveAck(msg)
	        self._debug('received ' + (payload[0] === 0 ? 'request' : payload[0] === 1 ? 'data' : 'ack'))
	
	        switch (payload[0]) {
	        case 0: return self._onrequest(msg, cb)
	        case 1: return self._ondata(msg, cb)
	        default: cb()
	        }
	      }, function (err) {
	        self._debug('failed to decrypt message', data, err)
	        cb()
	      })
	      .catch(function (err) {
	        self._debug('error processing message', data, err)
	        cb()
	      })
	  }
	}
	
	inherits(Wire, duplexify)
	
	Wire.prototype.end = function () {
	  this._debug('end')
	  Duplex.prototype.end.apply(this, arguments)
	}
	
	Wire.prototype.destroy = function (err) {
	  if (this.destroyed) return
	  this.destroyed = true
	  this._debug('destroy', err)
	  this.emit('close')
	  this.end()
	}
	
	Wire.prototype._debug = function () {
	  var args = [].slice.call(arguments)
	  args[0] = '[' + this._debugId + '] ' + args[0]
	  debug.apply(null, args)
	}
	
	Wire.prototype._read = function () {}
	
	Wire.prototype.open = function () {
	  this._initiator = true
	  this.handshake()
	}
	
	Wire.prototype._maybeOpen = function () {
	  if (this._initiator == null) this.open()
	}
	
	Wire.prototype._setTheirIdentity = function (theirIdentity) {
	  theirIdentity = normalizePubKey(theirIdentity)
	  if (this._theirIdentityKey && !theirIdentity.equals(this._theirIdentityKey)) {
	    throw new Error('refusing to change to a different counterparty')
	  }
	
	  this._theirIdentityKey = theirIdentity
	  const role = getRole(this._identityKey.publicKey, this._theirIdentityKey)
	  this._debug('role: ' + role)
	
	  this._session
	    .theirIdentity(this._theirIdentityKey)
	    .setRole(role)
	}
	
	Wire.prototype.handshake = function () {
	  this._debug('sending handshake')
	  this._sendCleartext(0, {
	    ephemeralKey: new Buffer(this._handshakeKey.publicKey),
	    staticKey: new Buffer(this._identityKey.publicKey),
	    authenticated: this._authenticated
	  }, true)
	}
	
	Wire.prototype.request = function (seq) {
	  this._sendEncrypted(0, {
	    seq: seq
	  })
	}
	
	Wire.prototype.send = function (msg, cb) {
	  this._sendEncrypted(1, {
	    ack: this._ack,
	    payload: msg
	  }, cb)
	}
	
	/**
	 * specify the last message we've received
	 */
	Wire.prototype.ack = function (ack) {
	  if (ack === 0) throw new Error('ack must be a positive integer')
	
	  this._ack = ack
	  // TODO: include acks in other message
	  // if (this._outgoing.length) return // ack in next outgoing message
	
	  this._sendEncrypted(2, {
	    ack: ack
	  })
	}
	
	Wire.prototype._onhandshake = function (handshake, cb) {
	  if (this._authenticated && handshake.authenticated) {
	    return nextTick(cb)
	  }
	
	  this._debug('received handshake')
	  if (this._theirIdentityKey) {
	    if (!handshake.staticKey.equals(this._theirIdentityKey)) {
	      // console.log('their identity', handshake.staticKey.toString('hex'))
	      // console.log('their handshake', handshake.ephemeralKey.toString('hex'))
	      this._debug('ignoring handshake from a different identity')
	      this.emit('error', new Error('invalid handshake'))
	      return cb()
	    }
	
	    return this.acceptHandshake(handshake, cb)
	  }
	
	  this.emit('handshake', handshake)
	  cb()
	}
	
	Wire.prototype.acceptHandshake = function (handshake, cb) {
	  const self = this
	  cb = cb || noop
	
	  this._setTheirIdentity(handshake.staticKey)
	  this._session
	    .theirHandshake(handshake.ephemeralKey)
	    .computeMasterKey()
	    .then(function () {
	      self._debug('authenticated')
	      self._authenticated = true
	      self.emit('open')
	      // if (self._initiator) self.handshake()
	
	      // TODO: optimize to avoid double-sending handshake
	      if (!handshake.authenticated) self.handshake()
	
	      cb()
	    }, cb)
	}
	
	Wire.prototype._sendCleartext = function (type, msg) {
	  // this._debug('sending', type === 0 ? 'handshake' : 'encrypted data')
	  const encoded = encodeEnvelope(type, msg)
	  this._encode.write(encoded)
	}
	
	Wire.prototype._sendEncrypted = function (type, msg, cb) {
	  const self = this
	  if (!this._authenticated) {
	    this._maybeOpen()
	    return this.once('open', function () {
	      self._sendEncrypted(type, msg, cb)
	    })
	  }
	
	  this._debug('sending', keyByValue(schema, ENCODERS.payload[type]))
	  const buf = encodePayload(type, msg)
	  this._session.encrypt(buf.toString('base64')).then(function (result) {
	    self._sendCleartext(1, result)
	    cb()
	  }, cb)
	}
	
	Wire.prototype._ondata = function (msg, cb) {
	  if (!this._authenticated) return this.destroy(new Error('did not receive handshake'))
	
	  this.emit('message', msg.payload)
	  cb()
	}
	
	Wire.prototype._onrequest = function (msg, cb) {
	  if (!this._authenticated) return this.destroy(new Error('did not receive handshake'))
	
	  this.emit('request', msg.seq)
	  cb()
	}
	
	Wire.prototype._receiveAck = function (msg) {
	  // ignore ack 0
	  if (msg.ack) {
	    this.emit('ack', msg.ack)
	  }
	}
	
	function copyBuf (buf, offset) {
	  const copy = new Buffer(buf.length)
	  buf.copy(copy, 0, offset)
	  return copy
	}
	
	function keyByValue (obj, val) {
	  for (var p in obj) {
	    if (obj[p] === val) return p
	  }
	}
	
	function nextTick (fn, arg1, arg2) {
	  process.nextTick(function () {
	    fn(arg1, arg2)
	  })
	}
	
	function encodeEnvelope (type, msg) {
	  return encode(ENCODERS.envelope, type, msg)
	}
	
	function encodePayload (type, msg) {
	  return encode(ENCODERS.payload, type, msg)
	}
	
	function decodeEnvelope (data) {
	  return decode(ENCODERS.envelope, data)
	}
	
	function decodePayload (data) {
	  return decode(ENCODERS.payload, data)
	}
	
	function encode (encoders, type, msg) {
	  for (var p in msg) {
	    var val = msg[p]
	    if (val instanceof Uint8Array) {
	      msg[p] = new Buffer(val)
	    }
	  }
	
	  const enc = encoders[type]
	  const len = enc ? enc.encodingLength(msg) : 0
	  const buf = new Buffer(len + 1)
	
	  buf[0] = type
	  enc.encode(msg, buf, 1)
	  return buf
	}
	
	function decode (encoders, data) {
	  const type = data[0]
	  const enc = encoders[type]
	  return enc.decode(data, 1)
	}
	
	function normalizePrivKey (key) {
	  if (key.secretKey) {
	    return {
	      secretKey: toBuffer(key.secretKey),
	      publicKey: toBuffer(key.publicKey)
	    }
	  }
	
	  return nacl.box.keyPair.fromSecretKey(toBuffer(key))
	}
	
	function normalizePubKey (key) {
	  if (key.publicKey) return key.publicKey
	
	  return toBuffer(key)
	}
	
	function toBuffer (buf) {
	  if (Buffer.isBuffer(buf)) return buf
	  if (buf instanceof Uint8Array) return new Buffer(buf)
	
	  throw new Error('expected Buffer or Uint8Array')
	}
	
	function getRole (us, them) {
	  for (var i = 0; i < us.length; i++) {
	    if (us[i] === them[i]) continue
	    if (us[i] > them[i]) {
	        return 'initiator'
	    } else {
	        return 'receiver'
	    }
	
	    break
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(820).Buffer, __webpack_require__(294)))

/***/ },

/***/ 1998:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var Stream = (function (){
	  try {
	    return __webpack_require__(827); // hack to fix a circular dependency issue when used with browserify
	  } catch(_){}
	}());
	exports = module.exports = __webpack_require__(1999);
	exports.Stream = Stream || exports;
	exports.Readable = exports;
	exports.Writable = __webpack_require__(2004);
	exports.Duplex = __webpack_require__(2003);
	exports.Transform = __webpack_require__(2005);
	exports.PassThrough = __webpack_require__(2006);
	
	if (!process.browser && process.env.READABLE_STREAM === 'disable' && Stream) {
	  module.exports = Stream;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(294)))

/***/ },

/***/ 1999:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	module.exports = Readable;
	
	/*<replacement>*/
	var processNextTick = __webpack_require__(1160);
	/*</replacement>*/
	
	/*<replacement>*/
	var isArray = __webpack_require__(2000);
	/*</replacement>*/
	
	Readable.ReadableState = ReadableState;
	
	/*<replacement>*/
	var EE = __webpack_require__(786).EventEmitter;
	
	var EElistenerCount = function (emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/
	
	/*<replacement>*/
	var Stream;
	(function () {
	  try {
	    Stream = __webpack_require__(827);
	  } catch (_) {} finally {
	    if (!Stream) Stream = __webpack_require__(786).EventEmitter;
	  }
	})();
	/*</replacement>*/
	
	var Buffer = __webpack_require__(820).Buffer;
	/*<replacement>*/
	var bufferShim = __webpack_require__(1162);
	/*</replacement>*/
	
	/*<replacement>*/
	var util = __webpack_require__(832);
	util.inherits = __webpack_require__(828);
	/*</replacement>*/
	
	/*<replacement>*/
	var debugUtil = __webpack_require__(2001);
	var debug = void 0;
	if (debugUtil && debugUtil.debuglog) {
	  debug = debugUtil.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/
	
	var BufferList = __webpack_require__(2002);
	var StringDecoder;
	
	util.inherits(Readable, Stream);
	
	function prependListener(emitter, event, fn) {
	  if (typeof emitter.prependListener === 'function') {
	    return emitter.prependListener(event, fn);
	  } else {
	    // This is a hack to make sure that our error handler is attached before any
	    // userland ones.  NEVER DO THIS. This is here only because this code needs
	    // to continue to work with older versions of Node.js that do not include
	    // the prependListener() method. The goal is to eventually remove this hack.
	    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
	  }
	}
	
	var Duplex;
	function ReadableState(options, stream) {
	  Duplex = Duplex || __webpack_require__(2003);
	
	  options = options || {};
	
	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;
	
	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
	
	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
	
	  // cast to ints.
	  this.highWaterMark = ~ ~this.highWaterMark;
	
	  // A linked list is used to store data chunks instead of an array because the
	  // linked list can remove elements from the beginning faster than
	  // array.shift()
	  this.buffer = new BufferList();
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	  this.resumeScheduled = false;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;
	
	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;
	
	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;
	
	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder) StringDecoder = __webpack_require__(836).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}
	
	var Duplex;
	function Readable(options) {
	  Duplex = Duplex || __webpack_require__(2003);
	
	  if (!(this instanceof Readable)) return new Readable(options);
	
	  this._readableState = new ReadableState(options, this);
	
	  // legacy
	  this.readable = true;
	
	  if (options && typeof options.read === 'function') this._read = options.read;
	
	  Stream.call(this);
	}
	
	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function (chunk, encoding) {
	  var state = this._readableState;
	
	  if (!state.objectMode && typeof chunk === 'string') {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = bufferShim.from(chunk, encoding);
	      encoding = '';
	    }
	  }
	
	  return readableAddChunk(this, state, chunk, encoding, false);
	};
	
	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function (chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};
	
	Readable.prototype.isPaused = function () {
	  return this._readableState.flowing === false;
	};
	
	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (chunk === null) {
	    state.reading = false;
	    onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var _e = new Error('stream.unshift() after end event');
	      stream.emit('error', _e);
	    } else {
	      var skipAdd;
	      if (state.decoder && !addToFront && !encoding) {
	        chunk = state.decoder.write(chunk);
	        skipAdd = !state.objectMode && chunk.length === 0;
	      }
	
	      if (!addToFront) state.reading = false;
	
	      // Don't add to the buffer if we've decoded to an empty string chunk and
	      // we're not in object mode
	      if (!skipAdd) {
	        // if we want the data now, just emit it.
	        if (state.flowing && state.length === 0 && !state.sync) {
	          stream.emit('data', chunk);
	          stream.read(0);
	        } else {
	          // update the buffer info.
	          state.length += state.objectMode ? 1 : chunk.length;
	          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
	
	          if (state.needReadable) emitReadable(stream);
	        }
	      }
	
	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }
	
	  return needMoreData(state);
	}
	
	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
	}
	
	// backwards compatibility.
	Readable.prototype.setEncoding = function (enc) {
	  if (!StringDecoder) StringDecoder = __webpack_require__(836).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};
	
	// Don't raise the hwm > 8MB
	var MAX_HWM = 0x800000;
	function computeNewHighWaterMark(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2 to prevent increasing hwm excessively in
	    // tiny amounts
	    n--;
	    n |= n >>> 1;
	    n |= n >>> 2;
	    n |= n >>> 4;
	    n |= n >>> 8;
	    n |= n >>> 16;
	    n++;
	  }
	  return n;
	}
	
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function howMuchToRead(n, state) {
	  if (n <= 0 || state.length === 0 && state.ended) return 0;
	  if (state.objectMode) return 1;
	  if (n !== n) {
	    // Only flow one buffer at a time
	    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
	  }
	  // If we're asking for more than the current hwm, then raise the hwm.
	  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
	  if (n <= state.length) return n;
	  // Don't have enough
	  if (!state.ended) {
	    state.needReadable = true;
	    return 0;
	  }
	  return state.length;
	}
	
	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function (n) {
	  debug('read', n);
	  n = parseInt(n, 10);
	  var state = this._readableState;
	  var nOrig = n;
	
	  if (n !== 0) state.emittedReadable = false;
	
	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
	    return null;
	  }
	
	  n = howMuchToRead(n, state);
	
	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0) endReadable(this);
	    return null;
	  }
	
	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.
	
	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);
	
	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }
	
	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  } else if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0) state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	    // If _read pushed data synchronously, then `reading` will be false,
	    // and we need to re-evaluate how much data we can return to the user.
	    if (!state.reading) n = howMuchToRead(nOrig, state);
	  }
	
	  var ret;
	  if (n > 0) ret = fromList(n, state);else ret = null;
	
	  if (ret === null) {
	    state.needReadable = true;
	    n = 0;
	  } else {
	    state.length -= n;
	  }
	
	  if (state.length === 0) {
	    // If we have nothing in the buffer, then we want to know
	    // as soon as we *do* get something into the buffer.
	    if (!state.ended) state.needReadable = true;
	
	    // If we tried to read() past the EOF, then emit end on the next tick.
	    if (nOrig !== n && state.ended) endReadable(this);
	  }
	
	  if (ret !== null) this.emit('data', ret);
	
	  return ret;
	};
	
	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}
	
	function onEofChunk(stream, state) {
	  if (state.ended) return;
	  if (state.decoder) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;
	
	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}
	
	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
	  }
	}
	
	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}
	
	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    processNextTick(maybeReadMore_, stream, state);
	  }
	}
	
	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;else len = state.length;
	  }
	  state.readingMore = false;
	}
	
	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function (n) {
	  this.emit('error', new Error('not implemented'));
	};
	
	Readable.prototype.pipe = function (dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;
	
	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
	
	  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
	
	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);
	
	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }
	
	  function onend() {
	    debug('onend');
	    dest.end();
	  }
	
	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);
	
	  var cleanedUp = false;
	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);
	
	    cleanedUp = true;
	
	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
	  }
	
	  // If the user pushes more data while we're writing to dest then we'll end up
	  // in ondata again. However, we only want to increase awaitDrain once because
	  // dest will only emit one 'drain' event for the multiple writes.
	  // => Introduce a guard on increasing awaitDrain.
	  var increasedAwaitDrain = false;
	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    increasedAwaitDrain = false;
	    var ret = dest.write(chunk);
	    if (false === ret && !increasedAwaitDrain) {
	      // If the user unpiped during `dest.write()`, it is possible
	      // to get stuck in a permanently paused state if that write
	      // also returned false.
	      // => Check whether `dest` is still a piping destination.
	      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
	        debug('false write response, pause', src._readableState.awaitDrain);
	        src._readableState.awaitDrain++;
	        increasedAwaitDrain = true;
	      }
	      src.pause();
	    }
	  }
	
	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
	  }
	
	  // Make sure our error handler is attached before userland ones.
	  prependListener(dest, 'error', onerror);
	
	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);
	
	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }
	
	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);
	
	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }
	
	  return dest;
	};
	
	function pipeOnDrain(src) {
	  return function () {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain) state.awaitDrain--;
	    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}
	
	Readable.prototype.unpipe = function (dest) {
	  var state = this._readableState;
	
	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0) return this;
	
	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes) return this;
	
	    if (!dest) dest = state.pipes;
	
	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest) dest.emit('unpipe', this);
	    return this;
	  }
	
	  // slow case. multiple pipe destinations.
	
	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	
	    for (var _i = 0; _i < len; _i++) {
	      dests[_i].emit('unpipe', this);
	    }return this;
	  }
	
	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1) return this;
	
	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1) state.pipes = state.pipes[0];
	
	  dest.emit('unpipe', this);
	
	  return this;
	};
	
	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function (ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);
	
	  if (ev === 'data') {
	    // Start flowing on next tick if stream isn't explicitly paused
	    if (this._readableState.flowing !== false) this.resume();
	  } else if (ev === 'readable') {
	    var state = this._readableState;
	    if (!state.endEmitted && !state.readableListening) {
	      state.readableListening = state.needReadable = true;
	      state.emittedReadable = false;
	      if (!state.reading) {
	        processNextTick(nReadingNextTick, this);
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }
	
	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;
	
	function nReadingNextTick(self) {
	  debug('readable nexttick read 0');
	  self.read(0);
	}
	
	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function () {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    resume(this, state);
	  }
	  return this;
	};
	
	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    processNextTick(resume_, stream, state);
	  }
	}
	
	function resume_(stream, state) {
	  if (!state.reading) {
	    debug('resume read 0');
	    stream.read(0);
	  }
	
	  state.resumeScheduled = false;
	  state.awaitDrain = 0;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading) stream.read(0);
	}
	
	Readable.prototype.pause = function () {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};
	
	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  while (state.flowing && stream.read() !== null) {}
	}
	
	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function (stream) {
	  var state = this._readableState;
	  var paused = false;
	
	  var self = this;
	  stream.on('end', function () {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length) self.push(chunk);
	    }
	
	    self.push(null);
	  });
	
	  stream.on('data', function (chunk) {
	    debug('wrapped data');
	    if (state.decoder) chunk = state.decoder.write(chunk);
	
	    // don't skip over falsy values in objectMode
	    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
	
	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });
	
	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (this[i] === undefined && typeof stream[i] === 'function') {
	      this[i] = function (method) {
	        return function () {
	          return stream[method].apply(stream, arguments);
	        };
	      }(i);
	    }
	  }
	
	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function (ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });
	
	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function (n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };
	
	  return self;
	};
	
	// exposed for testing purposes only.
	Readable._fromList = fromList;
	
	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromList(n, state) {
	  // nothing buffered
	  if (state.length === 0) return null;
	
	  var ret;
	  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
	    // read it all, truncate the list
	    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
	    state.buffer.clear();
	  } else {
	    // read part of list
	    ret = fromListPartial(n, state.buffer, state.decoder);
	  }
	
	  return ret;
	}
	
	// Extracts only enough buffered data to satisfy the amount requested.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromListPartial(n, list, hasStrings) {
	  var ret;
	  if (n < list.head.data.length) {
	    // slice is the same for buffers and strings
	    ret = list.head.data.slice(0, n);
	    list.head.data = list.head.data.slice(n);
	  } else if (n === list.head.data.length) {
	    // first chunk is a perfect match
	    ret = list.shift();
	  } else {
	    // result spans more than one buffer
	    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
	  }
	  return ret;
	}
	
	// Copies a specified amount of characters from the list of buffered data
	// chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBufferString(n, list) {
	  var p = list.head;
	  var c = 1;
	  var ret = p.data;
	  n -= ret.length;
	  while (p = p.next) {
	    var str = p.data;
	    var nb = n > str.length ? str.length : n;
	    if (nb === str.length) ret += str;else ret += str.slice(0, n);
	    n -= nb;
	    if (n === 0) {
	      if (nb === str.length) {
	        ++c;
	        if (p.next) list.head = p.next;else list.head = list.tail = null;
	      } else {
	        list.head = p;
	        p.data = str.slice(nb);
	      }
	      break;
	    }
	    ++c;
	  }
	  list.length -= c;
	  return ret;
	}
	
	// Copies a specified amount of bytes from the list of buffered data chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBuffer(n, list) {
	  var ret = bufferShim.allocUnsafe(n);
	  var p = list.head;
	  var c = 1;
	  p.data.copy(ret);
	  n -= p.data.length;
	  while (p = p.next) {
	    var buf = p.data;
	    var nb = n > buf.length ? buf.length : n;
	    buf.copy(ret, ret.length - n, 0, nb);
	    n -= nb;
	    if (n === 0) {
	      if (nb === buf.length) {
	        ++c;
	        if (p.next) list.head = p.next;else list.head = list.tail = null;
	      } else {
	        list.head = p;
	        p.data = buf.slice(nb);
	      }
	      break;
	    }
	    ++c;
	  }
	  list.length -= c;
	  return ret;
	}
	
	function endReadable(stream) {
	  var state = stream._readableState;
	
	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
	
	  if (!state.endEmitted) {
	    state.ended = true;
	    processNextTick(endReadableNT, state, stream);
	  }
	}
	
	function endReadableNT(state, stream) {
	  // Check that we didn't get one last unshift.
	  if (!state.endEmitted && state.length === 0) {
	    state.endEmitted = true;
	    stream.readable = false;
	    stream.emit('end');
	  }
	}
	
	function forEach(xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}
	
	function indexOf(xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(294)))

/***/ },

/***/ 2000:
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },

/***/ 2002:
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Buffer = __webpack_require__(820).Buffer;
	/*<replacement>*/
	var bufferShim = __webpack_require__(1162);
	/*</replacement>*/
	
	module.exports = BufferList;
	
	function BufferList() {
	  this.head = null;
	  this.tail = null;
	  this.length = 0;
	}
	
	BufferList.prototype.push = function (v) {
	  var entry = { data: v, next: null };
	  if (this.length > 0) this.tail.next = entry;else this.head = entry;
	  this.tail = entry;
	  ++this.length;
	};
	
	BufferList.prototype.unshift = function (v) {
	  var entry = { data: v, next: this.head };
	  if (this.length === 0) this.tail = entry;
	  this.head = entry;
	  ++this.length;
	};
	
	BufferList.prototype.shift = function () {
	  if (this.length === 0) return;
	  var ret = this.head.data;
	  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
	  --this.length;
	  return ret;
	};
	
	BufferList.prototype.clear = function () {
	  this.head = this.tail = null;
	  this.length = 0;
	};
	
	BufferList.prototype.join = function (s) {
	  if (this.length === 0) return '';
	  var p = this.head;
	  var ret = '' + p.data;
	  while (p = p.next) {
	    ret += s + p.data;
	  }return ret;
	};
	
	BufferList.prototype.concat = function (n) {
	  if (this.length === 0) return bufferShim.alloc(0);
	  if (this.length === 1) return this.head.data;
	  var ret = bufferShim.allocUnsafe(n >>> 0);
	  var p = this.head;
	  var i = 0;
	  while (p) {
	    p.data.copy(ret, i);
	    i += p.data.length;
	    p = p.next;
	  }
	  return ret;
	};

/***/ },

/***/ 2003:
/***/ function(module, exports, __webpack_require__) {

	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.
	
	'use strict';
	
	/*<replacement>*/
	
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    keys.push(key);
	  }return keys;
	};
	/*</replacement>*/
	
	module.exports = Duplex;
	
	/*<replacement>*/
	var processNextTick = __webpack_require__(1160);
	/*</replacement>*/
	
	/*<replacement>*/
	var util = __webpack_require__(832);
	util.inherits = __webpack_require__(828);
	/*</replacement>*/
	
	var Readable = __webpack_require__(1999);
	var Writable = __webpack_require__(2004);
	
	util.inherits(Duplex, Readable);
	
	var keys = objectKeys(Writable.prototype);
	for (var v = 0; v < keys.length; v++) {
	  var method = keys[v];
	  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
	}
	
	function Duplex(options) {
	  if (!(this instanceof Duplex)) return new Duplex(options);
	
	  Readable.call(this, options);
	  Writable.call(this, options);
	
	  if (options && options.readable === false) this.readable = false;
	
	  if (options && options.writable === false) this.writable = false;
	
	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
	
	  this.once('end', onend);
	}
	
	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended) return;
	
	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  processNextTick(onEndNT, this);
	}
	
	function onEndNT(self) {
	  self.end();
	}
	
	function forEach(xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

/***/ },

/***/ 2004:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, setImmediate) {// A bit simpler than readable streams.
	// Implement an async ._write(chunk, encoding, cb), and it'll handle all
	// the drain event emission and buffering.
	
	'use strict';
	
	module.exports = Writable;
	
	/*<replacement>*/
	var processNextTick = __webpack_require__(1160);
	/*</replacement>*/
	
	/*<replacement>*/
	var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
	/*</replacement>*/
	
	Writable.WritableState = WritableState;
	
	/*<replacement>*/
	var util = __webpack_require__(832);
	util.inherits = __webpack_require__(828);
	/*</replacement>*/
	
	/*<replacement>*/
	var internalUtil = {
	  deprecate: __webpack_require__(1167)
	};
	/*</replacement>*/
	
	/*<replacement>*/
	var Stream;
	(function () {
	  try {
	    Stream = __webpack_require__(827);
	  } catch (_) {} finally {
	    if (!Stream) Stream = __webpack_require__(786).EventEmitter;
	  }
	})();
	/*</replacement>*/
	
	var Buffer = __webpack_require__(820).Buffer;
	/*<replacement>*/
	var bufferShim = __webpack_require__(1162);
	/*</replacement>*/
	
	util.inherits(Writable, Stream);
	
	function nop() {}
	
	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	  this.next = null;
	}
	
	var Duplex;
	function WritableState(options, stream) {
	  Duplex = Duplex || __webpack_require__(2003);
	
	  options = options || {};
	
	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;
	
	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
	
	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
	
	  // cast to ints.
	  this.highWaterMark = ~ ~this.highWaterMark;
	
	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;
	
	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;
	
	  // a flag to see when we're in the middle of a write.
	  this.writing = false;
	
	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;
	
	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function (er) {
	    onwrite(stream, er);
	  };
	
	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;
	
	  // the amount that is being written when _write is called.
	  this.writelen = 0;
	
	  this.bufferedRequest = null;
	  this.lastBufferedRequest = null;
	
	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;
	
	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;
	
	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	
	  // count buffered requests
	  this.bufferedRequestCount = 0;
	
	  // allocate the first CorkedRequest, there is always
	  // one allocated and free to use, and we maintain at most two
	  this.corkedRequestsFree = new CorkedRequest(this);
	}
	
	WritableState.prototype.getBuffer = function writableStateGetBuffer() {
	  var current = this.bufferedRequest;
	  var out = [];
	  while (current) {
	    out.push(current);
	    current = current.next;
	  }
	  return out;
	};
	
	(function () {
	  try {
	    Object.defineProperty(WritableState.prototype, 'buffer', {
	      get: internalUtil.deprecate(function () {
	        return this.getBuffer();
	      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
	    });
	  } catch (_) {}
	})();
	
	var Duplex;
	function Writable(options) {
	  Duplex = Duplex || __webpack_require__(2003);
	
	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);
	
	  this._writableState = new WritableState(options, this);
	
	  // legacy.
	  this.writable = true;
	
	  if (options) {
	    if (typeof options.write === 'function') this._write = options.write;
	
	    if (typeof options.writev === 'function') this._writev = options.writev;
	  }
	
	  Stream.call(this);
	}
	
	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function () {
	  this.emit('error', new Error('Cannot pipe, not readable'));
	};
	
	function writeAfterEnd(stream, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  processNextTick(cb, er);
	}
	
	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  var er = false;
	  // Always throw error if a null is written
	  // if we are not in object mode then throw
	  // if it is not a buffer, string, or undefined.
	  if (chunk === null) {
	    er = new TypeError('May not write null values to stream');
	  } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  if (er) {
	    stream.emit('error', er);
	    processNextTick(cb, er);
	    valid = false;
	  }
	  return valid;
	}
	
	Writable.prototype.write = function (chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;
	
	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
	
	  if (typeof cb !== 'function') cb = nop;
	
	  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }
	
	  return ret;
	};
	
	Writable.prototype.cork = function () {
	  var state = this._writableState;
	
	  state.corked++;
	};
	
	Writable.prototype.uncork = function () {
	  var state = this._writableState;
	
	  if (state.corked) {
	    state.corked--;
	
	    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
	  }
	};
	
	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
	  // node::ParseEncoding() requires lower case.
	  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
	  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
	  this._writableState.defaultEncoding = encoding;
	  return this;
	};
	
	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
	    chunk = bufferShim.from(chunk, encoding);
	  }
	  return chunk;
	}
	
	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	
	  if (Buffer.isBuffer(chunk)) encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;
	
	  state.length += len;
	
	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret) state.needDrain = true;
	
	  if (state.writing || state.corked) {
	    var last = state.lastBufferedRequest;
	    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
	    if (last) {
	      last.next = state.lastBufferedRequest;
	    } else {
	      state.bufferedRequest = state.lastBufferedRequest;
	    }
	    state.bufferedRequestCount += 1;
	  } else {
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	  }
	
	  return ret;
	}
	
	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}
	
	function onwriteError(stream, state, sync, er, cb) {
	  --state.pendingcb;
	  if (sync) processNextTick(cb, er);else cb(er);
	
	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}
	
	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}
	
	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;
	
	  onwriteStateUpdate(state);
	
	  if (er) onwriteError(stream, state, sync, er, cb);else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(state);
	
	    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
	      clearBuffer(stream, state);
	    }
	
	    if (sync) {
	      /*<replacement>*/
	      asyncWrite(afterWrite, stream, state, finished, cb);
	      /*</replacement>*/
	    } else {
	        afterWrite(stream, state, finished, cb);
	      }
	  }
	}
	
	function afterWrite(stream, state, finished, cb) {
	  if (!finished) onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}
	
	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}
	
	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	  var entry = state.bufferedRequest;
	
	  if (stream._writev && entry && entry.next) {
	    // Fast case, write everything using _writev()
	    var l = state.bufferedRequestCount;
	    var buffer = new Array(l);
	    var holder = state.corkedRequestsFree;
	    holder.entry = entry;
	
	    var count = 0;
	    while (entry) {
	      buffer[count] = entry;
	      entry = entry.next;
	      count += 1;
	    }
	
	    doWrite(stream, state, true, state.length, buffer, '', holder.finish);
	
	    // doWrite is almost always async, defer these to save a bit of time
	    // as the hot path ends with doWrite
	    state.pendingcb++;
	    state.lastBufferedRequest = null;
	    if (holder.next) {
	      state.corkedRequestsFree = holder.next;
	      holder.next = null;
	    } else {
	      state.corkedRequestsFree = new CorkedRequest(state);
	    }
	  } else {
	    // Slow case, write chunks one-by-one
	    while (entry) {
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;
	
	      doWrite(stream, state, false, len, chunk, encoding, cb);
	      entry = entry.next;
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        break;
	      }
	    }
	
	    if (entry === null) state.lastBufferedRequest = null;
	  }
	
	  state.bufferedRequestCount = 0;
	  state.bufferedRequest = entry;
	  state.bufferProcessing = false;
	}
	
	Writable.prototype._write = function (chunk, encoding, cb) {
	  cb(new Error('not implemented'));
	};
	
	Writable.prototype._writev = null;
	
	Writable.prototype.end = function (chunk, encoding, cb) {
	  var state = this._writableState;
	
	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);
	
	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }
	
	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished) endWritable(this, state, cb);
	};
	
	function needFinish(state) {
	  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
	}
	
	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}
	
	function finishMaybe(stream, state) {
	  var need = needFinish(state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else {
	      prefinish(stream, state);
	    }
	  }
	  return need;
	}
	
	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
	  }
	  state.ended = true;
	  stream.writable = false;
	}
	
	// It seems a linked list but it is not
	// there will be only 2 of these for each stream
	function CorkedRequest(state) {
	  var _this = this;
	
	  this.next = null;
	  this.entry = null;
	
	  this.finish = function (err) {
	    var entry = _this.entry;
	    _this.entry = null;
	    while (entry) {
	      var cb = entry.callback;
	      state.pendingcb--;
	      cb(err);
	      entry = entry.next;
	    }
	    if (state.corkedRequestsFree) {
	      state.corkedRequestsFree.next = _this;
	    } else {
	      state.corkedRequestsFree = _this;
	    }
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(294), __webpack_require__(702).setImmediate))

/***/ },

/***/ 2005:
/***/ function(module, exports, __webpack_require__) {

	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.
	
	'use strict';
	
	module.exports = Transform;
	
	var Duplex = __webpack_require__(2003);
	
	/*<replacement>*/
	var util = __webpack_require__(832);
	util.inherits = __webpack_require__(828);
	/*</replacement>*/
	
	util.inherits(Transform, Duplex);
	
	function TransformState(stream) {
	  this.afterTransform = function (er, data) {
	    return afterTransform(stream, er, data);
	  };
	
	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	  this.writeencoding = null;
	}
	
	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;
	
	  var cb = ts.writecb;
	
	  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));
	
	  ts.writechunk = null;
	  ts.writecb = null;
	
	  if (data !== null && data !== undefined) stream.push(data);
	
	  cb(er);
	
	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}
	
	function Transform(options) {
	  if (!(this instanceof Transform)) return new Transform(options);
	
	  Duplex.call(this, options);
	
	  this._transformState = new TransformState(this);
	
	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;
	
	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;
	
	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;
	
	  if (options) {
	    if (typeof options.transform === 'function') this._transform = options.transform;
	
	    if (typeof options.flush === 'function') this._flush = options.flush;
	  }
	
	  this.once('prefinish', function () {
	    if (typeof this._flush === 'function') this._flush(function (er) {
	      done(stream, er);
	    });else done(stream);
	  });
	}
	
	Transform.prototype.push = function (chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};
	
	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function (chunk, encoding, cb) {
	  throw new Error('Not implemented');
	};
	
	Transform.prototype._write = function (chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
	  }
	};
	
	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function (n) {
	  var ts = this._transformState;
	
	  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};
	
	function done(stream, er) {
	  if (er) return stream.emit('error', er);
	
	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;
	
	  if (ws.length) throw new Error('Calling transform done when ws.length != 0');
	
	  if (ts.transforming) throw new Error('Calling transform done when still transforming');
	
	  return stream.push(null);
	}

/***/ },

/***/ 2006:
/***/ function(module, exports, __webpack_require__) {

	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.
	
	'use strict';
	
	module.exports = PassThrough;
	
	var Transform = __webpack_require__(2005);
	
	/*<replacement>*/
	var util = __webpack_require__(832);
	util.inherits = __webpack_require__(828);
	/*</replacement>*/
	
	util.inherits(PassThrough, Transform);
	
	function PassThrough(options) {
	  if (!(this instanceof PassThrough)) return new PassThrough(options);
	
	  Transform.call(this, options);
	}
	
	PassThrough.prototype._transform = function (chunk, encoding, cb) {
	  cb(null, chunk);
	};

/***/ },

/***/ 2020:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	    value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _tweetnacl = __webpack_require__(2021);
	
	var _tweetnacl2 = _interopRequireDefault(_tweetnacl);
	
	var _utils = __webpack_require__(2023);
	
	var _default = (function () {
	    /**
	    * WARNING: THIS LIBRARY IS UNTESTED AND THEREFORE INSECURE. USE AT YOUR
	    * OWN RISK. Seriously. Don't expect any security at all from this.
	    *
	    * This class implements the no-header-keys, role-select version of
	    * Axolotl. This is very similar to the implementation that Whisper Systems
	    * uses. The only real caveat is that you have to set the role of each
	    * user, where 'alice' is the conversation initiator and 'bob' is the
	    * conversation receiver.
	    */
	
	    function _default() {
	        _classCallCheck(this, _default);
	
	        // Storage function that is set later on.
	        this._store = null;
	
	        // Internals for the protocol.
	        this._rootKey = null;
	        this._chainKeys = { send: null, recv: null };
	        this._identityKeys = { send: null, priv: null, recv: null };
	        this._ratchetKeys = { send: null, priv: null, recv: null };
	        this._counters = { send: null, recv: null };
	        this._prevCounter = null; // PNs
	
	        // Determine if we are going to ratchet.
	        this._ratchet = null;
	
	        this._skippedMessageKeys = [];
	        this._stagedSkippedMessageKeys = [];
	
	        // Am I Alice or Bob in this scenario?
	        this._role = null;
	        this._baseKeys = null;
	        this._theirBaseKey = null;
	    }
	
	    /**
	    * Set the persistent storage function, that will be called each time the
	    * converstation state needs to be saved. This function allows one to
	    * automatically have conversation state saved so that it can easily be
	    * resumed later on.
	    *
	    * It takes a storageFunc that takes two arguments: the data to be saved, and
	    * a callback for when the data is saved. A callback is used because it is
	    * 2015 and a callback provides more interop at the moment. This function
	    * does convert it to a promise for internal use, however.
	    *
	    * @param {Function} storageFunc - Function to be called for storing state
	    * @return {Object} this - For chaining.
	    */
	
	    _createClass(_default, [{
	        key: 'storage',
	        value: function storage(storageFunc) {
	            this._store = function (data) {
	                return new Promise(function (resolve, reject) {
	                    storageFunc(data, function (err, result) {
	                        if (err) return reject(err);else return resolve(result);
	                    });
	                });
	            };
	
	            return this;
	        }
	
	        /**
	        * Serialize our session to a simple object of strings, integers, and arrays
	        * so that it can easily be saved to disk.
	        *
	        * @return {Object} s - Object that can be used to resume a session.
	        */
	    }, {
	        key: 'serialize',
	        value: function serialize() {
	            /**
	            * One thing to keep in mind is to not accidentally mutate these values
	            * outside of this function, which is why I've listed the type above them
	            * (so that extra precautions are taken to clone things that are mutable)
	            */
	            var s = {
	                // Buffers.
	                rootKey: this._rootKey.toString('hex'),
	                chainKeys: Object.assign({}, this._chainKeys),
	
	                // Typed arrays.
	                identityKeys: Object.assign({}, this._identityKeys),
	                ratchetKeys: Object.assign({}, this._ratchetKeys),
	
	                // Integers.
	                counters: this._counters,
	                prevCounter: this._prevCounter,
	                role: this._role,
	
	                // Booleans.
	                ratchet: this._ratchet,
	
	                // Array (of hexdecimal strings.)
	                skippedMessageKeys: this._skippedMessageKeys.slice(0)
	            };
	
	            /**
	            * Once we've got our "safe" object (aka one that we can mutate without
	            * side effects), go through each property and convert them to their
	            * respective Base64 (if TypedArray) or hex (if Buffer) representation.
	            */
	            if (s.chainKeys.send !== null) {
	                s.chainKeys.send = s.chainKeys.send.toString('hex');
	            }
	
	            if (s.chainKeys.recv !== null) {
	                s.chainKeys.recv = s.chainKeys.recv.toString('hex');
	            }
	
	            /**
	            * This is just a concise way of going through all of the possible
	            * Uint8Array values and converting them to their Base64 equivalents.
	            */
	            ['identityKeys', 'ratchetKeys'].forEach(function (keySet) {
	                ['send', 'priv', 'recv'].forEach(function (keyType) {
	                    // As long as the value isn't null, convert it to Base64
	                    if (s[keySet][keyType] !== null) {
	                        s[keySet][keyType] = _utils.typedArray.toBase64(s[keySet][keyType]);
	                    }
	                });
	            });
	
	            return s;
	        }
	
	        /**
	        * Resume a session from a serialized session object.
	        *
	        * @param {Object} s - Result of calling the serialize() function.
	        * @return {Object} this
	        */
	    }, {
	        key: 'resume',
	        value: function resume(s) {
	            var _this = this;
	
	            // Set the root key.
	            this._rootKey = new Buffer(s.rootKey, 'hex');
	
	            // Convert hex values back to their buffer equivalents.
	            if (s.chainKeys.send !== null) {
	                this._chainKeys.send = new Buffer(s.chainKeys.send, 'hex');
	            }
	
	            if (s.chainKeys.recv !== null) {
	                this._chainKeys.recv = new Buffer(s.chainKeys.recv, 'hex');
	            }
	
	            /**
	            * Go through the potential Base64 values and convert them back to their
	            * Uint8Array representations.
	            */
	            ['identityKeys', 'ratchetKeys'].forEach(function (keySet) {
	                ['send', 'priv', 'recv'].forEach(function (keyType) {
	                    if (s[keySet][keyType] !== null) {
	                        _this['_' + keySet][keyType] = _tweetnacl2['default'].util.decodeBase64(s[keySet][keyType]);
	                    }
	                });
	            });
	
	            // Assign things that don't need to be unserialized.
	            this._counters = s.counters;
	            this._prevCounter = s.prevCounter;
	            this._role = s.role;
	            this._ratchet = s.ratchet;
	            this._skippedMessageKeys = s.skippedMessageKeys;
	
	            return this;
	        }
	
	        /**
	        * Set our identity keys. These are our long-lived keys that ensure we are
	        * who we say we are throughout all future Axolotl sessions.
	        *
	        * @param {Object} keypair - NaCl-generated key pair.
	        * @return {Object} this - This object (for chaining.)
	        */
	    }, {
	        key: 'identity',
	        value: function identity(keypair) {
	            if (!(keypair.hasOwnProperty('publicKey') && keypair.hasOwnProperty('secretKey') && keypair.publicKey instanceof Uint8Array && keypair.secretKey instanceof Uint8Array)) {
	                throw new Error('identityKeys: invalid key pair');
	            }
	
	            this._identityKeys.send = keypair.publicKey;
	            this._identityKeys.priv = keypair.secretKey;
	            return this;
	        }
	
	        /**
	        * Set our own base key. If we are the initiator (Alice), we can pick
	        * anything we'd like here, because we have the luxury of telling Bob which
	        * keys he's going to use to communicate with us. If we are Bob, we must pick
	        * the key that corresponds to the public pre-key Alice chose (otherwise, we
	        * would not be able to decrypt anything she sends us!)
	        *
	        * @param {Object} keypair - NaCl-generated key pair.
	        * @return {Object} this - This object (for chaining.)
	        */
	    }, {
	        key: 'handshake',
	        value: function handshake(keypair) {
	            if (!(keypair.hasOwnProperty('publicKey') && keypair.hasOwnProperty('secretKey') && keypair.publicKey instanceof Uint8Array && keypair.secretKey instanceof Uint8Array)) {
	                throw new Error('baseKeys: invalid key pair');
	            }
	
	            this._baseKeys = keypair;
	            return this;
	        }
	
	        /**
	        * Set the other party's base key, e.g. the key that was either received from
	        * from a pre-key message or pulled from a list of pre-keys on the server.
	        *
	        * @param {Uint8Array} publicKey - a NaCl-generated public key.
	        * @return {Object} this - This object (for chaining.)
	        */
	    }, {
	        key: 'theirHandshake',
	        value: function theirHandshake(publicKey) {
	            if (!publicKey instanceof Uint8Array) {
	                throw new Error('theirBaseKey: Expected Uint8Array for publicKey');
	            }
	
	            this._theirBaseKey = publicKey;
	            return this;
	        }
	
	        /**
	        * Set our role. 'alice' is the initiatior, 'bob' is the receiver. Note that
	        * 'alice' can also be substituted with 'initiatior'.
	        *
	        * @param {String} role - accepts 'alice', 'initiator', 'bob', 'receiver'
	        * @return {Object} this - This object (for chaining.)
	        */
	    }, {
	        key: 'setRole',
	        value: function setRole(role) {
	            if (role === 'alice' || role === 'initiator') this._role = 1;else if (role === 'bob' || role === 'receiver') this._role = 2;else throw new Error('setRole: Unexpected role assigned: ' + role);
	            return this;
	        }
	
	        /**
	        * Set the other party's identity key.
	        *
	        * @param {Uint8Array} publicKey - a NaCl-generated public key.
	        * @return {Object} this - This object (for chaining.)
	        */
	    }, {
	        key: 'theirIdentity',
	        value: function theirIdentity(publicKey) {
	            if (!publicKey instanceof Uint8Array) {
	                throw new Error('theirIdentityKey: Expected Uint8Array');
	            }
	
	            this._identityKeys.recv = publicKey;
	            return this;
	        }
	
	        /**
	        * Compute a shared master key, and subsequent shared chain keys and root
	        * keys.
	        *
	        * @param {TypedArray} publicKey - a NaCl-generated public key.
	        * @return {Promise}
	        */
	    }, {
	        key: 'computeMasterKey',
	        value: function computeMasterKey() {
	            var _this2 = this;
	
	            // Role must be assigned before we can compute a master key.
	            if (!this._role) {
	                throw new Error('computeMasterKey: Role must be assigned first!');
	            }
	
	            var keys = null;
	
	            // Role is important to how our master key is computed.
	            if (this._role === 1) {
	                /**
	                * We are Alice in this scenario. That means that our master
	                * key computation looks like:
	                *
	                * ECDHE(theirBase, ourIdentity)
	                * ECDHE(theirIdentity, ourBase)
	                * ECDHE(theirBase, ourBase)
	                */
	                keys = [_utils.crypto.dh(this._theirBaseKey, this._identityKeys.priv), _utils.crypto.dh(this._identityKeys.recv, this._baseKeys.secretKey), _utils.crypto.dh(this._theirBaseKey, this._baseKeys.secretKey)];
	            } else {
	                /**
	                * We are Bob in this scenario. That means that our master
	                * key computation looks like:
	                *
	                * ECDHE(theirIdentity, ourBase)
	                * ECDHE(theirBase, ourIdentity)
	                * ECDHE(theirBase, ourBase)
	                */
	                keys = [_utils.crypto.dh(this._identityKeys.recv, this._baseKeys.secretKey), _utils.crypto.dh(this._theirBaseKey, this._identityKeys.priv), _utils.crypto.dh(this._theirBaseKey, this._baseKeys.secretKey)];
	            }
	
	            /**
	            * We need to concatenate the three keys, and the easiest way to do this
	            * is to convert them to buffers, then concatenate the buffers.
	            */
	            var masterKeyMaterial = Buffer.concat(keys.map(function (key) {
	                return _utils.typedArray.toBuffer(key);
	            }));
	
	            // Create a master key that is 64 bytes long.
	            var masterKey = _utils.crypto.kdf(masterKeyMaterial, '', 100, 64);
	
	            // The root key is the first 32 bytes of the master key.
	            this._rootKey = masterKey.slice(0, 32);
	
	            // Initialize all of the message counters to zero.
	            this._counters.send = 0;
	            this._counters.recv = 0;
	            this._prevCounter = 0;
	
	            if (this._role === 1) {
	                /**
	                * We are Alice.
	                *
	                * The reception chain key is the second 32 bytes of the master key.
	                * This will be the chain key that Bob uses to send, hence why it's
	                * our recv key.
	                */
	                this._chainKeys.recv = masterKey.slice(32);
	                this._ratchetKeys.send = null;
	                this._ratchetKeys.priv = null;
	                this._ratchetKeys.recv = this._theirBaseKey;
	
	                // We are going to ratchet.
	                this._ratchet = true;
	            } else {
	                // Alice will have her receive key set to our send key.
	                this._chainKeys.send = masterKey.slice(32);
	
	                /**
	                * We need to set our ratchet send keys to our base keys, since those
	                * will correspond to the initial message Alice sends us as she will
	                * have used our pre-key (which is our base keys public key!)
	                */
	                this._ratchetKeys.send = this._baseKeys.publicKey;
	                this._ratchetKeys.priv = this._baseKeys.secretKey;
	
	                /**
	                * We won't have received a message from Alice yet (I mean, we might
	                * have, but this is the session setup so it doesn't matter yet) so
	                * set our ratchet receive key to null.
	                */
	                this._ratchetKeys.recv = null;
	
	                // And since we are Bob, we are not going to ratchet yet.
	                this._ratchet = false;
	            }
	
	            return new Promise(function (resolve, reject) {
	                if (!_this2._store) return resolve();
	
	                _this2._store(_this2.serialize()).then(function () {
	                    return resolve();
	                })['catch'](function (e) {
	                    return reject(e);
	                });
	            });
	        }
	
	        /**
	        * Encrypt a message.
	        *
	        * @param {String} cleartext - The message to be encrypted.
	        * @return {Promise}
	        */
	    }, {
	        key: 'encrypt',
	        value: function encrypt(cleartext) {
	            var _this3 = this;
	
	            if (this._ratchet === true) {
	                // Generate new sending key pair.
	                var newKeys = _utils.keys.newPair();
	
	                // The new keys are our new ratchet *sending* pair.
	                this._ratchetKeys.send = newKeys.publicKey;
	                this._ratchetKeys.priv = newKeys.secretKey;
	
	                /**
	                * Derive a new root key and chain key using our newly generated
	                * secret ratchet key and their ratchet public key. This is done by
	                * taking the result of a KDF on the DH result of their ratchet
	                * public key and our new private ratchet key.
	                */
	                var newKeyMaterial = _utils.crypto.kdf(_utils.typedArray.toBuffer(_utils.crypto.dh(this._ratchetKeys.recv, this._ratchetKeys.priv)), this._rootKey, 100, 64);
	
	                /**
	                * Just like in the session setup, the root key is the first 32
	                * bytes of the new key material, and the sending chain key is the
	                * second 32 bytes.
	                */
	                this._rootKey = newKeyMaterial.slice(0, 32);
	                this._chainKeys.send = newKeyMaterial.slice(32);
	
	                /**
	                * Since we have ratcheted, set the previous counter to the number of
	                * messages that we sent on this chain, then reset this chain's
	                * counter.
	                */
	                this._prevCounter = this._counters.send;
	                this._counters.send = 0;
	
	                // And, we're done ratcheting.
	                this._ratchet = false;
	            }
	
	            return new Promise(function (resolve, reject) {
	                /**
	                * For the message key, take the HMAC of the sending chain key with 0
	                * as the data.
	                */
	                var messageKey = _utils.crypto.hmac(_this3._chainKeys.send, '0');
	                var nonce = _tweetnacl2['default'].randomBytes(_tweetnacl2['default'].secretbox.nonceLength);
	                var ciphertext = _tweetnacl2['default'].secretbox(_tweetnacl2['default'].util.decodeUTF8(cleartext), nonce, _utils.buffer.toTypedArray(messageKey));
	
	                // return defensive copies
	                var message = {
	                    ephemeralKey: _utils.buffer.toTypedArray(_this3._ratchetKeys.send),
	                    counter: _this3._counters.send,
	                    previousCounter: _this3._prevCounter,
	                    ciphertext: _utils.buffer.toTypedArray(ciphertext),
	                    nonce: _utils.buffer.toTypedArray(nonce)
	                };
	
	                /**
	                * Update the sent counter. (because we're sending a message right
	                * now)
	                */
	                _this3._counters.send = _this3._counters.send + 1;
	
	                // Advance the chain key.
	                _this3._chainKeys.send = _utils.crypto.hmac(_this3._chainKeys.send, '1');
	
	                // And finally, give the user their encrypted message.
	                if (!_this3._store) return resolve(message);
	
	                _this3._store(_this3.serialize()).then(function () {
	                    return resolve(message);
	                })['catch'](function (e) {
	                    return reject(e);
	                });
	            });
	        }
	
	        /**
	        * Decrypt a message object.
	        *
	        * @param {Object} message - The message object to be decrypted.
	        * @param {Buffer|Uint8Array} message.ephemeralKey - ephemeral key
	        * @param {Number} message.counter - Number of messages sent on this chain
	        * @param {Number} message.previousCounter - Number of messages on prev chain
	        * @param {Buffer|Uint8Array} message.ciphertext - ciphertext to be decrypted
	        * @param {Buffer|Uint8Array} message.nonce - nonce for ciphertext
	        * @return {Promise}
	        */
	    }, {
	        key: 'decrypt',
	        value: function decrypt(message) {
	            var _this4 = this;
	
	            return new Promise(function (resolve, reject) {
	                if (!(message && message.hasOwnProperty('ephemeralKey') && message.hasOwnProperty('counter') && message.hasOwnProperty('previousCounter') && message.hasOwnProperty('ciphertext') && message.hasOwnProperty('nonce') && message.ephemeralKey.length === 32 && message.nonce.length === 24 && message.ciphertext.length > 0 && !isNaN(message.counter) && !isNaN(message.previousCounter))) {
	                    return reject(new Error('decrypt: Message object invalid.'));
	                }
	
	                var messageCounter = message.counter;
	                var decryptedMessage = undefined;
	                var pChainKey = undefined;
	
	                /**
	                * Before we try anything, we need to see if we can decrypt this
	                * message with a key that corresponds to a skipped message (e.g. a
	                * message we didn't receive)
	                */
	
	                var _loop = function () {
	                    /**
	                    * Get the current index out of the skipped message keys, and
	                    * convert it from hex back to a buffer.
	                    */
	                    var thisKey = new Buffer(_this4._skippedMessageKeys[i], 'hex');
	
	                    // Attempt to decrypt the message.
	                    decryptedMessage = _tweetnacl2['default'].secretbox.open(message.ciphertext, message.nonce, _utils.buffer.toTypedArray(thisKey));
	
	                    var cleartext = _tweetnacl2['default'].util.encodeUTF8(decryptedMessage);
	
	                    /**
	                    * If the message is successfully decrypted with one of these
	                    * keys, then we've received an out-of-order message.
	                    */
	                    if (decryptedMessage !== false) {
	                        /**
	                        * Remove the key we used to decrypt this message from
	                        * storage, since we should under no circumstances need it
	                        * again.
	                        */
	                        _this4.consumeMessageKey(i);
	
	                        if (!_this4._store) {
	                            return {
	                                v: resolve({ cleartext: cleartext, outOfOrder: true })
	                            };
	                        }
	
	                        return {
	                            v: _this4._store(_this4.serialize()).then(function () {
	                                return resolve({
	                                    cleartext: cleartext, outOfOrder: true
	                                });
	                            })['catch'](function (e) {
	                                return reject(e);
	                            })
	                        };
	                    }
	                };
	
	                for (var i = 0; i < _this4._skippedMessageKeys.length; i++) {
	                    var _ret = _loop();
	
	                    if (typeof _ret === 'object') return _ret.v;
	                }
	
	                /*
	                * If we do not have a receiving ratchet key set OR if this message
	                * contains an ephemeral key that isn't the same as our current
	                * receiving ratchet key, we are about to ratchet.
	                */
	                if (_this4._ratchetKeys.recv === null || !_utils.buffer.equals(_this4._ratchetKeys.recv, message.ephemeralKey)) {
	                    if (_this4._ratchet === true) {
	                        /**
	                        * We are already ratcheting, this message is undecryptable
	                        * because we already threw away our keys.
	                        */
	                        throw new Error('Undecryptable message, ratchet broken.');
	                    }
	
	                    /**
	                    * Set the purported previous counter, and the purported next
	                    * ratchet receive key.
	                    */
	                    var pPrevCounter = message.previousCounter;
	                    var pRatchetRecv = message.ephemeralKey;
	
	                    /**
	                    * The spec says to stage all of the keys for the previous
	                    * counter to the current counter. This is because if we missed
	                    * some messages from the last chain, the previous counter value
	                    * will be the last message sent on the last chain, and the
	                    * current counter will be the last message we received on the
	                    * last chain, since we will have not changed chains just yet.
	                    *
	                    * Note that we do not need to save the message key generated
	                    * here to use in this iteration, because the message we have
	                    * received WILL be on the new chain, making this message key
	                    * irrelevant.
	                    */
	                    _this4.stageSkippedMessageKeys(_this4._counters.recv, pPrevCounter, _this4._chainKeys.recv);
	
	                    /**
	                    * We are going to be on a new root thanks to this new key, so we
	                    * need to calculate the new chain key and root key.
	                    */
	                    var newKeyMaterial = _utils.crypto.kdf(_utils.typedArray.toBuffer(_utils.crypto.dh(pRatchetRecv, _this4._ratchetKeys.priv)), _this4._rootKey, 100, 64);
	
	                    // Hold on to the new purported keys.
	                    var pRootKey = newKeyMaterial.slice(0, 32);
	                    pChainKey = newKeyMaterial.slice(32);
	
	                    /**
	                    * Calculate all of the keys from the start of this chain to the
	                    * counter of the message we just received.
	                    */
	                    var stagedKeys = _this4.stageSkippedMessageKeys(0, messageCounter, pChainKey);
	
	                    /**
	                    * This is the last key generated by stageSkippedNessageKeys,
	                    * which should be for the message we just received.
	                    */
	                    var messageKey = stagedKeys.messageKey;
	
	                    /**
	                    * pChainKey will already be defined, because it was just set
	                    * from  the key material above, and then used in the staged key
	                    * calculation.
	                    */
	                    pChainKey = stagedKeys.chainKey;
	
	                    // Attempt to decrypt the message.
	                    decryptedMessage = _tweetnacl2['default'].secretbox.open(message.ciphertext, message.nonce, _utils.buffer.toTypedArray(messageKey));
	
	                    /**
	                    * If the message fails to decrypt at this point, it will be
	                    * because we ratcheted and didn't have a record of the previous
	                    * keys. Or, the message was corrupt.
	                    */
	                    if (decryptedMessage === false) {
	                        /**
	                        * Remove all of the keys we staged during this decryption
	                        * attempt.
	                        */
	                        _this4.cleanStagedKeys();
	                        return reject(new Error('Undecryptable message.'));
	                    }
	
	                    // If it didn't fail to decrypt, move the ratchet forward.
	                    _this4._rootKey = pRootKey;
	                    _this4._ratchetKeys.recv = pRatchetRecv;
	
	                    // Clear out our private material.
	                    _this4._ratchetKeys.send = null;
	                    _this4._ratchetKeys.priv = null;
	
	                    // We're going to ratchet next time around.
	                    _this4._ratchet = true;
	                } else {
	                    /*
	                    * There is no new ephemeral key, which means that we are going
	                    * to continue down the current chain.
	                    *
	                    * Stage all keys from the last received to the message counter.
	                    */
	                    var stagedKeys = _this4.stageSkippedMessageKeys(_this4._counters.recv, messageCounter, _this4._chainKeys.recv);
	
	                    /**
	                    * Get the message key and new chain key from the last staged key
	                    * (which should match the message we just received)
	                    */
	                    var messageKey = stagedKeys.messageKey;
	
	                    pChainKey = stagedKeys.chainKey;
	
	                    decryptedMessage = _tweetnacl2['default'].secretbox.open(message.ciphertext, message.nonce, _utils.buffer.toTypedArray(messageKey));
	
	                    /**
	                    * If we fail to decrypt here, it is because the message itself
	                    * was invalid.
	                    */
	                    if (decryptedMessage === false) {
	                        _this4.cleanStagedKeys();
	                        return reject(new Error('Undecryptable message.'));
	                    }
	                }
	
	                /**
	                * Okay, if we made it this far, we've got a decrypted message ready
	                * to be returned. Commit all of the keys we've staged up until this
	                * point, as they may be needed to decrypt messages received later
	                * on.
	                */
	                _this4.commitStagedKeys();
	
	                // Update the received counter.
	                _this4._counters.recv = messageCounter + 1;
	
	                /**
	                * Update the recv chain key to the one that was purported
	                * earlier on.
	                */
	                _this4._chainKeys.recv = pChainKey;
	
	                /**
	                * decryptedMessage is still in buffer format, we need to get it
	                * in UTF8 so that it's actually readable.
	                */
	                var cleartext = _tweetnacl2['default'].util.encodeUTF8(decryptedMessage);
	
	                // And finally, give the user their encrypted message.
	                if (!_this4._store) return resolve({ cleartext: cleartext });
	
	                _this4._store(_this4.serialize()).then(function () {
	                    return resolve({ cleartext: cleartext });
	                })['catch'](function (e) {
	                    return reject(e);
	                });
	            });
	        }
	
	        /**
	        * Stage all possible message keys from a set start point to a set end point.
	        *
	        * @param {Number} lCounterRecv - Message number in the chain to start with
	        * @param {Number} lMessageCounter -  Message number in the chain to end with
	        * @param {String} lChainKeyRecv - The chain key to compute message keys for
	        * @return {Object} keys - An object with the last message key and chain key
	        */
	    }, {
	        key: 'stageSkippedMessageKeys',
	        value: function stageSkippedMessageKeys(lCounterRecv, lMessageCounter, lChainKeyRecv) {
	            if (!Buffer.isBuffer(lChainKeyRecv)) {
	                // If the chain key isn't a buffer, just do nothing.
	                return;
	            }
	
	            var chainKey = lChainKeyRecv;
	
	            /**
	            * If the root key is still the same, then we are advancing the chain
	            * right off the bat. Otherwise, we are going to use the new chain key
	            * we just derived from the master key.
	            */
	            if (lCounterRecv !== 0) chainKey = _utils.crypto.hmac(chainKey, '1');
	
	            /**
	            * Run the first calculation outside the loop, because we might be on the
	            * first chain.
	            */
	            var messageKey = _utils.crypto.hmac(chainKey, '0');
	
	            // Stage the key we just calculated.
	            this.stageKey(messageKey);
	
	            // Now, calculate all of the possible iterations.
	            for (var currentMessage = lCounterRecv; currentMessage < lMessageCounter; currentMessage++) {
	                chainKey = _utils.crypto.hmac(chainKey, '1');
	                messageKey = _utils.crypto.hmac(chainKey, '0');
	                this.stageKey(messageKey);
	            }
	
	            /**
	            * Remove the last element of the staged keys, since it's going to be the
	            * one we return from this function (it will be used immediately) and we
	            * don't want used keys clogging the skipped keys storage.
	            */
	            this._stagedSkippedMessageKeys.pop();
	
	            return { messageKey: messageKey, chainKey: chainKey };
	        }
	
	        /**
	        * Add a key to the staging area (just an in-memory array, persistence is not
	        * required here).
	        *
	        * @param {Buffer|String} key
	        */
	    }, {
	        key: 'stageKey',
	        value: function stageKey(key) {
	            var stagedKey = key;
	
	            // If the message key is a buffer, convert it to hex for storage.
	            if (Buffer.isBuffer(stagedKey)) {
	                stagedKey = stagedKey.toString('hex');
	            }
	
	            this._stagedSkippedMessageKeys.push(stagedKey);
	            return;
	        }
	
	        /**
	        * Clear the key staging area.
	        */
	    }, {
	        key: 'cleanStagedKeys',
	        value: function cleanStagedKeys() {
	            this._stagedSkippedMessageKeys = [];
	            return;
	        }
	
	        /**
	        * Commit all of the staged keys to permanent storage.
	        */
	    }, {
	        key: 'commitStagedKeys',
	        value: function commitStagedKeys() {
	            this._skippedMessageKeys = this._skippedMessageKeys.concat(this._stagedSkippedMessageKeys);
	            return;
	        }
	
	        /**
	        * Remove a used key from the key storage.
	        *
	        * @param {Number} keyIndex - the index of the key to be removed
	        * @return {Promise}
	        */
	    }, {
	        key: 'consumeMessageKey',
	        value: function consumeMessageKey(keyIndex) {
	            this._skippedMessageKeys.splice(keyIndex, 1);
	            return;
	        }
	    }]);
	
	    return _default;
	})();
	
	exports['default'] = _default;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(820).Buffer))

/***/ },

/***/ 2021:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {(function(nacl) {
	'use strict';
	
	// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
	// Public domain.
	//
	// Implementation derived from TweetNaCl version 20140427.
	// See for details: http://tweetnacl.cr.yp.to/
	
	var gf = function(init) {
	  var i, r = new Float64Array(16);
	  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
	  return r;
	};
	
	//  Pluggable, initialized in high-level API below.
	var randombytes = function(/* x, n */) { throw new Error('no PRNG'); };
	
	var _0 = new Uint8Array(16);
	var _9 = new Uint8Array(32); _9[0] = 9;
	
	var gf0 = gf(),
	    gf1 = gf([1]),
	    _121665 = gf([0xdb41, 1]),
	    D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),
	    D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),
	    X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),
	    Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),
	    I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);
	
	function ts64(x, i, h, l) {
	  x[i]   = (h >> 24) & 0xff;
	  x[i+1] = (h >> 16) & 0xff;
	  x[i+2] = (h >>  8) & 0xff;
	  x[i+3] = h & 0xff;
	  x[i+4] = (l >> 24)  & 0xff;
	  x[i+5] = (l >> 16)  & 0xff;
	  x[i+6] = (l >>  8)  & 0xff;
	  x[i+7] = l & 0xff;
	}
	
	function vn(x, xi, y, yi, n) {
	  var i,d = 0;
	  for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];
	  return (1 & ((d - 1) >>> 8)) - 1;
	}
	
	function crypto_verify_16(x, xi, y, yi) {
	  return vn(x,xi,y,yi,16);
	}
	
	function crypto_verify_32(x, xi, y, yi) {
	  return vn(x,xi,y,yi,32);
	}
	
	function core_salsa20(o, p, k, c) {
	  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
	      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
	      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
	      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
	      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
	      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
	      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
	      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
	      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
	      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
	      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
	      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
	      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
	      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
	      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
	      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;
	
	  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
	      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
	      x15 = j15, u;
	
	  for (var i = 0; i < 20; i += 2) {
	    u = x0 + x12 | 0;
	    x4 ^= u<<7 | u>>>(32-7);
	    u = x4 + x0 | 0;
	    x8 ^= u<<9 | u>>>(32-9);
	    u = x8 + x4 | 0;
	    x12 ^= u<<13 | u>>>(32-13);
	    u = x12 + x8 | 0;
	    x0 ^= u<<18 | u>>>(32-18);
	
	    u = x5 + x1 | 0;
	    x9 ^= u<<7 | u>>>(32-7);
	    u = x9 + x5 | 0;
	    x13 ^= u<<9 | u>>>(32-9);
	    u = x13 + x9 | 0;
	    x1 ^= u<<13 | u>>>(32-13);
	    u = x1 + x13 | 0;
	    x5 ^= u<<18 | u>>>(32-18);
	
	    u = x10 + x6 | 0;
	    x14 ^= u<<7 | u>>>(32-7);
	    u = x14 + x10 | 0;
	    x2 ^= u<<9 | u>>>(32-9);
	    u = x2 + x14 | 0;
	    x6 ^= u<<13 | u>>>(32-13);
	    u = x6 + x2 | 0;
	    x10 ^= u<<18 | u>>>(32-18);
	
	    u = x15 + x11 | 0;
	    x3 ^= u<<7 | u>>>(32-7);
	    u = x3 + x15 | 0;
	    x7 ^= u<<9 | u>>>(32-9);
	    u = x7 + x3 | 0;
	    x11 ^= u<<13 | u>>>(32-13);
	    u = x11 + x7 | 0;
	    x15 ^= u<<18 | u>>>(32-18);
	
	    u = x0 + x3 | 0;
	    x1 ^= u<<7 | u>>>(32-7);
	    u = x1 + x0 | 0;
	    x2 ^= u<<9 | u>>>(32-9);
	    u = x2 + x1 | 0;
	    x3 ^= u<<13 | u>>>(32-13);
	    u = x3 + x2 | 0;
	    x0 ^= u<<18 | u>>>(32-18);
	
	    u = x5 + x4 | 0;
	    x6 ^= u<<7 | u>>>(32-7);
	    u = x6 + x5 | 0;
	    x7 ^= u<<9 | u>>>(32-9);
	    u = x7 + x6 | 0;
	    x4 ^= u<<13 | u>>>(32-13);
	    u = x4 + x7 | 0;
	    x5 ^= u<<18 | u>>>(32-18);
	
	    u = x10 + x9 | 0;
	    x11 ^= u<<7 | u>>>(32-7);
	    u = x11 + x10 | 0;
	    x8 ^= u<<9 | u>>>(32-9);
	    u = x8 + x11 | 0;
	    x9 ^= u<<13 | u>>>(32-13);
	    u = x9 + x8 | 0;
	    x10 ^= u<<18 | u>>>(32-18);
	
	    u = x15 + x14 | 0;
	    x12 ^= u<<7 | u>>>(32-7);
	    u = x12 + x15 | 0;
	    x13 ^= u<<9 | u>>>(32-9);
	    u = x13 + x12 | 0;
	    x14 ^= u<<13 | u>>>(32-13);
	    u = x14 + x13 | 0;
	    x15 ^= u<<18 | u>>>(32-18);
	  }
	   x0 =  x0 +  j0 | 0;
	   x1 =  x1 +  j1 | 0;
	   x2 =  x2 +  j2 | 0;
	   x3 =  x3 +  j3 | 0;
	   x4 =  x4 +  j4 | 0;
	   x5 =  x5 +  j5 | 0;
	   x6 =  x6 +  j6 | 0;
	   x7 =  x7 +  j7 | 0;
	   x8 =  x8 +  j8 | 0;
	   x9 =  x9 +  j9 | 0;
	  x10 = x10 + j10 | 0;
	  x11 = x11 + j11 | 0;
	  x12 = x12 + j12 | 0;
	  x13 = x13 + j13 | 0;
	  x14 = x14 + j14 | 0;
	  x15 = x15 + j15 | 0;
	
	  o[ 0] = x0 >>>  0 & 0xff;
	  o[ 1] = x0 >>>  8 & 0xff;
	  o[ 2] = x0 >>> 16 & 0xff;
	  o[ 3] = x0 >>> 24 & 0xff;
	
	  o[ 4] = x1 >>>  0 & 0xff;
	  o[ 5] = x1 >>>  8 & 0xff;
	  o[ 6] = x1 >>> 16 & 0xff;
	  o[ 7] = x1 >>> 24 & 0xff;
	
	  o[ 8] = x2 >>>  0 & 0xff;
	  o[ 9] = x2 >>>  8 & 0xff;
	  o[10] = x2 >>> 16 & 0xff;
	  o[11] = x2 >>> 24 & 0xff;
	
	  o[12] = x3 >>>  0 & 0xff;
	  o[13] = x3 >>>  8 & 0xff;
	  o[14] = x3 >>> 16 & 0xff;
	  o[15] = x3 >>> 24 & 0xff;
	
	  o[16] = x4 >>>  0 & 0xff;
	  o[17] = x4 >>>  8 & 0xff;
	  o[18] = x4 >>> 16 & 0xff;
	  o[19] = x4 >>> 24 & 0xff;
	
	  o[20] = x5 >>>  0 & 0xff;
	  o[21] = x5 >>>  8 & 0xff;
	  o[22] = x5 >>> 16 & 0xff;
	  o[23] = x5 >>> 24 & 0xff;
	
	  o[24] = x6 >>>  0 & 0xff;
	  o[25] = x6 >>>  8 & 0xff;
	  o[26] = x6 >>> 16 & 0xff;
	  o[27] = x6 >>> 24 & 0xff;
	
	  o[28] = x7 >>>  0 & 0xff;
	  o[29] = x7 >>>  8 & 0xff;
	  o[30] = x7 >>> 16 & 0xff;
	  o[31] = x7 >>> 24 & 0xff;
	
	  o[32] = x8 >>>  0 & 0xff;
	  o[33] = x8 >>>  8 & 0xff;
	  o[34] = x8 >>> 16 & 0xff;
	  o[35] = x8 >>> 24 & 0xff;
	
	  o[36] = x9 >>>  0 & 0xff;
	  o[37] = x9 >>>  8 & 0xff;
	  o[38] = x9 >>> 16 & 0xff;
	  o[39] = x9 >>> 24 & 0xff;
	
	  o[40] = x10 >>>  0 & 0xff;
	  o[41] = x10 >>>  8 & 0xff;
	  o[42] = x10 >>> 16 & 0xff;
	  o[43] = x10 >>> 24 & 0xff;
	
	  o[44] = x11 >>>  0 & 0xff;
	  o[45] = x11 >>>  8 & 0xff;
	  o[46] = x11 >>> 16 & 0xff;
	  o[47] = x11 >>> 24 & 0xff;
	
	  o[48] = x12 >>>  0 & 0xff;
	  o[49] = x12 >>>  8 & 0xff;
	  o[50] = x12 >>> 16 & 0xff;
	  o[51] = x12 >>> 24 & 0xff;
	
	  o[52] = x13 >>>  0 & 0xff;
	  o[53] = x13 >>>  8 & 0xff;
	  o[54] = x13 >>> 16 & 0xff;
	  o[55] = x13 >>> 24 & 0xff;
	
	  o[56] = x14 >>>  0 & 0xff;
	  o[57] = x14 >>>  8 & 0xff;
	  o[58] = x14 >>> 16 & 0xff;
	  o[59] = x14 >>> 24 & 0xff;
	
	  o[60] = x15 >>>  0 & 0xff;
	  o[61] = x15 >>>  8 & 0xff;
	  o[62] = x15 >>> 16 & 0xff;
	  o[63] = x15 >>> 24 & 0xff;
	}
	
	function core_hsalsa20(o,p,k,c) {
	  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
	      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
	      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
	      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
	      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
	      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
	      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
	      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
	      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
	      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
	      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
	      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
	      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
	      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
	      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
	      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;
	
	  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
	      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
	      x15 = j15, u;
	
	  for (var i = 0; i < 20; i += 2) {
	    u = x0 + x12 | 0;
	    x4 ^= u<<7 | u>>>(32-7);
	    u = x4 + x0 | 0;
	    x8 ^= u<<9 | u>>>(32-9);
	    u = x8 + x4 | 0;
	    x12 ^= u<<13 | u>>>(32-13);
	    u = x12 + x8 | 0;
	    x0 ^= u<<18 | u>>>(32-18);
	
	    u = x5 + x1 | 0;
	    x9 ^= u<<7 | u>>>(32-7);
	    u = x9 + x5 | 0;
	    x13 ^= u<<9 | u>>>(32-9);
	    u = x13 + x9 | 0;
	    x1 ^= u<<13 | u>>>(32-13);
	    u = x1 + x13 | 0;
	    x5 ^= u<<18 | u>>>(32-18);
	
	    u = x10 + x6 | 0;
	    x14 ^= u<<7 | u>>>(32-7);
	    u = x14 + x10 | 0;
	    x2 ^= u<<9 | u>>>(32-9);
	    u = x2 + x14 | 0;
	    x6 ^= u<<13 | u>>>(32-13);
	    u = x6 + x2 | 0;
	    x10 ^= u<<18 | u>>>(32-18);
	
	    u = x15 + x11 | 0;
	    x3 ^= u<<7 | u>>>(32-7);
	    u = x3 + x15 | 0;
	    x7 ^= u<<9 | u>>>(32-9);
	    u = x7 + x3 | 0;
	    x11 ^= u<<13 | u>>>(32-13);
	    u = x11 + x7 | 0;
	    x15 ^= u<<18 | u>>>(32-18);
	
	    u = x0 + x3 | 0;
	    x1 ^= u<<7 | u>>>(32-7);
	    u = x1 + x0 | 0;
	    x2 ^= u<<9 | u>>>(32-9);
	    u = x2 + x1 | 0;
	    x3 ^= u<<13 | u>>>(32-13);
	    u = x3 + x2 | 0;
	    x0 ^= u<<18 | u>>>(32-18);
	
	    u = x5 + x4 | 0;
	    x6 ^= u<<7 | u>>>(32-7);
	    u = x6 + x5 | 0;
	    x7 ^= u<<9 | u>>>(32-9);
	    u = x7 + x6 | 0;
	    x4 ^= u<<13 | u>>>(32-13);
	    u = x4 + x7 | 0;
	    x5 ^= u<<18 | u>>>(32-18);
	
	    u = x10 + x9 | 0;
	    x11 ^= u<<7 | u>>>(32-7);
	    u = x11 + x10 | 0;
	    x8 ^= u<<9 | u>>>(32-9);
	    u = x8 + x11 | 0;
	    x9 ^= u<<13 | u>>>(32-13);
	    u = x9 + x8 | 0;
	    x10 ^= u<<18 | u>>>(32-18);
	
	    u = x15 + x14 | 0;
	    x12 ^= u<<7 | u>>>(32-7);
	    u = x12 + x15 | 0;
	    x13 ^= u<<9 | u>>>(32-9);
	    u = x13 + x12 | 0;
	    x14 ^= u<<13 | u>>>(32-13);
	    u = x14 + x13 | 0;
	    x15 ^= u<<18 | u>>>(32-18);
	  }
	
	  o[ 0] = x0 >>>  0 & 0xff;
	  o[ 1] = x0 >>>  8 & 0xff;
	  o[ 2] = x0 >>> 16 & 0xff;
	  o[ 3] = x0 >>> 24 & 0xff;
	
	  o[ 4] = x5 >>>  0 & 0xff;
	  o[ 5] = x5 >>>  8 & 0xff;
	  o[ 6] = x5 >>> 16 & 0xff;
	  o[ 7] = x5 >>> 24 & 0xff;
	
	  o[ 8] = x10 >>>  0 & 0xff;
	  o[ 9] = x10 >>>  8 & 0xff;
	  o[10] = x10 >>> 16 & 0xff;
	  o[11] = x10 >>> 24 & 0xff;
	
	  o[12] = x15 >>>  0 & 0xff;
	  o[13] = x15 >>>  8 & 0xff;
	  o[14] = x15 >>> 16 & 0xff;
	  o[15] = x15 >>> 24 & 0xff;
	
	  o[16] = x6 >>>  0 & 0xff;
	  o[17] = x6 >>>  8 & 0xff;
	  o[18] = x6 >>> 16 & 0xff;
	  o[19] = x6 >>> 24 & 0xff;
	
	  o[20] = x7 >>>  0 & 0xff;
	  o[21] = x7 >>>  8 & 0xff;
	  o[22] = x7 >>> 16 & 0xff;
	  o[23] = x7 >>> 24 & 0xff;
	
	  o[24] = x8 >>>  0 & 0xff;
	  o[25] = x8 >>>  8 & 0xff;
	  o[26] = x8 >>> 16 & 0xff;
	  o[27] = x8 >>> 24 & 0xff;
	
	  o[28] = x9 >>>  0 & 0xff;
	  o[29] = x9 >>>  8 & 0xff;
	  o[30] = x9 >>> 16 & 0xff;
	  o[31] = x9 >>> 24 & 0xff;
	}
	
	function crypto_core_salsa20(out,inp,k,c) {
	  core_salsa20(out,inp,k,c);
	}
	
	function crypto_core_hsalsa20(out,inp,k,c) {
	  core_hsalsa20(out,inp,k,c);
	}
	
	var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
	            // "expand 32-byte k"
	
	function crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {
	  var z = new Uint8Array(16), x = new Uint8Array(64);
	  var u, i;
	  for (i = 0; i < 16; i++) z[i] = 0;
	  for (i = 0; i < 8; i++) z[i] = n[i];
	  while (b >= 64) {
	    crypto_core_salsa20(x,z,k,sigma);
	    for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];
	    u = 1;
	    for (i = 8; i < 16; i++) {
	      u = u + (z[i] & 0xff) | 0;
	      z[i] = u & 0xff;
	      u >>>= 8;
	    }
	    b -= 64;
	    cpos += 64;
	    mpos += 64;
	  }
	  if (b > 0) {
	    crypto_core_salsa20(x,z,k,sigma);
	    for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];
	  }
	  return 0;
	}
	
	function crypto_stream_salsa20(c,cpos,b,n,k) {
	  var z = new Uint8Array(16), x = new Uint8Array(64);
	  var u, i;
	  for (i = 0; i < 16; i++) z[i] = 0;
	  for (i = 0; i < 8; i++) z[i] = n[i];
	  while (b >= 64) {
	    crypto_core_salsa20(x,z,k,sigma);
	    for (i = 0; i < 64; i++) c[cpos+i] = x[i];
	    u = 1;
	    for (i = 8; i < 16; i++) {
	      u = u + (z[i] & 0xff) | 0;
	      z[i] = u & 0xff;
	      u >>>= 8;
	    }
	    b -= 64;
	    cpos += 64;
	  }
	  if (b > 0) {
	    crypto_core_salsa20(x,z,k,sigma);
	    for (i = 0; i < b; i++) c[cpos+i] = x[i];
	  }
	  return 0;
	}
	
	function crypto_stream(c,cpos,d,n,k) {
	  var s = new Uint8Array(32);
	  crypto_core_hsalsa20(s,n,k,sigma);
	  var sn = new Uint8Array(8);
	  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
	  return crypto_stream_salsa20(c,cpos,d,sn,s);
	}
	
	function crypto_stream_xor(c,cpos,m,mpos,d,n,k) {
	  var s = new Uint8Array(32);
	  crypto_core_hsalsa20(s,n,k,sigma);
	  var sn = new Uint8Array(8);
	  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
	  return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);
	}
	
	/*
	* Port of Andrew Moon's Poly1305-donna-16. Public domain.
	* https://github.com/floodyberry/poly1305-donna
	*/
	
	var poly1305 = function(key) {
	  this.buffer = new Uint8Array(16);
	  this.r = new Uint16Array(10);
	  this.h = new Uint16Array(10);
	  this.pad = new Uint16Array(8);
	  this.leftover = 0;
	  this.fin = 0;
	
	  var t0, t1, t2, t3, t4, t5, t6, t7;
	
	  t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;
	  t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
	  t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;
	  t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
	  t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;
	  this.r[5] = ((t4 >>>  1)) & 0x1ffe;
	  t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
	  t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;
	  t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
	  this.r[9] = ((t7 >>>  5)) & 0x007f;
	
	  this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;
	  this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;
	  this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;
	  this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;
	  this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;
	  this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;
	  this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;
	  this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;
	};
	
	poly1305.prototype.blocks = function(m, mpos, bytes) {
	  var hibit = this.fin ? 0 : (1 << 11);
	  var t0, t1, t2, t3, t4, t5, t6, t7, c;
	  var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
	
	  var h0 = this.h[0],
	      h1 = this.h[1],
	      h2 = this.h[2],
	      h3 = this.h[3],
	      h4 = this.h[4],
	      h5 = this.h[5],
	      h6 = this.h[6],
	      h7 = this.h[7],
	      h8 = this.h[8],
	      h9 = this.h[9];
	
	  var r0 = this.r[0],
	      r1 = this.r[1],
	      r2 = this.r[2],
	      r3 = this.r[3],
	      r4 = this.r[4],
	      r5 = this.r[5],
	      r6 = this.r[6],
	      r7 = this.r[7],
	      r8 = this.r[8],
	      r9 = this.r[9];
	
	  while (bytes >= 16) {
	    t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;
	    t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
	    t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;
	    t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
	    t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;
	    h5 += ((t4 >>>  1)) & 0x1fff;
	    t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
	    t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;
	    t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
	    h9 += ((t7 >>> 5)) | hibit;
	
	    c = 0;
	
	    d0 = c;
	    d0 += h0 * r0;
	    d0 += h1 * (5 * r9);
	    d0 += h2 * (5 * r8);
	    d0 += h3 * (5 * r7);
	    d0 += h4 * (5 * r6);
	    c = (d0 >>> 13); d0 &= 0x1fff;
	    d0 += h5 * (5 * r5);
	    d0 += h6 * (5 * r4);
	    d0 += h7 * (5 * r3);
	    d0 += h8 * (5 * r2);
	    d0 += h9 * (5 * r1);
	    c += (d0 >>> 13); d0 &= 0x1fff;
	
	    d1 = c;
	    d1 += h0 * r1;
	    d1 += h1 * r0;
	    d1 += h2 * (5 * r9);
	    d1 += h3 * (5 * r8);
	    d1 += h4 * (5 * r7);
	    c = (d1 >>> 13); d1 &= 0x1fff;
	    d1 += h5 * (5 * r6);
	    d1 += h6 * (5 * r5);
	    d1 += h7 * (5 * r4);
	    d1 += h8 * (5 * r3);
	    d1 += h9 * (5 * r2);
	    c += (d1 >>> 13); d1 &= 0x1fff;
	
	    d2 = c;
	    d2 += h0 * r2;
	    d2 += h1 * r1;
	    d2 += h2 * r0;
	    d2 += h3 * (5 * r9);
	    d2 += h4 * (5 * r8);
	    c = (d2 >>> 13); d2 &= 0x1fff;
	    d2 += h5 * (5 * r7);
	    d2 += h6 * (5 * r6);
	    d2 += h7 * (5 * r5);
	    d2 += h8 * (5 * r4);
	    d2 += h9 * (5 * r3);
	    c += (d2 >>> 13); d2 &= 0x1fff;
	
	    d3 = c;
	    d3 += h0 * r3;
	    d3 += h1 * r2;
	    d3 += h2 * r1;
	    d3 += h3 * r0;
	    d3 += h4 * (5 * r9);
	    c = (d3 >>> 13); d3 &= 0x1fff;
	    d3 += h5 * (5 * r8);
	    d3 += h6 * (5 * r7);
	    d3 += h7 * (5 * r6);
	    d3 += h8 * (5 * r5);
	    d3 += h9 * (5 * r4);
	    c += (d3 >>> 13); d3 &= 0x1fff;
	
	    d4 = c;
	    d4 += h0 * r4;
	    d4 += h1 * r3;
	    d4 += h2 * r2;
	    d4 += h3 * r1;
	    d4 += h4 * r0;
	    c = (d4 >>> 13); d4 &= 0x1fff;
	    d4 += h5 * (5 * r9);
	    d4 += h6 * (5 * r8);
	    d4 += h7 * (5 * r7);
	    d4 += h8 * (5 * r6);
	    d4 += h9 * (5 * r5);
	    c += (d4 >>> 13); d4 &= 0x1fff;
	
	    d5 = c;
	    d5 += h0 * r5;
	    d5 += h1 * r4;
	    d5 += h2 * r3;
	    d5 += h3 * r2;
	    d5 += h4 * r1;
	    c = (d5 >>> 13); d5 &= 0x1fff;
	    d5 += h5 * r0;
	    d5 += h6 * (5 * r9);
	    d5 += h7 * (5 * r8);
	    d5 += h8 * (5 * r7);
	    d5 += h9 * (5 * r6);
	    c += (d5 >>> 13); d5 &= 0x1fff;
	
	    d6 = c;
	    d6 += h0 * r6;
	    d6 += h1 * r5;
	    d6 += h2 * r4;
	    d6 += h3 * r3;
	    d6 += h4 * r2;
	    c = (d6 >>> 13); d6 &= 0x1fff;
	    d6 += h5 * r1;
	    d6 += h6 * r0;
	    d6 += h7 * (5 * r9);
	    d6 += h8 * (5 * r8);
	    d6 += h9 * (5 * r7);
	    c += (d6 >>> 13); d6 &= 0x1fff;
	
	    d7 = c;
	    d7 += h0 * r7;
	    d7 += h1 * r6;
	    d7 += h2 * r5;
	    d7 += h3 * r4;
	    d7 += h4 * r3;
	    c = (d7 >>> 13); d7 &= 0x1fff;
	    d7 += h5 * r2;
	    d7 += h6 * r1;
	    d7 += h7 * r0;
	    d7 += h8 * (5 * r9);
	    d7 += h9 * (5 * r8);
	    c += (d7 >>> 13); d7 &= 0x1fff;
	
	    d8 = c;
	    d8 += h0 * r8;
	    d8 += h1 * r7;
	    d8 += h2 * r6;
	    d8 += h3 * r5;
	    d8 += h4 * r4;
	    c = (d8 >>> 13); d8 &= 0x1fff;
	    d8 += h5 * r3;
	    d8 += h6 * r2;
	    d8 += h7 * r1;
	    d8 += h8 * r0;
	    d8 += h9 * (5 * r9);
	    c += (d8 >>> 13); d8 &= 0x1fff;
	
	    d9 = c;
	    d9 += h0 * r9;
	    d9 += h1 * r8;
	    d9 += h2 * r7;
	    d9 += h3 * r6;
	    d9 += h4 * r5;
	    c = (d9 >>> 13); d9 &= 0x1fff;
	    d9 += h5 * r4;
	    d9 += h6 * r3;
	    d9 += h7 * r2;
	    d9 += h8 * r1;
	    d9 += h9 * r0;
	    c += (d9 >>> 13); d9 &= 0x1fff;
	
	    c = (((c << 2) + c)) | 0;
	    c = (c + d0) | 0;
	    d0 = c & 0x1fff;
	    c = (c >>> 13);
	    d1 += c;
	
	    h0 = d0;
	    h1 = d1;
	    h2 = d2;
	    h3 = d3;
	    h4 = d4;
	    h5 = d5;
	    h6 = d6;
	    h7 = d7;
	    h8 = d8;
	    h9 = d9;
	
	    mpos += 16;
	    bytes -= 16;
	  }
	  this.h[0] = h0;
	  this.h[1] = h1;
	  this.h[2] = h2;
	  this.h[3] = h3;
	  this.h[4] = h4;
	  this.h[5] = h5;
	  this.h[6] = h6;
	  this.h[7] = h7;
	  this.h[8] = h8;
	  this.h[9] = h9;
	};
	
	poly1305.prototype.finish = function(mac, macpos) {
	  var g = new Uint16Array(10);
	  var c, mask, f, i;
	
	  if (this.leftover) {
	    i = this.leftover;
	    this.buffer[i++] = 1;
	    for (; i < 16; i++) this.buffer[i] = 0;
	    this.fin = 1;
	    this.blocks(this.buffer, 0, 16);
	  }
	
	  c = this.h[1] >>> 13;
	  this.h[1] &= 0x1fff;
	  for (i = 2; i < 10; i++) {
	    this.h[i] += c;
	    c = this.h[i] >>> 13;
	    this.h[i] &= 0x1fff;
	  }
	  this.h[0] += (c * 5);
	  c = this.h[0] >>> 13;
	  this.h[0] &= 0x1fff;
	  this.h[1] += c;
	  c = this.h[1] >>> 13;
	  this.h[1] &= 0x1fff;
	  this.h[2] += c;
	
	  g[0] = this.h[0] + 5;
	  c = g[0] >>> 13;
	  g[0] &= 0x1fff;
	  for (i = 1; i < 10; i++) {
	    g[i] = this.h[i] + c;
	    c = g[i] >>> 13;
	    g[i] &= 0x1fff;
	  }
	  g[9] -= (1 << 13);
	
	  mask = (g[9] >>> ((2 * 8) - 1)) - 1;
	  for (i = 0; i < 10; i++) g[i] &= mask;
	  mask = ~mask;
	  for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];
	
	  this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;
	  this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;
	  this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;
	  this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;
	  this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;
	  this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;
	  this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;
	  this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;
	
	  f = this.h[0] + this.pad[0];
	  this.h[0] = f & 0xffff;
	  for (i = 1; i < 8; i++) {
	    f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;
	    this.h[i] = f & 0xffff;
	  }
	
	  mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;
	  mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;
	  mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;
	  mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;
	  mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;
	  mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;
	  mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;
	  mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;
	  mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;
	  mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;
	  mac[macpos+10] = (this.h[5] >>> 0) & 0xff;
	  mac[macpos+11] = (this.h[5] >>> 8) & 0xff;
	  mac[macpos+12] = (this.h[6] >>> 0) & 0xff;
	  mac[macpos+13] = (this.h[6] >>> 8) & 0xff;
	  mac[macpos+14] = (this.h[7] >>> 0) & 0xff;
	  mac[macpos+15] = (this.h[7] >>> 8) & 0xff;
	};
	
	poly1305.prototype.update = function(m, mpos, bytes) {
	  var i, want;
	
	  if (this.leftover) {
	    want = (16 - this.leftover);
	    if (want > bytes)
	      want = bytes;
	    for (i = 0; i < want; i++)
	      this.buffer[this.leftover + i] = m[mpos+i];
	    bytes -= want;
	    mpos += want;
	    this.leftover += want;
	    if (this.leftover < 16)
	      return;
	    this.blocks(this.buffer, 0, 16);
	    this.leftover = 0;
	  }
	
	  if (bytes >= 16) {
	    want = bytes - (bytes % 16);
	    this.blocks(m, mpos, want);
	    mpos += want;
	    bytes -= want;
	  }
	
	  if (bytes) {
	    for (i = 0; i < bytes; i++)
	      this.buffer[this.leftover + i] = m[mpos+i];
	    this.leftover += bytes;
	  }
	};
	
	function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
	  var s = new poly1305(k);
	  s.update(m, mpos, n);
	  s.finish(out, outpos);
	  return 0;
	}
	
	function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
	  var x = new Uint8Array(16);
	  crypto_onetimeauth(x,0,m,mpos,n,k);
	  return crypto_verify_16(h,hpos,x,0);
	}
	
	function crypto_secretbox(c,m,d,n,k) {
	  var i;
	  if (d < 32) return -1;
	  crypto_stream_xor(c,0,m,0,d,n,k);
	  crypto_onetimeauth(c, 16, c, 32, d - 32, c);
	  for (i = 0; i < 16; i++) c[i] = 0;
	  return 0;
	}
	
	function crypto_secretbox_open(m,c,d,n,k) {
	  var i;
	  var x = new Uint8Array(32);
	  if (d < 32) return -1;
	  crypto_stream(x,0,32,n,k);
	  if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;
	  crypto_stream_xor(m,0,c,0,d,n,k);
	  for (i = 0; i < 32; i++) m[i] = 0;
	  return 0;
	}
	
	function set25519(r, a) {
	  var i;
	  for (i = 0; i < 16; i++) r[i] = a[i]|0;
	}
	
	function car25519(o) {
	  var i, v, c = 1;
	  for (i = 0; i < 16; i++) {
	    v = o[i] + c + 65535;
	    c = Math.floor(v / 65536);
	    o[i] = v - c * 65536;
	  }
	  o[0] += c-1 + 37 * (c-1);
	}
	
	function sel25519(p, q, b) {
	  var t, c = ~(b-1);
	  for (var i = 0; i < 16; i++) {
	    t = c & (p[i] ^ q[i]);
	    p[i] ^= t;
	    q[i] ^= t;
	  }
	}
	
	function pack25519(o, n) {
	  var i, j, b;
	  var m = gf(), t = gf();
	  for (i = 0; i < 16; i++) t[i] = n[i];
	  car25519(t);
	  car25519(t);
	  car25519(t);
	  for (j = 0; j < 2; j++) {
	    m[0] = t[0] - 0xffed;
	    for (i = 1; i < 15; i++) {
	      m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);
	      m[i-1] &= 0xffff;
	    }
	    m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);
	    b = (m[15]>>16) & 1;
	    m[14] &= 0xffff;
	    sel25519(t, m, 1-b);
	  }
	  for (i = 0; i < 16; i++) {
	    o[2*i] = t[i] & 0xff;
	    o[2*i+1] = t[i]>>8;
	  }
	}
	
	function neq25519(a, b) {
	  var c = new Uint8Array(32), d = new Uint8Array(32);
	  pack25519(c, a);
	  pack25519(d, b);
	  return crypto_verify_32(c, 0, d, 0);
	}
	
	function par25519(a) {
	  var d = new Uint8Array(32);
	  pack25519(d, a);
	  return d[0] & 1;
	}
	
	function unpack25519(o, n) {
	  var i;
	  for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);
	  o[15] &= 0x7fff;
	}
	
	function A(o, a, b) {
	  for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
	}
	
	function Z(o, a, b) {
	  for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
	}
	
	function M(o, a, b) {
	  var v, c,
	     t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,
	     t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,
	    t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,
	    t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,
	    b0 = b[0],
	    b1 = b[1],
	    b2 = b[2],
	    b3 = b[3],
	    b4 = b[4],
	    b5 = b[5],
	    b6 = b[6],
	    b7 = b[7],
	    b8 = b[8],
	    b9 = b[9],
	    b10 = b[10],
	    b11 = b[11],
	    b12 = b[12],
	    b13 = b[13],
	    b14 = b[14],
	    b15 = b[15];
	
	  v = a[0];
	  t0 += v * b0;
	  t1 += v * b1;
	  t2 += v * b2;
	  t3 += v * b3;
	  t4 += v * b4;
	  t5 += v * b5;
	  t6 += v * b6;
	  t7 += v * b7;
	  t8 += v * b8;
	  t9 += v * b9;
	  t10 += v * b10;
	  t11 += v * b11;
	  t12 += v * b12;
	  t13 += v * b13;
	  t14 += v * b14;
	  t15 += v * b15;
	  v = a[1];
	  t1 += v * b0;
	  t2 += v * b1;
	  t3 += v * b2;
	  t4 += v * b3;
	  t5 += v * b4;
	  t6 += v * b5;
	  t7 += v * b6;
	  t8 += v * b7;
	  t9 += v * b8;
	  t10 += v * b9;
	  t11 += v * b10;
	  t12 += v * b11;
	  t13 += v * b12;
	  t14 += v * b13;
	  t15 += v * b14;
	  t16 += v * b15;
	  v = a[2];
	  t2 += v * b0;
	  t3 += v * b1;
	  t4 += v * b2;
	  t5 += v * b3;
	  t6 += v * b4;
	  t7 += v * b5;
	  t8 += v * b6;
	  t9 += v * b7;
	  t10 += v * b8;
	  t11 += v * b9;
	  t12 += v * b10;
	  t13 += v * b11;
	  t14 += v * b12;
	  t15 += v * b13;
	  t16 += v * b14;
	  t17 += v * b15;
	  v = a[3];
	  t3 += v * b0;
	  t4 += v * b1;
	  t5 += v * b2;
	  t6 += v * b3;
	  t7 += v * b4;
	  t8 += v * b5;
	  t9 += v * b6;
	  t10 += v * b7;
	  t11 += v * b8;
	  t12 += v * b9;
	  t13 += v * b10;
	  t14 += v * b11;
	  t15 += v * b12;
	  t16 += v * b13;
	  t17 += v * b14;
	  t18 += v * b15;
	  v = a[4];
	  t4 += v * b0;
	  t5 += v * b1;
	  t6 += v * b2;
	  t7 += v * b3;
	  t8 += v * b4;
	  t9 += v * b5;
	  t10 += v * b6;
	  t11 += v * b7;
	  t12 += v * b8;
	  t13 += v * b9;
	  t14 += v * b10;
	  t15 += v * b11;
	  t16 += v * b12;
	  t17 += v * b13;
	  t18 += v * b14;
	  t19 += v * b15;
	  v = a[5];
	  t5 += v * b0;
	  t6 += v * b1;
	  t7 += v * b2;
	  t8 += v * b3;
	  t9 += v * b4;
	  t10 += v * b5;
	  t11 += v * b6;
	  t12 += v * b7;
	  t13 += v * b8;
	  t14 += v * b9;
	  t15 += v * b10;
	  t16 += v * b11;
	  t17 += v * b12;
	  t18 += v * b13;
	  t19 += v * b14;
	  t20 += v * b15;
	  v = a[6];
	  t6 += v * b0;
	  t7 += v * b1;
	  t8 += v * b2;
	  t9 += v * b3;
	  t10 += v * b4;
	  t11 += v * b5;
	  t12 += v * b6;
	  t13 += v * b7;
	  t14 += v * b8;
	  t15 += v * b9;
	  t16 += v * b10;
	  t17 += v * b11;
	  t18 += v * b12;
	  t19 += v * b13;
	  t20 += v * b14;
	  t21 += v * b15;
	  v = a[7];
	  t7 += v * b0;
	  t8 += v * b1;
	  t9 += v * b2;
	  t10 += v * b3;
	  t11 += v * b4;
	  t12 += v * b5;
	  t13 += v * b6;
	  t14 += v * b7;
	  t15 += v * b8;
	  t16 += v * b9;
	  t17 += v * b10;
	  t18 += v * b11;
	  t19 += v * b12;
	  t20 += v * b13;
	  t21 += v * b14;
	  t22 += v * b15;
	  v = a[8];
	  t8 += v * b0;
	  t9 += v * b1;
	  t10 += v * b2;
	  t11 += v * b3;
	  t12 += v * b4;
	  t13 += v * b5;
	  t14 += v * b6;
	  t15 += v * b7;
	  t16 += v * b8;
	  t17 += v * b9;
	  t18 += v * b10;
	  t19 += v * b11;
	  t20 += v * b12;
	  t21 += v * b13;
	  t22 += v * b14;
	  t23 += v * b15;
	  v = a[9];
	  t9 += v * b0;
	  t10 += v * b1;
	  t11 += v * b2;
	  t12 += v * b3;
	  t13 += v * b4;
	  t14 += v * b5;
	  t15 += v * b6;
	  t16 += v * b7;
	  t17 += v * b8;
	  t18 += v * b9;
	  t19 += v * b10;
	  t20 += v * b11;
	  t21 += v * b12;
	  t22 += v * b13;
	  t23 += v * b14;
	  t24 += v * b15;
	  v = a[10];
	  t10 += v * b0;
	  t11 += v * b1;
	  t12 += v * b2;
	  t13 += v * b3;
	  t14 += v * b4;
	  t15 += v * b5;
	  t16 += v * b6;
	  t17 += v * b7;
	  t18 += v * b8;
	  t19 += v * b9;
	  t20 += v * b10;
	  t21 += v * b11;
	  t22 += v * b12;
	  t23 += v * b13;
	  t24 += v * b14;
	  t25 += v * b15;
	  v = a[11];
	  t11 += v * b0;
	  t12 += v * b1;
	  t13 += v * b2;
	  t14 += v * b3;
	  t15 += v * b4;
	  t16 += v * b5;
	  t17 += v * b6;
	  t18 += v * b7;
	  t19 += v * b8;
	  t20 += v * b9;
	  t21 += v * b10;
	  t22 += v * b11;
	  t23 += v * b12;
	  t24 += v * b13;
	  t25 += v * b14;
	  t26 += v * b15;
	  v = a[12];
	  t12 += v * b0;
	  t13 += v * b1;
	  t14 += v * b2;
	  t15 += v * b3;
	  t16 += v * b4;
	  t17 += v * b5;
	  t18 += v * b6;
	  t19 += v * b7;
	  t20 += v * b8;
	  t21 += v * b9;
	  t22 += v * b10;
	  t23 += v * b11;
	  t24 += v * b12;
	  t25 += v * b13;
	  t26 += v * b14;
	  t27 += v * b15;
	  v = a[13];
	  t13 += v * b0;
	  t14 += v * b1;
	  t15 += v * b2;
	  t16 += v * b3;
	  t17 += v * b4;
	  t18 += v * b5;
	  t19 += v * b6;
	  t20 += v * b7;
	  t21 += v * b8;
	  t22 += v * b9;
	  t23 += v * b10;
	  t24 += v * b11;
	  t25 += v * b12;
	  t26 += v * b13;
	  t27 += v * b14;
	  t28 += v * b15;
	  v = a[14];
	  t14 += v * b0;
	  t15 += v * b1;
	  t16 += v * b2;
	  t17 += v * b3;
	  t18 += v * b4;
	  t19 += v * b5;
	  t20 += v * b6;
	  t21 += v * b7;
	  t22 += v * b8;
	  t23 += v * b9;
	  t24 += v * b10;
	  t25 += v * b11;
	  t26 += v * b12;
	  t27 += v * b13;
	  t28 += v * b14;
	  t29 += v * b15;
	  v = a[15];
	  t15 += v * b0;
	  t16 += v * b1;
	  t17 += v * b2;
	  t18 += v * b3;
	  t19 += v * b4;
	  t20 += v * b5;
	  t21 += v * b6;
	  t22 += v * b7;
	  t23 += v * b8;
	  t24 += v * b9;
	  t25 += v * b10;
	  t26 += v * b11;
	  t27 += v * b12;
	  t28 += v * b13;
	  t29 += v * b14;
	  t30 += v * b15;
	
	  t0  += 38 * t16;
	  t1  += 38 * t17;
	  t2  += 38 * t18;
	  t3  += 38 * t19;
	  t4  += 38 * t20;
	  t5  += 38 * t21;
	  t6  += 38 * t22;
	  t7  += 38 * t23;
	  t8  += 38 * t24;
	  t9  += 38 * t25;
	  t10 += 38 * t26;
	  t11 += 38 * t27;
	  t12 += 38 * t28;
	  t13 += 38 * t29;
	  t14 += 38 * t30;
	  // t15 left as is
	
	  // first car
	  c = 1;
	  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
	  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
	  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
	  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
	  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
	  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
	  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
	  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
	  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
	  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
	  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
	  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
	  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
	  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
	  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
	  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
	  t0 += c-1 + 37 * (c-1);
	
	  // second car
	  c = 1;
	  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
	  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
	  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
	  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
	  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
	  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
	  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
	  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
	  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
	  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
	  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
	  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
	  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
	  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
	  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
	  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
	  t0 += c-1 + 37 * (c-1);
	
	  o[ 0] = t0;
	  o[ 1] = t1;
	  o[ 2] = t2;
	  o[ 3] = t3;
	  o[ 4] = t4;
	  o[ 5] = t5;
	  o[ 6] = t6;
	  o[ 7] = t7;
	  o[ 8] = t8;
	  o[ 9] = t9;
	  o[10] = t10;
	  o[11] = t11;
	  o[12] = t12;
	  o[13] = t13;
	  o[14] = t14;
	  o[15] = t15;
	}
	
	function S(o, a) {
	  M(o, a, a);
	}
	
	function inv25519(o, i) {
	  var c = gf();
	  var a;
	  for (a = 0; a < 16; a++) c[a] = i[a];
	  for (a = 253; a >= 0; a--) {
	    S(c, c);
	    if(a !== 2 && a !== 4) M(c, c, i);
	  }
	  for (a = 0; a < 16; a++) o[a] = c[a];
	}
	
	function pow2523(o, i) {
	  var c = gf();
	  var a;
	  for (a = 0; a < 16; a++) c[a] = i[a];
	  for (a = 250; a >= 0; a--) {
	      S(c, c);
	      if(a !== 1) M(c, c, i);
	  }
	  for (a = 0; a < 16; a++) o[a] = c[a];
	}
	
	function crypto_scalarmult(q, n, p) {
	  var z = new Uint8Array(32);
	  var x = new Float64Array(80), r, i;
	  var a = gf(), b = gf(), c = gf(),
	      d = gf(), e = gf(), f = gf();
	  for (i = 0; i < 31; i++) z[i] = n[i];
	  z[31]=(n[31]&127)|64;
	  z[0]&=248;
	  unpack25519(x,p);
	  for (i = 0; i < 16; i++) {
	    b[i]=x[i];
	    d[i]=a[i]=c[i]=0;
	  }
	  a[0]=d[0]=1;
	  for (i=254; i>=0; --i) {
	    r=(z[i>>>3]>>>(i&7))&1;
	    sel25519(a,b,r);
	    sel25519(c,d,r);
	    A(e,a,c);
	    Z(a,a,c);
	    A(c,b,d);
	    Z(b,b,d);
	    S(d,e);
	    S(f,a);
	    M(a,c,a);
	    M(c,b,e);
	    A(e,a,c);
	    Z(a,a,c);
	    S(b,a);
	    Z(c,d,f);
	    M(a,c,_121665);
	    A(a,a,d);
	    M(c,c,a);
	    M(a,d,f);
	    M(d,b,x);
	    S(b,e);
	    sel25519(a,b,r);
	    sel25519(c,d,r);
	  }
	  for (i = 0; i < 16; i++) {
	    x[i+16]=a[i];
	    x[i+32]=c[i];
	    x[i+48]=b[i];
	    x[i+64]=d[i];
	  }
	  var x32 = x.subarray(32);
	  var x16 = x.subarray(16);
	  inv25519(x32,x32);
	  M(x16,x16,x32);
	  pack25519(q,x16);
	  return 0;
	}
	
	function crypto_scalarmult_base(q, n) {
	  return crypto_scalarmult(q, n, _9);
	}
	
	function crypto_box_keypair(y, x) {
	  randombytes(x, 32);
	  return crypto_scalarmult_base(y, x);
	}
	
	function crypto_box_beforenm(k, y, x) {
	  var s = new Uint8Array(32);
	  crypto_scalarmult(s, x, y);
	  return crypto_core_hsalsa20(k, _0, s, sigma);
	}
	
	var crypto_box_afternm = crypto_secretbox;
	var crypto_box_open_afternm = crypto_secretbox_open;
	
	function crypto_box(c, m, d, n, y, x) {
	  var k = new Uint8Array(32);
	  crypto_box_beforenm(k, y, x);
	  return crypto_box_afternm(c, m, d, n, k);
	}
	
	function crypto_box_open(m, c, d, n, y, x) {
	  var k = new Uint8Array(32);
	  crypto_box_beforenm(k, y, x);
	  return crypto_box_open_afternm(m, c, d, n, k);
	}
	
	var K = [
	  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
	  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
	  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
	  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
	  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
	  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
	  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
	  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
	  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
	  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
	  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
	  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
	  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
	  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
	  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
	  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
	  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
	  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
	  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
	  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
	  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
	  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
	  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
	  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
	  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
	  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
	  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
	  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
	  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
	  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
	  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
	  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
	  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
	  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
	  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
	  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
	  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
	  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
	  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
	  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
	];
	
	function crypto_hashblocks_hl(hh, hl, m, n) {
	  var wh = new Int32Array(16), wl = new Int32Array(16),
	      bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,
	      bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,
	      th, tl, i, j, h, l, a, b, c, d;
	
	  var ah0 = hh[0],
	      ah1 = hh[1],
	      ah2 = hh[2],
	      ah3 = hh[3],
	      ah4 = hh[4],
	      ah5 = hh[5],
	      ah6 = hh[6],
	      ah7 = hh[7],
	
	      al0 = hl[0],
	      al1 = hl[1],
	      al2 = hl[2],
	      al3 = hl[3],
	      al4 = hl[4],
	      al5 = hl[5],
	      al6 = hl[6],
	      al7 = hl[7];
	
	  var pos = 0;
	  while (n >= 128) {
	    for (i = 0; i < 16; i++) {
	      j = 8 * i + pos;
	      wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];
	      wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];
	    }
	    for (i = 0; i < 80; i++) {
	      bh0 = ah0;
	      bh1 = ah1;
	      bh2 = ah2;
	      bh3 = ah3;
	      bh4 = ah4;
	      bh5 = ah5;
	      bh6 = ah6;
	      bh7 = ah7;
	
	      bl0 = al0;
	      bl1 = al1;
	      bl2 = al2;
	      bl3 = al3;
	      bl4 = al4;
	      bl5 = al5;
	      bl6 = al6;
	      bl7 = al7;
	
	      // add
	      h = ah7;
	      l = al7;
	
	      a = l & 0xffff; b = l >>> 16;
	      c = h & 0xffff; d = h >>> 16;
	
	      // Sigma1
	      h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));
	      l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));
	
	      a += l & 0xffff; b += l >>> 16;
	      c += h & 0xffff; d += h >>> 16;
	
	      // Ch
	      h = (ah4 & ah5) ^ (~ah4 & ah6);
	      l = (al4 & al5) ^ (~al4 & al6);
	
	      a += l & 0xffff; b += l >>> 16;
	      c += h & 0xffff; d += h >>> 16;
	
	      // K
	      h = K[i*2];
	      l = K[i*2+1];
	
	      a += l & 0xffff; b += l >>> 16;
	      c += h & 0xffff; d += h >>> 16;
	
	      // w
	      h = wh[i%16];
	      l = wl[i%16];
	
	      a += l & 0xffff; b += l >>> 16;
	      c += h & 0xffff; d += h >>> 16;
	
	      b += a >>> 16;
	      c += b >>> 16;
	      d += c >>> 16;
	
	      th = c & 0xffff | d << 16;
	      tl = a & 0xffff | b << 16;
	
	      // add
	      h = th;
	      l = tl;
	
	      a = l & 0xffff; b = l >>> 16;
	      c = h & 0xffff; d = h >>> 16;
	
	      // Sigma0
	      h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));
	      l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));
	
	      a += l & 0xffff; b += l >>> 16;
	      c += h & 0xffff; d += h >>> 16;
	
	      // Maj
	      h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
	      l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);
	
	      a += l & 0xffff; b += l >>> 16;
	      c += h & 0xffff; d += h >>> 16;
	
	      b += a >>> 16;
	      c += b >>> 16;
	      d += c >>> 16;
	
	      bh7 = (c & 0xffff) | (d << 16);
	      bl7 = (a & 0xffff) | (b << 16);
	
	      // add
	      h = bh3;
	      l = bl3;
	
	      a = l & 0xffff; b = l >>> 16;
	      c = h & 0xffff; d = h >>> 16;
	
	      h = th;
	      l = tl;
	
	      a += l & 0xffff; b += l >>> 16;
	      c += h & 0xffff; d += h >>> 16;
	
	      b += a >>> 16;
	      c += b >>> 16;
	      d += c >>> 16;
	
	      bh3 = (c & 0xffff) | (d << 16);
	      bl3 = (a & 0xffff) | (b << 16);
	
	      ah1 = bh0;
	      ah2 = bh1;
	      ah3 = bh2;
	      ah4 = bh3;
	      ah5 = bh4;
	      ah6 = bh5;
	      ah7 = bh6;
	      ah0 = bh7;
	
	      al1 = bl0;
	      al2 = bl1;
	      al3 = bl2;
	      al4 = bl3;
	      al5 = bl4;
	      al6 = bl5;
	      al7 = bl6;
	      al0 = bl7;
	
	      if (i%16 === 15) {
	        for (j = 0; j < 16; j++) {
	          // add
	          h = wh[j];
	          l = wl[j];
	
	          a = l & 0xffff; b = l >>> 16;
	          c = h & 0xffff; d = h >>> 16;
	
	          h = wh[(j+9)%16];
	          l = wl[(j+9)%16];
	
	          a += l & 0xffff; b += l >>> 16;
	          c += h & 0xffff; d += h >>> 16;
	
	          // sigma0
	          th = wh[(j+1)%16];
	          tl = wl[(j+1)%16];
	          h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);
	          l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));
	
	          a += l & 0xffff; b += l >>> 16;
	          c += h & 0xffff; d += h >>> 16;
	
	          // sigma1
	          th = wh[(j+14)%16];
	          tl = wl[(j+14)%16];
	          h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);
	          l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));
	
	          a += l & 0xffff; b += l >>> 16;
	          c += h & 0xffff; d += h >>> 16;
	
	          b += a >>> 16;
	          c += b >>> 16;
	          d += c >>> 16;
	
	          wh[j] = (c & 0xffff) | (d << 16);
	          wl[j] = (a & 0xffff) | (b << 16);
	        }
	      }
	    }
	
	    // add
	    h = ah0;
	    l = al0;
	
	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;
	
	    h = hh[0];
	    l = hl[0];
	
	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;
	
	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;
	
	    hh[0] = ah0 = (c & 0xffff) | (d << 16);
	    hl[0] = al0 = (a & 0xffff) | (b << 16);
	
	    h = ah1;
	    l = al1;
	
	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;
	
	    h = hh[1];
	    l = hl[1];
	
	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;
	
	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;
	
	    hh[1] = ah1 = (c & 0xffff) | (d << 16);
	    hl[1] = al1 = (a & 0xffff) | (b << 16);
	
	    h = ah2;
	    l = al2;
	
	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;
	
	    h = hh[2];
	    l = hl[2];
	
	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;
	
	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;
	
	    hh[2] = ah2 = (c & 0xffff) | (d << 16);
	    hl[2] = al2 = (a & 0xffff) | (b << 16);
	
	    h = ah3;
	    l = al3;
	
	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;
	
	    h = hh[3];
	    l = hl[3];
	
	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;
	
	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;
	
	    hh[3] = ah3 = (c & 0xffff) | (d << 16);
	    hl[3] = al3 = (a & 0xffff) | (b << 16);
	
	    h = ah4;
	    l = al4;
	
	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;
	
	    h = hh[4];
	    l = hl[4];
	
	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;
	
	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;
	
	    hh[4] = ah4 = (c & 0xffff) | (d << 16);
	    hl[4] = al4 = (a & 0xffff) | (b << 16);
	
	    h = ah5;
	    l = al5;
	
	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;
	
	    h = hh[5];
	    l = hl[5];
	
	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;
	
	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;
	
	    hh[5] = ah5 = (c & 0xffff) | (d << 16);
	    hl[5] = al5 = (a & 0xffff) | (b << 16);
	
	    h = ah6;
	    l = al6;
	
	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;
	
	    h = hh[6];
	    l = hl[6];
	
	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;
	
	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;
	
	    hh[6] = ah6 = (c & 0xffff) | (d << 16);
	    hl[6] = al6 = (a & 0xffff) | (b << 16);
	
	    h = ah7;
	    l = al7;
	
	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;
	
	    h = hh[7];
	    l = hl[7];
	
	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;
	
	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;
	
	    hh[7] = ah7 = (c & 0xffff) | (d << 16);
	    hl[7] = al7 = (a & 0xffff) | (b << 16);
	
	    pos += 128;
	    n -= 128;
	  }
	
	  return n;
	}
	
	function crypto_hash(out, m, n) {
	  var hh = new Int32Array(8),
	      hl = new Int32Array(8),
	      x = new Uint8Array(256),
	      i, b = n;
	
	  hh[0] = 0x6a09e667;
	  hh[1] = 0xbb67ae85;
	  hh[2] = 0x3c6ef372;
	  hh[3] = 0xa54ff53a;
	  hh[4] = 0x510e527f;
	  hh[5] = 0x9b05688c;
	  hh[6] = 0x1f83d9ab;
	  hh[7] = 0x5be0cd19;
	
	  hl[0] = 0xf3bcc908;
	  hl[1] = 0x84caa73b;
	  hl[2] = 0xfe94f82b;
	  hl[3] = 0x5f1d36f1;
	  hl[4] = 0xade682d1;
	  hl[5] = 0x2b3e6c1f;
	  hl[6] = 0xfb41bd6b;
	  hl[7] = 0x137e2179;
	
	  crypto_hashblocks_hl(hh, hl, m, n);
	  n %= 128;
	
	  for (i = 0; i < n; i++) x[i] = m[b-n+i];
	  x[n] = 128;
	
	  n = 256-128*(n<112?1:0);
	  x[n-9] = 0;
	  ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);
	  crypto_hashblocks_hl(hh, hl, x, n);
	
	  for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);
	
	  return 0;
	}
	
	function add(p, q) {
	  var a = gf(), b = gf(), c = gf(),
	      d = gf(), e = gf(), f = gf(),
	      g = gf(), h = gf(), t = gf();
	
	  Z(a, p[1], p[0]);
	  Z(t, q[1], q[0]);
	  M(a, a, t);
	  A(b, p[0], p[1]);
	  A(t, q[0], q[1]);
	  M(b, b, t);
	  M(c, p[3], q[3]);
	  M(c, c, D2);
	  M(d, p[2], q[2]);
	  A(d, d, d);
	  Z(e, b, a);
	  Z(f, d, c);
	  A(g, d, c);
	  A(h, b, a);
	
	  M(p[0], e, f);
	  M(p[1], h, g);
	  M(p[2], g, f);
	  M(p[3], e, h);
	}
	
	function cswap(p, q, b) {
	  var i;
	  for (i = 0; i < 4; i++) {
	    sel25519(p[i], q[i], b);
	  }
	}
	
	function pack(r, p) {
	  var tx = gf(), ty = gf(), zi = gf();
	  inv25519(zi, p[2]);
	  M(tx, p[0], zi);
	  M(ty, p[1], zi);
	  pack25519(r, ty);
	  r[31] ^= par25519(tx) << 7;
	}
	
	function scalarmult(p, q, s) {
	  var b, i;
	  set25519(p[0], gf0);
	  set25519(p[1], gf1);
	  set25519(p[2], gf1);
	  set25519(p[3], gf0);
	  for (i = 255; i >= 0; --i) {
	    b = (s[(i/8)|0] >> (i&7)) & 1;
	    cswap(p, q, b);
	    add(q, p);
	    add(p, p);
	    cswap(p, q, b);
	  }
	}
	
	function scalarbase(p, s) {
	  var q = [gf(), gf(), gf(), gf()];
	  set25519(q[0], X);
	  set25519(q[1], Y);
	  set25519(q[2], gf1);
	  M(q[3], X, Y);
	  scalarmult(p, q, s);
	}
	
	function crypto_sign_keypair(pk, sk, seeded) {
	  var d = new Uint8Array(64);
	  var p = [gf(), gf(), gf(), gf()];
	  var i;
	
	  if (!seeded) randombytes(sk, 32);
	  crypto_hash(d, sk, 32);
	  d[0] &= 248;
	  d[31] &= 127;
	  d[31] |= 64;
	
	  scalarbase(p, d);
	  pack(pk, p);
	
	  for (i = 0; i < 32; i++) sk[i+32] = pk[i];
	  return 0;
	}
	
	var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);
	
	function modL(r, x) {
	  var carry, i, j, k;
	  for (i = 63; i >= 32; --i) {
	    carry = 0;
	    for (j = i - 32, k = i - 12; j < k; ++j) {
	      x[j] += carry - 16 * x[i] * L[j - (i - 32)];
	      carry = (x[j] + 128) >> 8;
	      x[j] -= carry * 256;
	    }
	    x[j] += carry;
	    x[i] = 0;
	  }
	  carry = 0;
	  for (j = 0; j < 32; j++) {
	    x[j] += carry - (x[31] >> 4) * L[j];
	    carry = x[j] >> 8;
	    x[j] &= 255;
	  }
	  for (j = 0; j < 32; j++) x[j] -= carry * L[j];
	  for (i = 0; i < 32; i++) {
	    x[i+1] += x[i] >> 8;
	    r[i] = x[i] & 255;
	  }
	}
	
	function reduce(r) {
	  var x = new Float64Array(64), i;
	  for (i = 0; i < 64; i++) x[i] = r[i];
	  for (i = 0; i < 64; i++) r[i] = 0;
	  modL(r, x);
	}
	
	// Note: difference from C - smlen returned, not passed as argument.
	function crypto_sign(sm, m, n, sk) {
	  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
	  var i, j, x = new Float64Array(64);
	  var p = [gf(), gf(), gf(), gf()];
	
	  crypto_hash(d, sk, 32);
	  d[0] &= 248;
	  d[31] &= 127;
	  d[31] |= 64;
	
	  var smlen = n + 64;
	  for (i = 0; i < n; i++) sm[64 + i] = m[i];
	  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];
	
	  crypto_hash(r, sm.subarray(32), n+32);
	  reduce(r);
	  scalarbase(p, r);
	  pack(sm, p);
	
	  for (i = 32; i < 64; i++) sm[i] = sk[i];
	  crypto_hash(h, sm, n + 64);
	  reduce(h);
	
	  for (i = 0; i < 64; i++) x[i] = 0;
	  for (i = 0; i < 32; i++) x[i] = r[i];
	  for (i = 0; i < 32; i++) {
	    for (j = 0; j < 32; j++) {
	      x[i+j] += h[i] * d[j];
	    }
	  }
	
	  modL(sm.subarray(32), x);
	  return smlen;
	}
	
	function unpackneg(r, p) {
	  var t = gf(), chk = gf(), num = gf(),
	      den = gf(), den2 = gf(), den4 = gf(),
	      den6 = gf();
	
	  set25519(r[2], gf1);
	  unpack25519(r[1], p);
	  S(num, r[1]);
	  M(den, num, D);
	  Z(num, num, r[2]);
	  A(den, r[2], den);
	
	  S(den2, den);
	  S(den4, den2);
	  M(den6, den4, den2);
	  M(t, den6, num);
	  M(t, t, den);
	
	  pow2523(t, t);
	  M(t, t, num);
	  M(t, t, den);
	  M(t, t, den);
	  M(r[0], t, den);
	
	  S(chk, r[0]);
	  M(chk, chk, den);
	  if (neq25519(chk, num)) M(r[0], r[0], I);
	
	  S(chk, r[0]);
	  M(chk, chk, den);
	  if (neq25519(chk, num)) return -1;
	
	  if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);
	
	  M(r[3], r[0], r[1]);
	  return 0;
	}
	
	function crypto_sign_open(m, sm, n, pk) {
	  var i, mlen;
	  var t = new Uint8Array(32), h = new Uint8Array(64);
	  var p = [gf(), gf(), gf(), gf()],
	      q = [gf(), gf(), gf(), gf()];
	
	  mlen = -1;
	  if (n < 64) return -1;
	
	  if (unpackneg(q, pk)) return -1;
	
	  for (i = 0; i < n; i++) m[i] = sm[i];
	  for (i = 0; i < 32; i++) m[i+32] = pk[i];
	  crypto_hash(h, m, n);
	  reduce(h);
	  scalarmult(p, q, h);
	
	  scalarbase(q, sm.subarray(32));
	  add(p, q);
	  pack(t, p);
	
	  n -= 64;
	  if (crypto_verify_32(sm, 0, t, 0)) {
	    for (i = 0; i < n; i++) m[i] = 0;
	    return -1;
	  }
	
	  for (i = 0; i < n; i++) m[i] = sm[i + 64];
	  mlen = n;
	  return mlen;
	}
	
	var crypto_secretbox_KEYBYTES = 32,
	    crypto_secretbox_NONCEBYTES = 24,
	    crypto_secretbox_ZEROBYTES = 32,
	    crypto_secretbox_BOXZEROBYTES = 16,
	    crypto_scalarmult_BYTES = 32,
	    crypto_scalarmult_SCALARBYTES = 32,
	    crypto_box_PUBLICKEYBYTES = 32,
	    crypto_box_SECRETKEYBYTES = 32,
	    crypto_box_BEFORENMBYTES = 32,
	    crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
	    crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
	    crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
	    crypto_sign_BYTES = 64,
	    crypto_sign_PUBLICKEYBYTES = 32,
	    crypto_sign_SECRETKEYBYTES = 64,
	    crypto_sign_SEEDBYTES = 32,
	    crypto_hash_BYTES = 64;
	
	nacl.lowlevel = {
	  crypto_core_hsalsa20: crypto_core_hsalsa20,
	  crypto_stream_xor: crypto_stream_xor,
	  crypto_stream: crypto_stream,
	  crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
	  crypto_stream_salsa20: crypto_stream_salsa20,
	  crypto_onetimeauth: crypto_onetimeauth,
	  crypto_onetimeauth_verify: crypto_onetimeauth_verify,
	  crypto_verify_16: crypto_verify_16,
	  crypto_verify_32: crypto_verify_32,
	  crypto_secretbox: crypto_secretbox,
	  crypto_secretbox_open: crypto_secretbox_open,
	  crypto_scalarmult: crypto_scalarmult,
	  crypto_scalarmult_base: crypto_scalarmult_base,
	  crypto_box_beforenm: crypto_box_beforenm,
	  crypto_box_afternm: crypto_box_afternm,
	  crypto_box: crypto_box,
	  crypto_box_open: crypto_box_open,
	  crypto_box_keypair: crypto_box_keypair,
	  crypto_hash: crypto_hash,
	  crypto_sign: crypto_sign,
	  crypto_sign_keypair: crypto_sign_keypair,
	  crypto_sign_open: crypto_sign_open,
	
	  crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
	  crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
	  crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
	  crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
	  crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
	  crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
	  crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
	  crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
	  crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
	  crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
	  crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
	  crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
	  crypto_sign_BYTES: crypto_sign_BYTES,
	  crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
	  crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
	  crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
	  crypto_hash_BYTES: crypto_hash_BYTES
	};
	
	/* High-level API */
	
	function checkLengths(k, n) {
	  if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');
	  if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');
	}
	
	function checkBoxLengths(pk, sk) {
	  if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');
	  if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
	}
	
	function checkArrayTypes() {
	  var t, i;
	  for (i = 0; i < arguments.length; i++) {
	     if ((t = Object.prototype.toString.call(arguments[i])) !== '[object Uint8Array]')
	       throw new TypeError('unexpected type ' + t + ', use Uint8Array');
	  }
	}
	
	function cleanup(arr) {
	  for (var i = 0; i < arr.length; i++) arr[i] = 0;
	}
	
	nacl.util = {};
	
	nacl.util.decodeUTF8 = function(s) {
	  var i, d = unescape(encodeURIComponent(s)), b = new Uint8Array(d.length);
	  for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);
	  return b;
	};
	
	nacl.util.encodeUTF8 = function(arr) {
	  var i, s = [];
	  for (i = 0; i < arr.length; i++) s.push(String.fromCharCode(arr[i]));
	  return decodeURIComponent(escape(s.join('')));
	};
	
	nacl.util.encodeBase64 = function(arr) {
	  if (typeof btoa === 'undefined') {
	    return (new Buffer(arr)).toString('base64');
	  } else {
	    var i, s = [], len = arr.length;
	    for (i = 0; i < len; i++) s.push(String.fromCharCode(arr[i]));
	    return btoa(s.join(''));
	  }
	};
	
	nacl.util.decodeBase64 = function(s) {
	  if (typeof atob === 'undefined') {
	    return new Uint8Array(Array.prototype.slice.call(new Buffer(s, 'base64'), 0));
	  } else {
	    var i, d = atob(s), b = new Uint8Array(d.length);
	    for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);
	    return b;
	  }
	};
	
	nacl.randomBytes = function(n) {
	  var b = new Uint8Array(n);
	  randombytes(b, n);
	  return b;
	};
	
	nacl.secretbox = function(msg, nonce, key) {
	  checkArrayTypes(msg, nonce, key);
	  checkLengths(key, nonce);
	  var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
	  var c = new Uint8Array(m.length);
	  for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];
	  crypto_secretbox(c, m, m.length, nonce, key);
	  return c.subarray(crypto_secretbox_BOXZEROBYTES);
	};
	
	nacl.secretbox.open = function(box, nonce, key) {
	  checkArrayTypes(box, nonce, key);
	  checkLengths(key, nonce);
	  var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
	  var m = new Uint8Array(c.length);
	  for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];
	  if (c.length < 32) return false;
	  if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return false;
	  return m.subarray(crypto_secretbox_ZEROBYTES);
	};
	
	nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
	nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
	nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
	
	nacl.scalarMult = function(n, p) {
	  checkArrayTypes(n, p);
	  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
	  if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
	  var q = new Uint8Array(crypto_scalarmult_BYTES);
	  crypto_scalarmult(q, n, p);
	  return q;
	};
	
	nacl.scalarMult.base = function(n) {
	  checkArrayTypes(n);
	  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
	  var q = new Uint8Array(crypto_scalarmult_BYTES);
	  crypto_scalarmult_base(q, n);
	  return q;
	};
	
	nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
	nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
	
	nacl.box = function(msg, nonce, publicKey, secretKey) {
	  var k = nacl.box.before(publicKey, secretKey);
	  return nacl.secretbox(msg, nonce, k);
	};
	
	nacl.box.before = function(publicKey, secretKey) {
	  checkArrayTypes(publicKey, secretKey);
	  checkBoxLengths(publicKey, secretKey);
	  var k = new Uint8Array(crypto_box_BEFORENMBYTES);
	  crypto_box_beforenm(k, publicKey, secretKey);
	  return k;
	};
	
	nacl.box.after = nacl.secretbox;
	
	nacl.box.open = function(msg, nonce, publicKey, secretKey) {
	  var k = nacl.box.before(publicKey, secretKey);
	  return nacl.secretbox.open(msg, nonce, k);
	};
	
	nacl.box.open.after = nacl.secretbox.open;
	
	nacl.box.keyPair = function() {
	  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
	  var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
	  crypto_box_keypair(pk, sk);
	  return {publicKey: pk, secretKey: sk};
	};
	
	nacl.box.keyPair.fromSecretKey = function(secretKey) {
	  checkArrayTypes(secretKey);
	  if (secretKey.length !== crypto_box_SECRETKEYBYTES)
	    throw new Error('bad secret key size');
	  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
	  crypto_scalarmult_base(pk, secretKey);
	  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
	};
	
	nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
	nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
	nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
	nacl.box.nonceLength = crypto_box_NONCEBYTES;
	nacl.box.overheadLength = nacl.secretbox.overheadLength;
	
	nacl.sign = function(msg, secretKey) {
	  checkArrayTypes(msg, secretKey);
	  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
	    throw new Error('bad secret key size');
	  var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);
	  crypto_sign(signedMsg, msg, msg.length, secretKey);
	  return signedMsg;
	};
	
	nacl.sign.open = function(signedMsg, publicKey) {
	  if (arguments.length !== 2)
	    throw new Error('nacl.sign.open accepts 2 arguments; did you mean to use nacl.sign.detached.verify?');
	  checkArrayTypes(signedMsg, publicKey);
	  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
	    throw new Error('bad public key size');
	  var tmp = new Uint8Array(signedMsg.length);
	  var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
	  if (mlen < 0) return null;
	  var m = new Uint8Array(mlen);
	  for (var i = 0; i < m.length; i++) m[i] = tmp[i];
	  return m;
	};
	
	nacl.sign.detached = function(msg, secretKey) {
	  var signedMsg = nacl.sign(msg, secretKey);
	  var sig = new Uint8Array(crypto_sign_BYTES);
	  for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
	  return sig;
	};
	
	nacl.sign.detached.verify = function(msg, sig, publicKey) {
	  checkArrayTypes(msg, sig, publicKey);
	  if (sig.length !== crypto_sign_BYTES)
	    throw new Error('bad signature size');
	  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
	    throw new Error('bad public key size');
	  var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
	  var m = new Uint8Array(crypto_sign_BYTES + msg.length);
	  var i;
	  for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
	  for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];
	  return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);
	};
	
	nacl.sign.keyPair = function() {
	  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
	  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
	  crypto_sign_keypair(pk, sk);
	  return {publicKey: pk, secretKey: sk};
	};
	
	nacl.sign.keyPair.fromSecretKey = function(secretKey) {
	  checkArrayTypes(secretKey);
	  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
	    throw new Error('bad secret key size');
	  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
	  for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];
	  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
	};
	
	nacl.sign.keyPair.fromSeed = function(seed) {
	  checkArrayTypes(seed);
	  if (seed.length !== crypto_sign_SEEDBYTES)
	    throw new Error('bad seed size');
	  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
	  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
	  for (var i = 0; i < 32; i++) sk[i] = seed[i];
	  crypto_sign_keypair(pk, sk, true);
	  return {publicKey: pk, secretKey: sk};
	};
	
	nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
	nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
	nacl.sign.seedLength = crypto_sign_SEEDBYTES;
	nacl.sign.signatureLength = crypto_sign_BYTES;
	
	nacl.hash = function(msg) {
	  checkArrayTypes(msg);
	  var h = new Uint8Array(crypto_hash_BYTES);
	  crypto_hash(h, msg, msg.length);
	  return h;
	};
	
	nacl.hash.hashLength = crypto_hash_BYTES;
	
	nacl.verify = function(x, y) {
	  checkArrayTypes(x, y);
	  // Zero length arguments are considered not equal.
	  if (x.length === 0 || y.length === 0) return false;
	  if (x.length !== y.length) return false;
	  return (vn(x, 0, y, 0, x.length) === 0) ? true : false;
	};
	
	nacl.setPRNG = function(fn) {
	  randombytes = fn;
	};
	
	(function() {
	  // Initialize PRNG if environment provides CSPRNG.
	  // If not, methods calling randombytes will throw.
	  var crypto;
	  if (typeof window !== 'undefined') {
	    // Browser.
	    if (window.crypto && window.crypto.getRandomValues) {
	      crypto = window.crypto; // Standard
	    } else if (window.msCrypto && window.msCrypto.getRandomValues) {
	      crypto = window.msCrypto; // Internet Explorer 11+
	    }
	    if (crypto) {
	      nacl.setPRNG(function(x, n) {
	        var i, v = new Uint8Array(n);
	        crypto.getRandomValues(v);
	        for (i = 0; i < n; i++) x[i] = v[i];
	        cleanup(v);
	      });
	    }
	  } else if (true) {
	    // Node.js.
	    crypto = __webpack_require__(2022);
	    if (crypto) {
	      nacl.setPRNG(function(x, n) {
	        var i, v = crypto.randomBytes(n);
	        for (i = 0; i < n; i++) x[i] = v[i];
	        cleanup(v);
	      });
	    }
	  }
	})();
	
	})(typeof module !== 'undefined' && module.exports ? module.exports : (window.nacl = window.nacl || {}));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(820).Buffer))

/***/ },

/***/ 2023:
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _crypto = __webpack_require__(2024);
	
	var _crypto2 = _interopRequireDefault(_crypto);
	
	var _buffer = __webpack_require__(2026);
	
	var _buffer2 = _interopRequireDefault(_buffer);
	
	var _keys = __webpack_require__(2027);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _typedArray = __webpack_require__(2028);
	
	var _typedArray2 = _interopRequireDefault(_typedArray);
	
	exports.crypto = _crypto2['default'];
	exports.buffer = _buffer2['default'];
	exports.keys = _keys2['default'];
	exports.typedArray = _typedArray2['default'];

/***/ },

/***/ 2024:
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	    value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _pbkdf2Sha256 = __webpack_require__(2025);
	
	var _pbkdf2Sha2562 = _interopRequireDefault(_pbkdf2Sha256);
	
	var _crypto = __webpack_require__(904);
	
	var _crypto2 = _interopRequireDefault(_crypto);
	
	var _tweetnacl = __webpack_require__(2021);
	
	var _tweetnacl2 = _interopRequireDefault(_tweetnacl);
	
	exports['default'] = new ((function () {
	    function _class() {
	        _classCallCheck(this, _class);
	    }
	
	    _createClass(_class, [{
	        key: 'hmac',
	
	        /**
	        * Create an SHA256-HMAC from the specified key and data. Note that according
	        * to this (http://stackoverflow.com/a/9591184) we can use buffers as key
	        * material (as well as for data).
	        *
	        * @param {Buffer|String} key
	        * @param {Buffer|String} data
	        * @return {Buffer} digest
	        */
	        value: function hmac(key, data) {
	            return _crypto2['default'].createHmac('sha256', key).update(data).digest();
	        }
	
	        /**
	        * Key-derivation using PBKDF2.
	        *
	        * @param {Buffer|String} key
	        * @param {Buffer|String} salt
	        * @param {Number} iter - Number of iterations.
	        * @param {Number} length - The length of the key material we require.
	        * @return {Buffer}
	        */
	    }, {
	        key: 'kdf',
	        value: function kdf(key, salt, iter, length) {
	            return (0, _pbkdf2Sha2562['default'])(key, salt, iter, length);
	        }
	
	        /**
	        * ECDH using Curve25519 (from NaCl).
	        *
	        * @param {Uint8Array} publicKey
	        * @param {Uint8Array} secretKey
	        * @return {Uint8Array} - The shared key.
	        */
	    }, {
	        key: 'dh',
	        value: function dh(publicKey, secretKey) {
	            return _tweetnacl2['default'].box.before(publicKey, secretKey);
	        }
	    }]);
	
	    return _class;
	})())();
	module.exports = exports['default'];

/***/ },

/***/ 2025:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var assert = __webpack_require__(1296)
	var crypto = __webpack_require__(904)
	
	function pbkdf2(key, salt, iterations, dkLen) {
	  var hLen = 32 //SHA256 Mac length
	  assert(dkLen <= (Math.pow(2, 32) - 1) * hLen, 'requested key length too long')
	  assert(typeof key == 'string' || Buffer.isBuffer(key), 'key must be a string or buffer')
	  assert(typeof salt == 'string' || Buffer.isBuffer(salt), 'key must be a string or buffer')
	
	  if (typeof key == 'string') key = new Buffer(key)
	  if (typeof salt == 'string') salt = new Buffer(salt)
	
	  var DK = new Buffer(dkLen)
	  var T = new Buffer(hLen)
	  var block1 = new Buffer(salt.length + 4)
	
	  var l = Math.ceil(dkLen / hLen)
	  var r = dkLen - (l - 1) * hLen
	
	  salt.copy(block1, 0, 0, salt.length)
	  for (var i = 1; i <= l; i++) {
	    block1.writeUInt32BE(i, salt.length)
	
	    var U = crypto.createHmac('sha256', key).update(block1).digest()
	    U.copy(T, 0, 0, hLen)
	
	    for (var j = 1; j < iterations; j++) {
	      U = crypto.createHmac('sha256', key).update(U).digest()
	
	      for (var k = 0; k < hLen; k++) {
	        T[k] ^= U[k]
	      }
	    }
	
	    var destPos = (i - 1) * hLen
	    var len = (i == l ? r : hLen)
	    T.copy(DK, destPos, 0, len)
	  }
	
	  return DK
	}
	
	module.exports = pbkdf2
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(820).Buffer))

/***/ },

/***/ 2026:
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	exports["default"] = new ((function () {
	    function _class() {
	        _classCallCheck(this, _class);
	    }
	
	    _createClass(_class, [{
	        key: "toTypedArray",
	
	        /**
	        * Take a buffer and convert it to a Uint8Array. Thanks to Martin Thomson:
	        * http://stackoverflow.com/a/12101012
	        *
	        * @param {Buffer} buffer - The buffer to be converted.
	        * @return {Uint8Array} view - The new Uint8Array.
	        */
	        value: function toTypedArray(buffer) {
	            var ab = new ArrayBuffer(buffer.length);
	            var view = new Uint8Array(ab);
	
	            for (var i = 0; i < buffer.length; ++i) {
	                view[i] = buffer[i];
	            }
	
	            return view;
	        }
	    }, {
	        key: "equals",
	        value: function equals(a, b) {
	            if (a.length !== b.length) return false;
	
	            for (var i = 0, l = a.length; i < l; i++) {
	                if (a[i] !== b[i]) return false;
	            }
	
	            return true;
	        }
	    }]);
	
	    return _class;
	})())();
	module.exports = exports["default"];

/***/ },

/***/ 2027:
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	    value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _tweetnacl = __webpack_require__(2021);
	
	var _tweetnacl2 = _interopRequireDefault(_tweetnacl);
	
	exports['default'] = new ((function () {
	    function _class() {
	        _classCallCheck(this, _class);
	    }
	
	    _createClass(_class, [{
	        key: 'newPair',
	
	        /**
	        * Generate a new key pair.
	        *
	        * @return {Object} - New NaCl key pair.
	        */
	        value: function newPair() {
	            return _tweetnacl2['default'].box.keyPair();
	        }
	    }]);
	
	    return _class;
	})())();
	module.exports = exports['default'];

/***/ },

/***/ 2028:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	    value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _tweetnacl = __webpack_require__(2021);
	
	var _tweetnacl2 = _interopRequireDefault(_tweetnacl);
	
	exports['default'] = new ((function () {
	    function _class() {
	        _classCallCheck(this, _class);
	    }
	
	    _createClass(_class, [{
	        key: 'toBuffer',
	
	        /**
	        * Take a Uint8Array and convert it to a buffer. Thanks to Martin Thomson:
	        * http://stackoverflow.com/a/12101012
	        *
	        * @param {Uint8Array} ab - The Uint8Array to be converted.
	        * @return {Buffer} buffer - The new Buffer.
	        */
	        value: function toBuffer(ab) {
	            var buffer = new Buffer(ab.byteLength);
	            var view = new Uint8Array(ab);
	
	            for (var i = 0; i < buffer.length; ++i) {
	                buffer[i] = view[i];
	            }
	
	            return buffer;
	        }
	
	        /**
	        * Take a typed array and convert it to a base 64 representation.
	        *
	        * @param {Uint8Array} ab - The Uint8Array to be converted.
	        * @return {String} - Base64 representation of the array.
	        */
	    }, {
	        key: 'toBase64',
	        value: function toBase64(ab) {
	            return _tweetnacl2['default'].util.encodeBase64(ab);
	        }
	    }]);
	
	    return _class;
	})())();
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(820).Buffer))

/***/ },

/***/ 2029:
/***/ function(module, exports, __webpack_require__) {

	/**
	 * flow:
	 *
	 * A                    B
	 *      --> open
	 *      <-- handshake
	 *      --> handshake
	 *      <--> data/ack
	 */
	module.exports = __webpack_require__(1184)(`
	  // ack = seq of last message received
	
	  message Handshake {
	    required bytes ephemeralKey = 1;
	    required bytes staticKey = 2;
	    // whether the sender has already authenticated
	    // the receiver. If false, the receiver should send its own handshake
	    required bool authenticated = 3;
	  }
	
	  message Encrypted {
	    required bytes ephemeralKey = 1;
	    required uint32 counter = 2;
	    required uint32 previousCounter = 3;
	    required bytes ciphertext = 4;
	    required bytes nonce = 5;
	  }
	
	  // Encrypted messages ciphertext contain one of the following:
	  message Request {
	    required uint32 seq = 1;
	  }
	
	  message Data {
	    required bytes payload = 1;
	    required uint32 ack = 2;
	  }
	
	  message Ack {
	    required uint32 ack = 1;
	  }
	`)


/***/ },

/***/ 2030:
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(1296)
	
	var Addresses = __webpack_require__(2031)
	var Blocks = __webpack_require__(2039)
	var Transactions = __webpack_require__(2040)
	var utils = __webpack_require__(2032)
	
	var NETWORKS = {
	  testnet: "tbtc",
	  bitcoin: "btc",
	  litecoin: "ltc"
	}
	
	function Blockr(network, proxyURL) {
	  network = network || 'bitcoin'
	  assert(network in NETWORKS, 'Unknown network: ' + network)
	  var BASE_URL = this._baseUrl = 'https://' + NETWORKS[network] + '.blockr.io/api/v1/'
	
	  // end points
	  this.transactions = new Transactions(BASE_URL + 'tx/')
	  this.addresses = new Addresses(BASE_URL + 'address/', this.transactions)
	  this.blocks = new Blocks(BASE_URL + 'block/', this.transactions)
	  this._urlForPath = function (path) {
	    return BASE_URL + path
	  }
	
	  this.network = network
	
	  utils.setProxyURL(proxyURL)
	  this.proxyURL = proxyURL
	}
	
	Blockr.Addresses = Addresses
	Blockr.Blocks = Blocks
	Blockr.Transactions = Transactions
	Blockr.prototype.info = function (cb) {
	  utils.makeRequest(this._urlForPath('coin/info'), function (err, data) {
	    if (err) return cb(err)
	
	    var block = data.last_block
	    cb(null, {
	      blockHeight: block.nb,
	      timestamp: new Date(block.time_utc).getTime(),
	      txCount: block.nb_txs
	    })
	  })
	}
	
	Blockr.prototype.getNetwork = function() { return this.network }
	Blockr.prototype.getProxyURL = function() { return this.proxyURL }
	Blockr.throttleGet = utils.throttleGet
	Blockr.throttlePost = utils.throttlePost
	
	module.exports = Blockr


/***/ },

/***/ 2031:
/***/ function(module, exports, __webpack_require__) {

	var async = __webpack_require__(1851)
	var utils = __webpack_require__(2032)
	var bitcoinjs = __webpack_require__(1294)
	
	function Addresses(url, txEndpoint) {
	  this.url = url
	  this.txEndpoint = txEndpoint
	}
	
	Addresses.prototype.summary = function(addresses, callback) {
	  var uri = this.url + "info/"
	
	  validateAddresses(addresses, function(err) {
	    if(err) return callback(err)
	
	    utils.batchRequest(uri, addresses, {params: ["confirmations=0"]}, function(err, data) {
	      if(err) return callback(err);
	
	      var results = data.map(function(address) {
	        return {
	          address: address.address,
	          balance: utils.btcToSatoshi(address.balance),
	          totalReceived: utils.btcToSatoshi(address.totalreceived),
	          txCount: address.nb_txs
	        }
	      })
	
	      callback(null, Array.isArray(addresses) ? results : results[0])
	    })
	  })
	}
	
	Addresses.prototype.transactions = function(addresses, blockHeight, done) {
	  // optional blockHeight
	  if ('function' === typeof blockHeight) {
	    done = blockHeight
	    blockHeight = 0
	  }
	
	  if (blockHeight > 0) {
	    console.warn('Blockr API does not support blockHeight filter for addresses.transactions')
	  }
	
	  var url = this.url
	  var txIds = {}
	
	  var self = this
	  validateAddresses(addresses, function(err) {
	    if(err) return done(err)
	
	    async.parallel([
	      // confirmed transactions
	      function(callback) {
	        utils.batchRequest(url + 'txs/', addresses, {params: ["confirmations=0"]}, function(err, data) {
	          if (err) return callback(err)
	
	          data.forEach(function(address) {
	            address.txs.forEach(function(tx) {
	              txIds[tx.tx] = true
	            })
	          })
	
	          callback()
	        })
	      },
	
	      // unconfirmed (FIXME: remove if they ever fix their API)
	      function(callback) {
	        utils.batchRequest(url + 'unconfirmed/', addresses, {}, function(err, data) {
	          if (err) return callback(err)
	
	          data.forEach(function(address) {
	            address.unconfirmed.forEach(function(tx) {
	              txIds[tx.tx] = true
	            })
	          })
	
	          callback()
	        })
	      }
	    ], function(err) {
	      if (err) return done(err)
	
	      self.txEndpoint.get(Object.keys(txIds), done)
	    })
	  })
	}
	
	Addresses.prototype.unspents = function(addresses, callback) {
	  var uri = this.url + "unspent/"
	
	  validateAddresses(addresses, function(err) {
	    if(err) return callback(err)
	
	    utils.batchRequest(uri, addresses, {params: ["unconfirmed=1"]}, function(err, data) {
	      if (err) return callback(err)
	
	      var unspents = []
	      data.forEach(function(result) {
	        var address = result.address
	
	        result.unspent.forEach(function(unspent) {
	          unspent.address = address
	        })
	
	        unspents = unspents.concat(result.unspent)
	      })
	
	      var results = unspents.map(function(unspent) {
	        return {
	          address: unspent.address,
	          confirmations: unspent.confirmations,
	          vout: unspent.n,
	          txId: unspent.tx,
	          value: utils.btcToSatoshi(unspent.amount)
	        }
	      })
	
	      callback(null, results)
	    })
	  })
	}
	
	function validateAddresses(addresses, callback) {
	  addresses = [].concat(addresses)
	  var invalidAddresses = addresses.filter(function(address) {
	    try {
	      bitcoinjs.Address.fromBase58Check(address)
	    } catch(e) {
	      return true
	    }
	  })
	
	  if(invalidAddresses.length > 0) {
	    return callback(new Error("There are " + invalidAddresses.length + " invalid addresses: " + invalidAddresses.join(', ')))
	  }
	
	  callback(null)
	}
	
	module.exports = Addresses


/***/ },

/***/ 2032:
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(1296)
	var request = __webpack_require__(2033)
	var async = __webpack_require__(1851)
	var throttle = __webpack_require__(2038)
	var proxyURL;
	
	function btcToSatoshi(value) {
	  return Math.round(1e8 * parseFloat(value))
	}
	
	function assertJSend(body) {
	  assert.notEqual(body.status, 'error', body.message || 'Invalid JSend response:' + JSON.stringify(body))
	  assert.notEqual(body.status, 'fail', body.data ? JSON.stringify(body.data) : 'Invalid JSend response: ' + JSON.stringify(body))
	
	  assert.equal(body.status, 'success', 'Unexpected JSend response: ' + body)
	  assert.notEqual(body.data, undefined, 'Unexpected JSend response: ' + body)
	}
	
	function handleJSend(callback) {
	  return function(err, response) {
	    if (err) {
	      return callback(normalizeError(err, response))
	    }
	
	    var body = JSON.parse(response.text)
	    try {
	      assertJSend(body)
	    } catch (exception) {
	      return callback(exception)
	    }
	
	    callback(null, body.data)
	  }
	}
	
	function normalizeError (err, response) {
	  var body = response && response.body
	  if (!body) return err
	
	  err = new Error(body.message || err.message)
	  for (var p in body) {
	    err[p] = body[p]
	  }
	
	  return err
	}
	
	function batchRequest(uri, items, options, callback) {
	  items = [].concat(items)
	
	  if(typeof options === 'function') {
	    callback = options
	    options = {}
	  } else {
	    options = options || {}
	  }
	
	  var itemsPerBatch = options.itemsPerBatch || 20
	  var params = options.params
	
	  var batches = []
	  while(items.length > itemsPerBatch){
	    var batch = items.splice(0, itemsPerBatch)
	    batches.push(batch)
	  }
	
	  if(items.length > 0) batches.push(items)
	
	  var requests = batches.map(function(batch) {
	    return function(cb) {
	      module.exports.makeRequest(uri + batch.join(','), params, cb)
	    }
	  })
	
	  var consolidated = []
	  async.parallel(requests, function(err, results) {
	    if(err) return callback(err)
	
	    results.forEach(function(r) {
	      consolidated = consolidated.concat(r)
	    })
	
	    consolidated = consolidated.filter(function (item) {
	      // filter out nulls
	      return item
	    })
	
	    callback(null, consolidated)
	  })
	}
	
	function makeRequest(uri, params, callback){
	  if(Array.isArray(params)){
	    uri +=  '?' + params.join('&')
	  } else if (params instanceof Function) {
	    callback = params
	  }
	
	  if(proxyURL) {
	    uri = proxyURL + encodeURIComponent(uri)
	  }
	
	  request
	    .get(uri)
	    .timeout(20000)
	    .end(handleJSend(callback))
	}
	
	function makePostRequest(uri, form, callback){
	  if(proxyURL) {
	    uri = proxyURL + encodeURIComponent(uri)
	  }
	
	  request
	    .post(uri)
	    .timeout(20000)
	    .send(form)
	    .end(handleJSend(callback))
	}
	
	function setProxyURL(url) {
	  proxyURL = url
	}
	
	function throttleGet (millis) {
	  module.exports.makeRequest = throttle(makeRequest, millis)
	}
	
	function throttlePost (millis) {
	  module.exports.makePostRequest = throttle(makePostRequest, millis)
	}
	
	module.exports = {
	  handleJSend: handleJSend,
	  btcToSatoshi: btcToSatoshi,
	  batchRequest: batchRequest,
	  makeRequest: makeRequest,
	  makePostRequest: makePostRequest,
	  setProxyURL: setProxyURL,
	  throttleGet: throttleGet,
	  throttlePost: throttlePost
	}


/***/ },

/***/ 2039:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var assert = __webpack_require__(1296)
	var async = __webpack_require__(1851)
	var bitcoinjs = __webpack_require__(1294)
	var utils = __webpack_require__(2032)
	
	function Blocks(url, txEndpoint) {
	  this.url = url
	  this.txEndpoint = txEndpoint
	}
	
	Blocks.prototype.get = function(idsOrHeights, callback) {
	  var uri = this.url + "raw/"
	  var txEndpoint = this.txEndpoint
	
	  utils.batchRequest(uri, idsOrHeights, function(err, data) {
	    if(err) return callback(err)
	
	    function parseBlock(b, cb) {
	      var block = new bitcoinjs.Block()
	      block.version = b.version
	      block.prevHash = bitcoinjs.bufferutils.reverse(new Buffer(b.previousblockhash, 'hex'))
	      block.merkleRoot = bitcoinjs.bufferutils.reverse(new Buffer(b.merkleroot, 'hex'))
	      block.timestamp = b.time
	      block.bits = parseInt(b.bits, 16)
	      block.nonce = b.nonce
	
	      txEndpoint.get(b.tx, function(err, transactions) {
	        if(err) return cb(err)
	
	        block.transactions = transactions.map(function(t) {
	          return bitcoinjs.Transaction.fromHex(t.txHex)
	        })
	
	        cb(null, {
	          blockId: b.hash,
	          blockHex: block.toHex()
	        })
	      })
	    }
	
	    async.map(data, parseBlock, function(err, results) {
	      callback(err, Array.isArray(idsOrHeights) ? results : results[0])
	    })
	  })
	}
	
	Blocks.prototype.latest = function(callback) {
	  var uri = this.url + "raw/last/"
	
	  utils.makeRequest(uri, function(err, data) {
	    if(err) return callback(err)
	
	    callback(null, {
	      blockId: data.hash,
	      prevBlockId: data.previousblockhash,
	      merkleRootHash: data.merkleroot,
	      nonce: data.nonce,
	      version: data.version,
	      blockHeight: data.height,
	      blockSize: parseInt(data.bits, 16),
	      timestamp: data.time,
	      txCount: data.tx.length
	    })
	  })
	}
	
	Blocks.prototype.propagate = function() {
	  assert(false, 'TODO')
	}
	
	Blocks.prototype.summary = function(idsOrHeights, callback) {
	  var uri = this.url + "raw/"
	
	  utils.batchRequest(uri, idsOrHeights, function(err, data) {
	    if(err) return callback(err)
	
	    callback(null, data.map(function(d) {
	      return {
	        blockId: d.hash,
	        prevBlockId: d.previousblockhash,
	        merkleRootHash: d.merkleroot,
	        nonce: d.nonce,
	        version: d.version,
	        blockHeight: d.height,
	        blockSize: parseInt(d.bits, 16),
	        timestamp: d.time
	      }
	    }))
	  })
	}
	
	module.exports = Blocks
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(820).Buffer))

/***/ },

/***/ 2040:
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(1296)
	var async = __webpack_require__(1851)
	var utils = __webpack_require__(2032)
	
	function Transactions(url) {
	  this.url = url
	}
	
	Transactions.prototype.summary = function(txIds, callback) {
	  var uri = this.url + "info/"
	
	  utils.batchRequest(uri, txIds, function(err, data) {
	    if(err) return callback(err)
	
	    var results = data.map(function(d) {
	      return {
	        txId: d.tx,
	        blockId: d.blockhash,
	        blockHeight: d.block,
	        nInputs: d.vins.length,
	        nOutputs: d.vouts.length,
	        totalInputValue: -getTotalValue(d.vins),
	        totalOutputValue: getTotalValue(d.vouts)
	      }
	    })
	
	    callback(null, Array.isArray(txIds) ? results : results[0])
	  })
	
	  function getTotalValue(inputs) {
	    if (!inputs) return 0
	
	    return inputs.reduce(function(memo, input) {
	      return memo + Math.round(input.amount * 1e8)
	    }, 0)
	  }
	}
	
	Transactions.prototype.get = function(txIds, callback) {
	  var uri = this.url + "raw/"
	
	  var queryTxIds = [].concat(txIds)
	  utils.batchRequest(uri, queryTxIds, function(err, data) {
	    if (err) return callback(err)
	
	    var results = data.map(function(d, i) {
	      return {
	        txId: queryTxIds[i],
	        txHex: d.tx.hex,
	        blockId: d.tx.blockhash,
	        blockHeight: d.tx.blockheight,
	
	        // non-standard
	        __blockTimestamp: d.tx.blocktime,
	        __confirmations: d.tx.confirmations || 0
	      }
	    })
	
	    callback(null, Array.isArray(txIds) ? results : results[0])
	  })
	}
	
	Transactions.prototype.latest = function() {
	  assert(false, 'TODO')
	}
	
	Transactions.prototype.propagate = function(transactions, callback) {
	  var that = this
	
	  if(!Array.isArray(transactions)) {
	    transactions = [transactions]
	  }
	
	  var requests = transactions.map(function(txHex) {
	    return function(cb) {
	      utils.makePostRequest(that.url + 'push', { hex: txHex }, cb)
	    }
	  })
	
	  async.parallel(requests, callback)
	}
	
	module.exports = Transactions


/***/ },

/***/ 2041:
/***/ function(module, exports, __webpack_require__) {

	
	const crypto = __webpack_require__(904)
	const levelup = __webpack_require__(2042)
	const encryption = __webpack_require__(2049)
	// const protocol = require('@tradle/protocol')
	const errors = __webpack_require__(2052)
	
	module.exports = function keeper (opts) {
	  // may want to have a safe/dangerous API
	  //   safe: generate key from value on 'put'
	  //   dangerous: accept passed in key on 'put'
	  const encryptionOpts = opts.encryption
	  const rawDB = levelup(opts.path, {
	    db: opts.db,
	    keyEncoding: 'binary',
	    valueEncoding: opts.valueEncoding || 'binary'
	  })
	
	  const db = encryption.toEncrypted(rawDB, encryptionOpts)
	  db.close = function (cb) {
	    rawDB.close(cb)
	  }
	
	  // const multiPut = opts.multiPut
	  // if (multiPut) {
	  //   // on some architectures there is a fast multi-put / multi-get
	  //   // e.g. react-native has AsyncStorage.multiPut / AsyncStorage.multiGet
	  //   const writeBatch = db.batch
	  //   db.batch = function (batch) {
	  //     const fn = batch.every(row => row.type === 'put')
	  //       ? multiPut
	  //       : writeBatch
	
	  //     return fn.apply(db, arguments)
	  //   }
	  // }
	
	  // if (opts.multiGet) {
	  //   db.multiGet = opts.multiGet.bind(db)
	  // }
	
	  return db
	}
	
	// function createDefaultMultiPut (db, batch) {
	//   return function multiPut (batch, cb) {
	//     batch = batch.map(row => extend(row, { type: 'put' }))
	//     db.batch(batch, cb)
	//   }
	// }


/***/ },

/***/ 2042:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/* Copyright (c) 2012-2016 LevelUP contributors
	 * See list at <https://github.com/level/levelup#contributing>
	 * MIT License
	 * <https://github.com/level/levelup/blob/master/LICENSE.md>
	 */
	
	var EventEmitter        = __webpack_require__(786).EventEmitter
	  , inherits            = __webpack_require__(1130).inherits
	  , deprecate           = __webpack_require__(1130).deprecate
	  , extend              = __webpack_require__(859)
	  , prr                 = __webpack_require__(1250)
	  , DeferredLevelDOWN   = __webpack_require__(1251)
	  , IteratorStream      = __webpack_require__(1258)
	
	  , errors              = __webpack_require__(1259)
	  , WriteError          = errors.WriteError
	  , ReadError           = errors.ReadError
	  , NotFoundError       = errors.NotFoundError
	  , OpenError           = errors.OpenError
	  , EncodingError       = errors.EncodingError
	  , InitializationError = errors.InitializationError
	
	  , util                = __webpack_require__(2043)
	  , Batch               = __webpack_require__(2048)
	  , Codec               = __webpack_require__(1266)
	
	  , getOptions          = util.getOptions
	  , defaultOptions      = util.defaultOptions
	  , getLevelDOWN        = util.getLevelDOWN
	  , dispatchError       = util.dispatchError
	  , isDefined           = util.isDefined
	
	function getCallback (options, callback) {
	  return typeof options == 'function' ? options : callback
	}
	
	// Possible LevelUP#_status values:
	//  - 'new'     - newly created, not opened or closed
	//  - 'opening' - waiting for the database to be opened, post open()
	//  - 'open'    - successfully opened the database, available for use
	//  - 'closing' - waiting for the database to be closed, post close()
	//  - 'closed'  - database has been successfully closed, should not be
	//                 used except for another open() operation
	
	function LevelUP (location, options, callback) {
	  if (!(this instanceof LevelUP))
	    return new LevelUP(location, options, callback)
	
	  var error
	
	  EventEmitter.call(this)
	  this.setMaxListeners(Infinity)
	
	  if (typeof location == 'function') {
	    options = typeof options == 'object' ? options : {}
	    options.db = location
	    location = null
	  } else if (typeof location == 'object' && typeof location.db == 'function') {
	    options = location
	    location = null
	  }
	
	
	  if (typeof options == 'function') {
	    callback = options
	    options  = {}
	  }
	
	  if ((!options || typeof options.db != 'function') && typeof location != 'string') {
	    error = new InitializationError(
	        'Must provide a location for the database')
	    if (callback) {
	      return process.nextTick(function () {
	        callback(error)
	      })
	    }
	    throw error
	  }
	
	  options      = getOptions(options)
	  this.options = extend(defaultOptions, options)
	  this._codec = new Codec(this.options)
	  this._status = 'new'
	  // set this.location as enumerable but not configurable or writable
	  prr(this, 'location', location, 'e')
	
	  this.open(callback)
	}
	
	inherits(LevelUP, EventEmitter)
	
	LevelUP.prototype.open = function (callback) {
	  var self = this
	    , dbFactory
	    , db
	
	  if (this.isOpen()) {
	    if (callback)
	      process.nextTick(function () { callback(null, self) })
	    return this
	  }
	
	  if (this._isOpening()) {
	    return callback && this.once(
	        'open'
	      , function () { callback(null, self) }
	    )
	  }
	
	  this.emit('opening')
	
	  this._status = 'opening'
	  this.db      = new DeferredLevelDOWN(this.location)
	  dbFactory    = this.options.db || getLevelDOWN()
	  db           = dbFactory(this.location)
	
	  db.open(this.options, function (err) {
	    if (err) {
	      return dispatchError(self, new OpenError(err), callback)
	    } else {
	      self.db.setDb(db)
	      self.db = db
	      self._status = 'open'
	      if (callback)
	        callback(null, self)
	      self.emit('open')
	      self.emit('ready')
	    }
	  })
	}
	
	LevelUP.prototype.close = function (callback) {
	  var self = this
	
	  if (this.isOpen()) {
	    this._status = 'closing'
	    this.db.close(function () {
	      self._status = 'closed'
	      self.emit('closed')
	      if (callback)
	        callback.apply(null, arguments)
	    })
	    this.emit('closing')
	    this.db = new DeferredLevelDOWN(this.location)
	  } else if (this._status == 'closed' && callback) {
	    return process.nextTick(callback)
	  } else if (this._status == 'closing' && callback) {
	    this.once('closed', callback)
	  } else if (this._isOpening()) {
	    this.once('open', function () {
	      self.close(callback)
	    })
	  }
	}
	
	LevelUP.prototype.isOpen = function () {
	  return this._status == 'open'
	}
	
	LevelUP.prototype._isOpening = function () {
	  return this._status == 'opening'
	}
	
	LevelUP.prototype.isClosed = function () {
	  return (/^clos/).test(this._status)
	}
	
	function maybeError(db, options, callback) {
	  if (!db._isOpening() && !db.isOpen()) {
	    dispatchError(
	        db
	      , new ReadError('Database is not open')
	      , callback
	    )
	    return true
	  }
	}
	
	function writeError (db, message, callback) {
	  dispatchError(
	      db
	     , new WriteError(message)
	     , callback
	  )
	}
	
	function readError (db, message, callback) {
	  dispatchError(
	      db
	     , new ReadError(message)
	     , callback
	  )
	}
	
	
	LevelUP.prototype.get = function (key_, options, callback) {
	  var self = this
	    , key
	
	  callback = getCallback(options, callback)
	
	  if (maybeError(this, options, callback))
	    return
	
	  if (key_ === null || key_ === undefined || 'function' !== typeof callback)
	    return readError(this
	      , 'get() requires key and callback arguments', callback)
	
	  options = util.getOptions(options)
	  key = this._codec.encodeKey(key_, options)
	
	  options.asBuffer = this._codec.valueAsBuffer(options)
	
	  this.db.get(key, options, function (err, value) {
	    if (err) {
	      if ((/notfound/i).test(err) || err.notFound) {
	        err = new NotFoundError(
	            'Key not found in database [' + key_ + ']', err)
	      } else {
	        err = new ReadError(err)
	      }
	      return dispatchError(self, err, callback)
	    }
	    if (callback) {
	      try {
	        value = self._codec.decodeValue(value, options)
	      } catch (e) {
	        return callback(new EncodingError(e))
	      }
	      callback(null, value)
	    }
	  })
	}
	
	LevelUP.prototype.put = function (key_, value_, options, callback) {
	  var self = this
	    , key
	    , value
	
	  callback = getCallback(options, callback)
	
	  if (key_ === null || key_ === undefined)
	    return writeError(this, 'put() requires a key argument', callback)
	
	  if (maybeError(this, options, callback))
	    return
	
	  options = getOptions(options)
	  key     = this._codec.encodeKey(key_, options)
	  value   = this._codec.encodeValue(value_, options)
	
	  this.db.put(key, value, options, function (err) {
	    if (err) {
	      return dispatchError(self, new WriteError(err), callback)
	    } else {
	      self.emit('put', key_, value_)
	      if (callback)
	        callback()
	    }
	  })
	}
	
	LevelUP.prototype.del = function (key_, options, callback) {
	  var self = this
	    , key
	
	  callback = getCallback(options, callback)
	
	  if (key_ === null || key_ === undefined)
	    return writeError(this, 'del() requires a key argument', callback)
	
	  if (maybeError(this, options, callback))
	    return
	
	  options = getOptions(options)
	  key     = this._codec.encodeKey(key_, options)
	
	  this.db.del(key, options, function (err) {
	    if (err) {
	      return dispatchError(self, new WriteError(err), callback)
	    } else {
	      self.emit('del', key_)
	      if (callback)
	        callback()
	    }
	  })
	}
	
	LevelUP.prototype.batch = function (arr_, options, callback) {
	  var self = this
	    , keyEnc
	    , valueEnc
	    , arr
	
	  if (!arguments.length)
	    return new Batch(this, this._codec)
	
	  callback = getCallback(options, callback)
	
	  if (!Array.isArray(arr_))
	    return writeError(this, 'batch() requires an array argument', callback)
	
	  if (maybeError(this, options, callback))
	    return
	
	  options  = getOptions(options)
	  arr      = self._codec.encodeBatch(arr_, options)
	  arr      = arr.map(function (op) {
	    if (!op.type && op.key !== undefined && op.value !== undefined)
	      op.type = 'put'
	    return op
	  })
	
	  this.db.batch(arr, options, function (err) {
	    if (err) {
	      return dispatchError(self, new WriteError(err), callback)
	    } else {
	      self.emit('batch', arr_)
	      if (callback)
	        callback()
	    }
	  })
	}
	
	LevelUP.prototype.approximateSize = deprecate(function (start_, end_, options, callback) {   
	  var self = this    
	    , start    
	    , end    
	   
	  callback = getCallback(options, callback)    
	   
	  options = getOptions(options)    
	   
	  if (start_ === null || start_ === undefined    
	        || end_ === null || end_ === undefined || 'function' !== typeof callback)    
	    return readError(this, 'approximateSize() requires start, end and callback arguments', callback)   
	   
	  start = this._codec.encodeKey(start_, options)   
	  end   = this._codec.encodeKey(end_, options)   
	   
	  this.db.approximateSize(start, end, function (err, size) {   
	    if (err) {   
	      return dispatchError(self, new OpenError(err), callback)   
	    } else if (callback) {   
	      callback(null, size)   
	    }    
	  })   
	}, 'db.approximateSize() is deprecated. Use db.db.approximateSize() instead')
	
	LevelUP.prototype.readStream =
	LevelUP.prototype.createReadStream = function (options) {
	  options = extend( {keys: true, values: true}, this.options, options)
	
	  options.keyEncoding   = options.keyEncoding
	  options.valueEncoding = options.valueEncoding
	
	  options = this._codec.encodeLtgt(options);
	  options.keyAsBuffer   = this._codec.keyAsBuffer(options)
	  options.valueAsBuffer = this._codec.valueAsBuffer(options)
	
	  if ('number' !== typeof options.limit)
	    options.limit = -1
	
	  return new IteratorStream(this.db.iterator(options), extend(options, {
	    decoder: this._codec.createStreamDecoder(options)
	  }))
	}
	
	LevelUP.prototype.keyStream =
	LevelUP.prototype.createKeyStream = function (options) {
	  return this.createReadStream(extend(options, { keys: true, values: false }))
	}
	
	LevelUP.prototype.valueStream =
	LevelUP.prototype.createValueStream = function (options) {
	  return this.createReadStream(extend(options, { keys: false, values: true }))
	}
	
	LevelUP.prototype.toString = function () {
	  return 'LevelUP'
	}
	
	function utilStatic (name) {
	  return function (location, callback) {
	    getLevelDOWN()[name](location, callback || function () {})
	  }
	}
	
	module.exports         = LevelUP
	module.exports.errors  = __webpack_require__(1259)
	module.exports.destroy = deprecate(
	    utilStatic('destroy')
	  , 'levelup.destroy() is deprecated. Use leveldown.destroy() instead'
	)
	module.exports.repair  = deprecate(
	    utilStatic('repair')
	  , 'levelup.repair() is deprecated. Use leveldown.repair() instead'
	)
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(294)))

/***/ },

/***/ 2043:
/***/ function(module, exports, __webpack_require__) {

	/* Copyright (c) 2012-2016 LevelUP contributors
	 * See list at <https://github.com/level/levelup#contributing>
	 * MIT License
	 * <https://github.com/level/levelup/blob/master/LICENSE.md>
	 */
	
	var extend         = __webpack_require__(859)
	  , LevelUPError   = __webpack_require__(1259).LevelUPError
	  , format         = __webpack_require__(1130).format
	  , defaultOptions = {
	        createIfMissing : true
	      , errorIfExists   : false
	      , keyEncoding     : 'utf8'
	      , valueEncoding   : 'utf8'
	      , compression     : true
	    }
	
	  , leveldown
	
	function getOptions (options) {
	  if (typeof options == 'string')
	    options = { valueEncoding: options }
	  if (typeof options != 'object')
	    options = {}
	  return options
	}
	
	function getLevelDOWN () {
	  if (leveldown)
	    return leveldown
	
	  var requiredVersion  = __webpack_require__(2044).devDependencies.leveldown
	    , leveldownVersion
	
	  try {
	    leveldownVersion = __webpack_require__(2045).version
	  } catch (e) {
	    throw requireError(e)
	  }
	
	  if (!__webpack_require__(2046).satisfies(leveldownVersion, requiredVersion)) {
	    throw new LevelUPError(
	        'Installed version of LevelDOWN ('
	      + leveldownVersion
	      + ') does not match required version ('
	      + requiredVersion
	      + ')'
	    )
	  }
	
	  try {
	    return leveldown = __webpack_require__(2047)
	  } catch (e) {
	    throw requireError(e)
	  }
	}
	
	function requireError (e) {
	  var template = 'Failed to require LevelDOWN (%s). Try `npm install leveldown` if it\'s missing'
	  return new LevelUPError(format(template, e.message))
	}
	
	function dispatchError (db, error, callback) {
	  typeof callback == 'function' ? callback(error) : db.emit('error', error)
	}
	
	function isDefined (v) {
	  return typeof v !== 'undefined'
	}
	
	module.exports = {
	    defaultOptions  : defaultOptions
	  , getOptions      : getOptions
	  , getLevelDOWN    : getLevelDOWN
	  , dispatchError   : dispatchError
	  , isDefined       : isDefined
	}


/***/ },

/***/ 2044:
/***/ function(module, exports) {

	module.exports = {
		"_args": [
			[
				{
					"raw": "levelup@https://registry.npmjs.org/levelup/-/levelup-1.3.3.tgz",
					"scope": null,
					"escapedName": "levelup",
					"name": "levelup",
					"rawSpec": "https://registry.npmjs.org/levelup/-/levelup-1.3.3.tgz",
					"spec": "https://registry.npmjs.org/levelup/-/levelup-1.3.3.tgz",
					"type": "remote"
				},
				"/Users/tenaciousmv/Code/tradle-app-web/node_modules/@tradle/keeper"
			]
		],
		"_from": "levelup@>=1.3.2 <2.0.0",
		"_id": "levelup@1.3.3",
		"_inCache": true,
		"_location": "/@tradle/keeper/levelup",
		"_phantomChildren": {},
		"_requested": {
			"raw": "levelup@https://registry.npmjs.org/levelup/-/levelup-1.3.3.tgz",
			"scope": null,
			"escapedName": "levelup",
			"name": "levelup",
			"rawSpec": "https://registry.npmjs.org/levelup/-/levelup-1.3.3.tgz",
			"spec": "https://registry.npmjs.org/levelup/-/levelup-1.3.3.tgz",
			"type": "remote"
		},
		"_requiredBy": [
			"/@tradle/keeper"
		],
		"_resolved": "https://registry.npmjs.org/levelup/-/levelup-1.3.3.tgz",
		"_shasum": "bf9db62bdb6188d08eaaa2efcf6cc311916f41fd",
		"_shrinkwrap": null,
		"_spec": "levelup@https://registry.npmjs.org/levelup/-/levelup-1.3.3.tgz",
		"_where": "/Users/tenaciousmv/Code/tradle-app-web/node_modules/@tradle/keeper",
		"browser": {
			"leveldown": false,
			"leveldown/package": false,
			"semver": false
		},
		"bugs": {
			"url": "https://github.com/level/levelup/issues"
		},
		"contributors": [
			{
				"name": "Rod Vagg",
				"email": "r@va.gg",
				"url": "https://github.com/rvagg"
			},
			{
				"name": "John Chesley",
				"email": "john@chesl.es",
				"url": "https://github.com/chesles/"
			},
			{
				"name": "Jake Verbaten",
				"email": "raynos2@gmail.com",
				"url": "https://github.com/raynos"
			},
			{
				"name": "Dominic Tarr",
				"email": "dominic.tarr@gmail.com",
				"url": "https://github.com/dominictarr"
			},
			{
				"name": "Max Ogden",
				"email": "max@maxogden.com",
				"url": "https://github.com/maxogden"
			},
			{
				"name": "Lars-Magnus Skog",
				"email": "ralphtheninja@riseup.net",
				"url": "https://github.com/ralphtheninja"
			},
			{
				"name": "David Björklund",
				"email": "david.bjorklund@gmail.com",
				"url": "https://github.com/kesla"
			},
			{
				"name": "Julian Gruber",
				"email": "julian@juliangruber.com",
				"url": "https://github.com/juliangruber"
			},
			{
				"name": "Paolo Fragomeni",
				"email": "paolo@async.ly",
				"url": "https://github.com/0x00a"
			},
			{
				"name": "Anton Whalley",
				"email": "anton.whalley@nearform.com",
				"url": "https://github.com/No9"
			},
			{
				"name": "Matteo Collina",
				"email": "matteo.collina@gmail.com",
				"url": "https://github.com/mcollina"
			},
			{
				"name": "Pedro Teixeira",
				"email": "pedro.teixeira@gmail.com",
				"url": "https://github.com/pgte"
			},
			{
				"name": "James Halliday",
				"email": "mail@substack.net",
				"url": "https://github.com/substack"
			},
			{
				"name": "Jarrett Cruger",
				"email": "jcrugzz@gmail.com",
				"url": "https://github.com/jcrugzz"
			}
		],
		"dependencies": {
			"deferred-leveldown": "~1.2.1",
			"level-codec": "~6.1.0",
			"level-errors": "~1.0.3",
			"level-iterator-stream": "~1.3.0",
			"prr": "~1.0.1",
			"semver": "~5.1.0",
			"xtend": "~4.0.0"
		},
		"description": "Fast & simple storage - a Node.js-style LevelDB wrapper",
		"devDependencies": {
			"async": "~1.5.0",
			"bustermove": "~1.0.0",
			"delayed": "~1.0.1",
			"faucet": "~0.0.1",
			"leveldown": "^1.1.0",
			"memdown": "~1.1.0",
			"msgpack-js": "~0.3.0",
			"referee": "~1.2.0",
			"rimraf": "~2.4.3",
			"slow-stream": "0.0.4",
			"tap": "~2.3.1",
			"tape": "~4.2.1"
		},
		"homepage": "https://github.com/level/levelup",
		"keywords": [
			"leveldb",
			"stream",
			"database",
			"db",
			"store",
			"storage",
			"json"
		],
		"license": "MIT",
		"main": "lib/levelup.js",
		"name": "levelup",
		"optionalDependencies": {},
		"readme": "LevelUP\n=======\n\n<img alt=\"LevelDB Logo\" height=\"100\" src=\"http://leveldb.org/img/logo.svg\">\n\n**Fast & simple storage - a Node.js-style LevelDB wrapper**\n\n[![Build Status](https://secure.travis-ci.org/Level/levelup.svg?branch=master)](http://travis-ci.org/Level/levelup)\n[![dependencies](https://david-dm.org/Level/levelup.svg)](https://david-dm.org/level/levelup)\n\n[![NPM](https://nodei.co/npm/levelup.png?stars&downloads&downloadRank)](https://nodei.co/npm/levelup/) [![NPM](https://nodei.co/npm-dl/levelup.png?months=6&height=3)](https://nodei.co/npm/levelup/)\n\n\n  * <a href=\"#intro\">Introduction</a>\n  * <a href=\"#leveldown\">Relationship to LevelDOWN</a>\n  * <a href=\"#platforms\">Tested &amp; supported platforms</a>\n  * <a href=\"#basic\">Basic usage</a>\n  * <a href=\"#api\">API</a>\n  * <a href=\"#events\">Events</a>\n  * <a href=\"#json\">JSON data</a>\n  * <a href=\"#custom_encodings\">Custom encodings</a>\n  * <a href=\"#extending\">Extending LevelUP</a>\n  * <a href=\"#multiproc\">Multi-process access</a>\n  * <a href=\"#support\">Getting support</a>\n  * <a href=\"#contributing\">Contributing</a>\n  * <a href=\"#license\">Licence &amp; copyright</a>\n\n<a name=\"intro\"></a>\nIntroduction\n------------\n\n**[LevelDB](https://github.com/google/leveldb)** is a simple key/value data store built by Google, inspired by BigTable. It's used in Google Chrome and many other products. LevelDB supports arbitrary byte arrays as both keys and values, singular *get*, *put* and *delete* operations, *batched put and delete*, bi-directional iterators and simple compression using the very fast [Snappy](http://google.github.io/snappy/) algorithm.\n\n**LevelUP** aims to expose the features of LevelDB in a **Node.js-friendly way**. All standard `Buffer` encoding types are supported, as is a special JSON encoding. LevelDB's iterators are exposed as a Node.js-style **readable stream**.\n\nLevelDB stores entries **sorted lexicographically by keys**. This makes LevelUP's <a href=\"#createReadStream\"><code>ReadStream</code></a> interface a very powerful query mechanism.\n\n**LevelUP** is an **OPEN Open Source Project**, see the <a href=\"#contributing\">Contributing</a> section to find out what this means.\n\n<a name=\"leveldown\"></a>\nRelationship to LevelDOWN\n-------------------------\n\nLevelUP is designed to be backed by **[LevelDOWN](https://github.com/level/leveldown/)** which provides a pure C++ binding to LevelDB and can be used as a stand-alone package if required.\n\n**As of version 0.9, LevelUP no longer requires LevelDOWN as a dependency so you must `npm install leveldown` when you install LevelUP.**\n\nLevelDOWN is now optional because LevelUP can be used with alternative backends, such as **[level.js](https://github.com/maxogden/level.js)** in the browser or [MemDOWN](https://github.com/level/memdown) for a pure in-memory store.\n\nLevelUP will look for LevelDOWN and throw an error if it can't find it in its Node `require()` path. It will also tell you if the installed version of LevelDOWN is incompatible.\n\n**The [level](https://github.com/level/level) package is available as an alternative installation mechanism.** Install it instead to automatically get both LevelUP & LevelDOWN. It exposes LevelUP on its export (i.e. you can `var leveldb = require('level')`).\n\n\n<a name=\"platforms\"></a>\nTested & supported platforms\n----------------------------\n\n  * **Linux**: including ARM platforms such as Raspberry Pi *and Kindle!*\n  * **Mac OS**\n  * **Solaris**: including Joyent's SmartOS & Nodejitsu\n  * **Windows**: Node 0.10 and above only. See installation instructions for *node-gyp's* dependencies [here](https://github.com/TooTallNate/node-gyp#installation), you'll need these (free) components from Microsoft to compile and run any native Node add-on in Windows.\n\n<a name=\"basic\"></a>\nBasic usage\n-----------\n\nFirst you need to install LevelUP!\n\n```sh\n$ npm install levelup leveldown\n```\n\nOr\n\n```sh\n$ npm install level\n```\n\n*(this second option requires you to use LevelUP by calling `var levelup = require('level')`)*\n\n\nAll operations are asynchronous although they don't necessarily require a callback if you don't need to know when the operation was performed.\n\n```js\nvar levelup = require('levelup')\n\n// 1) Create our database, supply location and options.\n//    This will create or open the underlying LevelDB store.\nvar db = levelup('./mydb')\n\n// 2) put a key & value\ndb.put('name', 'LevelUP', function (err) {\n  if (err) return console.log('Ooops!', err) // some kind of I/O error\n\n  // 3) fetch by key\n  db.get('name', function (err, value) {\n    if (err) return console.log('Ooops!', err) // likely the key was not found\n\n    // ta da!\n    console.log('name=' + value)\n  })\n})\n```\n\n<a name=\"api\"></a>\n## API\n\n  * <a href=\"#ctor\"><code><b>levelup()</b></code></a>\n  * <a href=\"#open\"><code>db.<b>open()</b></code></a>\n  * <a href=\"#close\"><code>db.<b>close()</b></code></a>\n  * <a href=\"#put\"><code>db.<b>put()</b></code></a>\n  * <a href=\"#get\"><code>db.<b>get()</b></code></a>\n  * <a href=\"#del\"><code>db.<b>del()</b></code></a>\n  * <a href=\"#batch\"><code>db.<b>batch()</b></code> *(array form)*</a>\n  * <a href=\"#batch_chained\"><code>db.<b>batch()</b></code> *(chained form)*</a>\n  * <a href=\"#isOpen\"><code>db.<b>isOpen()</b></code></a>\n  * <a href=\"#isClosed\"><code>db.<b>isClosed()</b></code></a>\n  * <a href=\"#createReadStream\"><code>db.<b>createReadStream()</b></code></a>\n  * <a href=\"#createKeyStream\"><code>db.<b>createKeyStream()</b></code></a>\n  * <a href=\"#createValueStream\"><code>db.<b>createValueStream()</b></code></a>\n\n### Special operations exposed by LevelDOWN\n\n  * <a href=\"#approximateSize\"><code>db.db.<b>approximateSize()</b></code></a>\n  * <a href=\"#getProperty\"><code>db.db.<b>getProperty()</b></code></a>\n  * <a href=\"#destroy\"><code><b>leveldown.destroy()</b></code></a>\n  * <a href=\"#repair\"><code><b>leveldown.repair()</b></code></a>\n\n### Special Notes\n  * <a href=\"#writeStreams\">What happened to <code><b>db.createWriteStream()</b></code></a>\n\n\n--------------------------------------------------------\n<a name=\"ctor\"></a>\n### levelup(location[, options[, callback]])\n### levelup(options[, callback ])\n### levelup(db[, callback ])\n<code>levelup()</code> is the main entry point for creating a new LevelUP instance and opening the underlying store with LevelDB.\n\nThis function returns a new instance of LevelUP and will also initiate an <a href=\"#open\"><code>open()</code></a> operation. Opening the database is an asynchronous operation which will trigger your callback if you provide one. The callback should take the form: `function (err, db) {}` where the `db` is the LevelUP instance. If you don't provide a callback, any read & write operations are simply queued internally until the database is fully opened.\n\nThis leads to two alternative ways of managing a new LevelUP instance:\n\n```js\nlevelup(location, options, function (err, db) {\n  if (err) throw err\n  db.get('foo', function (err, value) {\n    if (err) return console.log('foo does not exist')\n    console.log('got foo =', value)\n  })\n})\n\n// vs the equivalent:\n\nvar db = levelup(location, options) // will throw if an error occurs\ndb.get('foo', function (err, value) {\n  if (err) return console.log('foo does not exist')\n  console.log('got foo =', value)\n})\n```\n\nThe `location` argument is available as a read-only property on the returned LevelUP instance.\n\nThe `levelup(options, callback)` form (with optional `callback`) is only available where you provide a valid `'db'` property on the options object (see below). Only for back-ends that don't require a `location` argument, such as [MemDOWN](https://github.com/level/memdown).\n\nFor example:\n\n```js\nvar levelup = require('levelup')\nvar memdown = require('memdown')\nvar db = levelup({ db: memdown })\n```\n\nThe `levelup(db, callback)` form (with optional `callback`) is only available where `db` is a factory function, as would be provided as a `'db'` property on an `options` object (see below). Only for back-ends that don't require a `location` argument, such as [MemDOWN](https://github.com/level/memdown).\n\nFor example:\n\n```js\nvar levelup = require('levelup')\nvar memdown = require('memdown')\nvar db = levelup(memdown)\n```\n\n#### `options`\n\n`levelup()` takes an optional options object as its second argument; the following properties are accepted:\n\n* `'createIfMissing'` *(boolean, default: `true`)*: If `true`, will initialise an empty database at the specified location if one doesn't already exist. If `false` and a database doesn't exist you will receive an error in your `open()` callback and your database won't open.\n\n* `'errorIfExists'` *(boolean, default: `false`)*: If `true`, you will receive an error in your `open()` callback if the database exists at the specified location.\n\n* `'compression'` *(boolean, default: `true`)*: If `true`, all *compressible* data will be run through the Snappy compression algorithm before being stored. Snappy is very fast and shouldn't gain much speed by disabling so leave this on unless you have good reason to turn it off.\n\n* `'cacheSize'` *(number, default: `8 * 1024 * 1024`)*: The size (in bytes) of the in-memory [LRU](http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used) cache with frequently used uncompressed block contents.\n\n* `'keyEncoding'` and `'valueEncoding'` *(string, default: `'utf8'`)*: The encoding of the keys and values passed through Node.js' `Buffer` implementation (see [Buffer#toString()](http://nodejs.org/docs/latest/api/buffer.html#buffer_buf_tostring_encoding_start_end)).\n  <p><code>'utf8'</code> is the default encoding for both keys and values so you can simply pass in strings and expect strings from your <code>get()</code> operations. You can also pass <code>Buffer</code> objects as keys and/or values and conversion will be performed.</p>\n  <p>Supported encodings are: hex, utf8, ascii, binary, base64, ucs2, utf16le.</p>\n  <p><code>'json'</code> encoding is also supported, see below.</p>\n\n* `'db'` *(object, default: LevelDOWN)*: LevelUP is backed by [LevelDOWN](https://github.com/level/leveldown/) to provide an interface to LevelDB. You can completely replace the use of LevelDOWN by providing a \"factory\" function that will return a LevelDOWN API compatible object given a `location` argument. For further information, see [MemDOWN](https://github.com/level/memdown), a fully LevelDOWN API compatible replacement that uses a memory store rather than LevelDB. Also see [Abstract LevelDOWN](http://github.com/level/abstract-leveldown), a partial implementation of the LevelDOWN API that can be used as a base prototype for a LevelDOWN substitute.\n\nAdditionally, each of the main interface methods accept an optional options object that can be used to override `'keyEncoding'` and `'valueEncoding'`.\n\n--------------------------------------------------------\n<a name=\"open\"></a>\n### db.open([callback])\n<code>open()</code> opens the underlying LevelDB store. In general **you should never need to call this method directly** as it's automatically called by <a href=\"#ctor\"><code>levelup()</code></a>.\n\nHowever, it is possible to *reopen* a database after it has been closed with <a href=\"#close\"><code>close()</code></a>, although this is not generally advised.\n\n--------------------------------------------------------\n<a name=\"close\"></a>\n### db.close([callback])\n<code>close()</code> closes the underlying LevelDB store. The callback will receive any error encountered during closing as the first argument.\n\nYou should always clean up your LevelUP instance by calling `close()` when you no longer need it to free up resources. A LevelDB store cannot be opened by multiple instances of LevelDB/LevelUP simultaneously.\n\n--------------------------------------------------------\n<a name=\"put\"></a>\n### db.put(key, value[, options][, callback])\n<code>put()</code> is the primary method for inserting data into the store. Both the `key` and `value` can be arbitrary data objects.\n\nThe callback argument is optional but if you don't provide one and an error occurs then expect the error to be thrown.\n\n#### `options`\n\nEncoding of the `key` and `value` objects will adhere to `'keyEncoding'` and `'valueEncoding'` options provided to <a href=\"#ctor\"><code>levelup()</code></a>, although you can provide alternative encoding settings in the options for `put()` (it's recommended that you stay consistent in your encoding of keys and values in a single store).\n\nIf you provide a `'sync'` value of `true` in your `options` object, LevelDB will perform a synchronous write of the data; although the operation will be asynchronous as far as Node is concerned. Normally, LevelDB passes the data to the operating system for writing and returns immediately, however a synchronous write will use `fsync()` or equivalent so your callback won't be triggered until the data is actually on disk. Synchronous filesystem writes are **significantly** slower than asynchronous writes but if you want to be absolutely sure that the data is flushed then you can use `'sync': true`.\n\n--------------------------------------------------------\n<a name=\"get\"></a>\n### db.get(key[, options][, callback])\n<code>get()</code> is the primary method for fetching data from the store. The `key` can be an arbitrary data object. If it doesn't exist in the store then the callback will receive an error as its first argument. A not-found err object will be of type `'NotFoundError'` so you can `err.type == 'NotFoundError'` or you can perform a truthy test on the property `err.notFound`.\n\n```js\ndb.get('foo', function (err, value) {\n  if (err) {\n    if (err.notFound) {\n      // handle a 'NotFoundError' here\n      return\n    }\n    // I/O or other error, pass it up the callback chain\n    return callback(err)\n  }\n\n  // .. handle `value` here\n})\n```\n\n#### `options`\n\nEncoding of the `key` and `value` objects is the same as in <a href=\"#put\"><code>put</code></a>. \n\nLevelDB will by default fill the in-memory LRU Cache with data from a call to get. Disabling this is done by setting `fillCache` to `false`.\n\n--------------------------------------------------------\n<a name=\"del\"></a>\n### db.del(key[, options][, callback])\n<code>del()</code> is the primary method for removing data from the store.\n```js\ndb.del('foo', function (err) {\n  if (err)\n    // handle I/O or other error\n});\n```\n\n#### `options`\n\nEncoding of the `key` object will adhere to the `'keyEncoding'` option provided to <a href=\"#ctor\"><code>levelup()</code></a>, although you can provide alternative encoding settings in the options for `del()` (it's recommended that you stay consistent in your encoding of keys and values in a single store).\n\nA `'sync'` option can also be passed, see <a href=\"#put\"><code>put()</code></a> for details on how this works.\n\n--------------------------------------------------------\n<a name=\"batch\"></a>\n### db.batch(array[, options][, callback]) *(array form)*\n<code>batch()</code> can be used for very fast bulk-write operations (both *put* and *delete*). The `array` argument should contain a list of operations to be executed sequentially, although as a whole they are performed as an atomic operation inside LevelDB.\n\nEach operation is contained in an object having the following properties: `type`, `key`, `value`, where the *type* is either `'put'` or `'del'`. In the case of `'del'` the `'value'` property is ignored. Any entries with a `'key'` of `null` or `undefined` will cause an error to be returned on the `callback` and any `'type': 'put'` entry with a `'value'` of `null` or `undefined` will return an error.\n\nIf `key` and `value` are defined but `type` is not, it will default to `'put'`.\n\n```js\nvar ops = [\n    { type: 'del', key: 'father' }\n  , { type: 'put', key: 'name', value: 'Yuri Irsenovich Kim' }\n  , { type: 'put', key: 'dob', value: '16 February 1941' }\n  , { type: 'put', key: 'spouse', value: 'Kim Young-sook' }\n  , { type: 'put', key: 'occupation', value: 'Clown' }\n]\n\ndb.batch(ops, function (err) {\n  if (err) return console.log('Ooops!', err)\n  console.log('Great success dear leader!')\n})\n```\n\n#### `options`\n\nSee <a href=\"#put\"><code>put()</code></a> for a discussion on the `options` object. You can overwrite default `'keyEncoding'` and `'valueEncoding'` and also specify the use of `sync` filesystem operations.\n\nIn addition to encoding options for the whole batch you can also overwrite the encoding per operation, like:\n\n```js\nvar ops = [{\n    type          : 'put'\n  , key           : new Buffer([1, 2, 3])\n  , value         : { some: 'json' }\n  , keyEncoding   : 'binary'\n  , valueEncoding : 'json'\n}]\n```\n\n--------------------------------------------------------\n<a name=\"batch_chained\"></a>\n### db.batch() *(chained form)*\n<code>batch()</code>, when called with no arguments will return a `Batch` object which can be used to build, and eventually commit, an atomic LevelDB batch operation. Depending on how it's used, it is possible to obtain greater performance when using the chained form of `batch()` over the array form.\n\n```js\ndb.batch()\n  .del('father')\n  .put('name', 'Yuri Irsenovich Kim')\n  .put('dob', '16 February 1941')\n  .put('spouse', 'Kim Young-sook')\n  .put('occupation', 'Clown')\n  .write(function () { console.log('Done!') })\n```\n\n<b><code>batch.put(key, value[, options])</code></b>\n\nQueue a *put* operation on the current batch, not committed until a `write()` is called on the batch.\n\nThe optional `options` argument can be used to override the default `'keyEncoding'` and/or `'valueEncoding'`.\n\nThis method may `throw` a `WriteError` if there is a problem with your put (such as the `value` being `null` or `undefined`).\n\n<b><code>batch.del(key[, options])</code></b>\n\nQueue a *del* operation on the current batch, not committed until a `write()` is called on the batch.\n\nThe optional `options` argument can be used to override the default `'keyEncoding'`.\n\nThis method may `throw` a `WriteError` if there is a problem with your delete.\n\n<b><code>batch.clear()</code></b>\n\nClear all queued operations on the current batch, any previous operations will be discarded.\n\n<b><code>batch.length</code></b>\n\nThe number of queued operations on the current batch.\n\n<b><code>batch.write([callback])</code></b>\n\nCommit the queued operations for this batch. All operations not *cleared* will be written to the database atomically, that is, they will either all succeed or fail with no partial commits. The optional `callback` will be called when the operation has completed with an *error* argument if an error has occurred; if no `callback` is supplied and an error occurs then this method will `throw` a `WriteError`.\n\n\n--------------------------------------------------------\n<a name=\"isOpen\"></a>\n### db.isOpen()\n\nA LevelUP object can be in one of the following states:\n\n  * *\"new\"*     - newly created, not opened or closed\n  * *\"opening\"* - waiting for the database to be opened\n  * *\"open\"*    - successfully opened the database, available for use\n  * *\"closing\"* - waiting for the database to be closed\n  * *\"closed\"*  - database has been successfully closed, should not be used\n\n`isOpen()` will return `true` only when the state is \"open\".\n\n--------------------------------------------------------\n<a name=\"isClosed\"></a>\n### db.isClosed()\n\n*See <a href=\"#put\"><code>isOpen()</code></a>*\n\n`isClosed()` will return `true` only when the state is \"closing\" *or* \"closed\", it can be useful for determining if read and write operations are permissible.\n\n--------------------------------------------------------\n<a name=\"createReadStream\"></a>\n### db.createReadStream([options])\n\nYou can obtain a **ReadStream** of the full database by calling the `createReadStream()` method. The resulting stream is a complete Node.js-style [Readable Stream](http://nodejs.org/docs/latest/api/stream.html#stream_readable_stream) where `'data'` events emit objects with `'key'` and `'value'` pairs. You can also use the `gt`, `lt` and `limit` options to control the range of keys that are streamed.\n\n```js\ndb.createReadStream()\n  .on('data', function (data) {\n    console.log(data.key, '=', data.value)\n  })\n  .on('error', function (err) {\n    console.log('Oh my!', err)\n  })\n  .on('close', function () {\n    console.log('Stream closed')\n  })\n  .on('end', function () {\n    console.log('Stream ended')\n  })\n```\n\nThe standard `pause()`, `resume()` and `destroy()` methods are implemented on the ReadStream, as is `pipe()` (see below). `'data'`, '`error'`, `'end'` and `'close'` events are emitted.\n\nAdditionally, you can supply an options object as the first parameter to `createReadStream()` with the following options:\n\n* `'gt'` (greater than), `'gte'` (greater than or equal) define the lower bound of the range to be streamed. Only records where the key is greater than (or equal to) this option will be included in the range. When `reverse=true` the order will be reversed, but the records streamed will be the same.\n\n* `'lt'` (less than), `'lte'` (less than or equal) define the higher bound of the range to be streamed. Only key/value pairs where the key is less than (or equal to) this option will be included in the range. When `reverse=true` the order will be reversed, but the records streamed will be the same.\n\n* `'start', 'end'` legacy ranges - instead use `'gte', 'lte'`\n\n* `'reverse'` *(boolean, default: `false`)*: a boolean, set true and the stream output will be reversed. Beware that due to the way LevelDB works, a reverse seek will be slower than a forward seek.\n\n* `'keys'` *(boolean, default: `true`)*: whether the `'data'` event should contain keys. If set to `true` and `'values'` set to `false` then `'data'` events will simply be keys, rather than objects with a `'key'` property. Used internally by the `createKeyStream()` method.\n\n* `'values'` *(boolean, default: `true`)*: whether the `'data'` event should contain values. If set to `true` and `'keys'` set to `false` then `'data'` events will simply be values, rather than objects with a `'value'` property. Used internally by the `createValueStream()` method.\n\n* `'limit'` *(number, default: `-1`)*: limit the number of results collected by this stream. This number represents a *maximum* number of results and may not be reached if you get to the end of the data first. A value of `-1` means there is no limit. When `reverse=true` the highest keys will be returned instead of the lowest keys.\n\n* `'fillCache'` *(boolean, default: `false`)*: whether LevelDB's LRU-cache should be filled with data read.\n\n* `'keyEncoding'` / `'valueEncoding'` *(string)*: the encoding applied to each read piece of data.\n\n--------------------------------------------------------\n<a name=\"createKeyStream\"></a>\n### db.createKeyStream([options])\n\nA **KeyStream** is a **ReadStream** where the `'data'` events are simply the keys from the database so it can be used like a traditional stream rather than an object stream.\n\nYou can obtain a KeyStream either by calling the `createKeyStream()` method on a LevelUP object or by passing an options object to `createReadStream()` with `keys` set to `true` and `values` set to `false`.\n\n```js\ndb.createKeyStream()\n  .on('data', function (data) {\n    console.log('key=', data)\n  })\n\n// same as:\ndb.createReadStream({ keys: true, values: false })\n  .on('data', function (data) {\n    console.log('key=', data)\n  })\n```\n\n--------------------------------------------------------\n<a name=\"createValueStream\"></a>\n### db.createValueStream([options])\n\nA **ValueStream** is a **ReadStream** where the `'data'` events are simply the values from the database so it can be used like a traditional stream rather than an object stream.\n\nYou can obtain a ValueStream either by calling the `createValueStream()` method on a LevelUP object or by passing an options object to `createReadStream()` with `values` set to `true` and `keys` set to `false`.\n\n```js\ndb.createValueStream()\n  .on('data', function (data) {\n    console.log('value=', data)\n  })\n\n// same as:\ndb.createReadStream({ keys: false, values: true })\n  .on('data', function (data) {\n    console.log('value=', data)\n  })\n```\n\n--------------------------------------------------------\n<a name=\"writeStreams\"></a>\n#### What happened to `db.createWriteStream`?\n\n`db.createWriteStream()` has been removed in order to provide a smaller and more maintainable core. It primarily existed to create symmetry with `db.createReadStream()` but through much [discussion](https://github.com/level/levelup/issues/199), removing it was the best course of action.\n\nThe main driver for this was performance. While `db.createReadStream()` performs well under most use cases, `db.createWriteStream()` was highly dependent on the application keys and values. Thus we can't provide a standard implementation and encourage more `write-stream` implementations to be created to solve the broad spectrum of use cases.\n\nCheck out the implementations that the community has already produced [here](https://github.com/level/levelup/wiki/Modules#write-streams).\n\n--------------------------------------------------------\n<a name='approximateSize'></a>\n### db.db.approximateSize(start, end, callback)\n<code>approximateSize()</code> can used to get the approximate number of bytes of file system space used by the range `[start..end)`. The result may not include recently written data.\n\n```js\nvar db = require('level')('./huge.db')\n\ndb.db.approximateSize('a', 'c', function (err, size) {\n  if (err) return console.error('Ooops!', err)\n  console.log('Approximate size of range is %d', size)\n})\n```\n\n**Note:** `approximateSize()` is available via [LevelDOWN](https://github.com/level/leveldown/), which by default is accessible as the `db` property of your LevelUP instance. This is a specific LevelDB operation and is not likely to be available where you replace LevelDOWN with an alternative back-end via the `'db'` option.\n\n\n--------------------------------------------------------\n<a name='getProperty'></a>\n### db.db.getProperty(property)\n<code>getProperty</code> can be used to get internal details from LevelDB. When issued with a valid property string, a readable string will be returned (this method is synchronous).\n\nCurrently, the only valid properties are:\n\n* <b><code>'leveldb.num-files-at-levelN'</code></b>: returns the number of files at level *N*, where N is an integer representing a valid level (e.g. \"0\").\n\n* <b><code>'leveldb.stats'</code></b>: returns a multi-line string describing statistics about LevelDB's internal operation.\n\n* <b><code>'leveldb.sstables'</code></b>: returns a multi-line string describing all of the *sstables* that make up contents of the current database.\n\n\n```js\nvar db = require('level')('./huge.db')\nconsole.log(db.db.getProperty('leveldb.num-files-at-level3'))\n// → '243'\n```\n\n**Note:** `getProperty()` is available via [LevelDOWN](https://github.com/level/leveldown/), which by default is accessible as the `db` property of your LevelUP instance. This is a specific LevelDB operation and is not likely to be available where you replace LevelDOWN with an alternative back-end via the `'db'` option.\n\n\n--------------------------------------------------------\n<a name=\"destroy\"></a>\n### leveldown.destroy(location, callback)\n<code>destroy()</code> is used to completely remove an existing LevelDB database directory. You can use this function in place of a full directory *rm* if you want to be sure to only remove LevelDB-related files. If the directory only contains LevelDB files, the directory itself will be removed as well. If there are additional, non-LevelDB files in the directory, those files, and the directory, will be left alone.\n\nThe callback will be called when the destroy operation is complete, with a possible `error` argument.\n\n**Note:** `destroy()` is available via [LevelDOWN](https://github.com/level/leveldown/) which you will have to install seperately, e.g.:\n\n```js\nrequire('leveldown').destroy('./huge.db', function (err) { console.log('done!') })\n```\n\n--------------------------------------------------------\n<a name=\"repair\"></a>\n### leveldown.repair(location, callback)\n<code>repair()</code> can be used to attempt a restoration of a damaged LevelDB store. From the LevelDB documentation:\n\n> If a DB cannot be opened, you may attempt to call this method to resurrect as much of the contents of the database as possible. Some data may be lost, so be careful when calling this function on a database that contains important information.\n\nYou will find information on the *repair* operation in the *LOG* file inside the store directory.\n\nA `repair()` can also be used to perform a compaction of the LevelDB log into table files.\n\nThe callback will be called when the repair operation is complete, with a possible `error` argument.\n\n**Note:** `repair()` is available via [LevelDOWN](https://github.com/level/leveldown/) which you will have to install seperately, e.g.:\n\n```js\nrequire('leveldown').repair('./huge.db', function (err) { console.log('done!') })\n```\n\n--------------------------------------------------------\n\n<a name=\"events\"></a>\nEvents\n------\n\nLevelUP emits events when the callbacks to the corresponding methods are called.\n\n* `db.emit('put', key, value)` emitted when a new value is `'put'`\n* `db.emit('del', key)` emitted when a value is deleted\n* `db.emit('batch', ary)` emitted when a batch operation has executed\n* `db.emit('ready')` emitted when the database has opened (`'open'` is synonym)\n* `db.emit('closed')` emitted when the database has closed\n* `db.emit('opening')` emitted when the database is opening\n* `db.emit('closing')` emitted when the database is closing\n\nIf you do not pass a callback to an async function, and there is an error, LevelUP will `emit('error', err)` instead.\n\n<a name=\"json\"></a>\nJSON data\n---------\n\nYou specify `'json'` encoding for both keys and/or values, you can then supply JavaScript objects to LevelUP and receive them from all fetch operations, including ReadStreams. LevelUP will automatically *stringify* your objects and store them as *utf8* and parse the strings back into objects before passing them back to you.\n\n<a name=\"custom_encodings\"></a>\nCustom encodings\n----------------\n\nA custom encoding may be provided by passing in an object as a value for `keyEncoding` or `valueEncoding` (wherever accepted), it must have the following properties:\n\n```js\n{\n    encode : function (val) { ... }\n  , decode : function (val) { ... }\n  , buffer : boolean // encode returns a buffer and decode accepts a buffer\n  , type   : String  // name of this encoding type.\n}\n```\n\n<a name=\"extending\"></a>\nExtending LevelUP\n-----------------\n\nA list of <a href=\"https://github.com/level/levelup/wiki/Modules\"><b>Node.js LevelDB modules and projects</b></a> can be found in the wiki.\n\nWhen attempting to extend the functionality of LevelUP, it is recommended that you consider using [level-hooks](https://github.com/dominictarr/level-hooks) and/or [level-sublevel](https://github.com/dominictarr/level-sublevel). **level-sublevel** is particularly helpful for keeping additional, extension-specific, data in a LevelDB store. It allows you to partition a LevelUP instance into multiple sub-instances that each correspond to discrete namespaced key ranges.\n\n<a name=\"multiproc\"></a>\nMulti-process access\n--------------------\n\nLevelDB is thread-safe but is **not** suitable for accessing with multiple processes. You should only ever have a LevelDB database open from a single Node.js process. Node.js clusters are made up of multiple processes so a LevelUP instance cannot be shared between them either.\n\nSee the <a href=\"https://github.com/level/levelup/wiki/Modules\"><b>wiki</b></a> for some LevelUP extensions, including [multilevel](https://github.com/juliangruber/multilevel), that may help if you require a single data store to be shared across processes.\n\n<a name=\"support\"></a>\nGetting support\n---------------\n\nThere are multiple ways you can find help in using LevelDB in Node.js:\n\n * **IRC:** you'll find an active group of LevelUP users in the **##leveldb** channel on Freenode, including most of the contributors to this project.\n * **Mailing list:** there is an active [Node.js LevelDB](https://groups.google.com/forum/#!forum/node-levelup) Google Group.\n * **GitHub:** you're welcome to open an issue here on this GitHub repository if you have a question.\n\n<a name=\"contributing\"></a>\nContributing\n------------\n\nLevelUP is an **OPEN Open Source Project**. This means that:\n\n> Individuals making significant and valuable contributions are given commit-access to the project to contribute as they see fit. This project is more like an open wiki than a standard guarded open source project.\n\nSee the [contribution guide](https://github.com/Level/community/blob/master/CONTRIBUTING.md) for more details.\n\n### Windows\n\nA large portion of the Windows support comes from code by [Krzysztof Kowalczyk](http://blog.kowalczyk.info/) [@kjk](https://twitter.com/kjk), see his Windows LevelDB port [here](http://code.google.com/r/kkowalczyk-leveldb/). If you're using LevelUP on Windows, you should give him your thanks!\n\n\n<a name=\"license\"></a>\nLicense &amp; copyright\n-------------------\n\nCopyright &copy; 2012-2016 **LevelUP** [contributors](https://github.com/level/community#contributors).\n\n**LevelUP** is licensed under the MIT license. All rights not explicitly granted in the MIT license are reserved. See the included `LICENSE.md` file for more details.\n\n=======\n*LevelUP builds on the excellent work of the LevelDB and Snappy teams from Google and additional contributors. LevelDB and Snappy are both issued under the [New BSD Licence](http://opensource.org/licenses/BSD-3-Clause).*\n",
		"readmeFilename": "README.md",
		"repository": {
			"type": "git",
			"url": "git+https://github.com/level/levelup.git"
		},
		"scripts": {
			"test": "tape test/*-test.js | faucet"
		},
		"version": "1.3.3"
	};

/***/ },

/***/ 2048:
/***/ function(module, exports, __webpack_require__) {

	/* Copyright (c) 2012-2016 LevelUP contributors
	 * See list at <https://github.com/level/levelup#contributing>
	 * MIT License
	 * <https://github.com/level/levelup/blob/master/LICENSE.md>
	 */
	
	var util          = __webpack_require__(2043)
	  , WriteError    = __webpack_require__(1259).WriteError
	
	  , getOptions    = util.getOptions
	  , dispatchError = util.dispatchError
	
	function Batch (levelup, codec) {
	  this._levelup = levelup
	  this._codec = codec
	  this.batch = levelup.db.batch()
	  this.ops = []
	  this.length = 0
	}
	
	Batch.prototype.put = function (key_, value_, options) {
	  options = getOptions(options)
	
	  var key   = this._codec.encodeKey(key_, options)
	    , value = this._codec.encodeValue(value_, options)
	
	  try {
	    this.batch.put(key, value)
	  } catch (e) {
	    throw new WriteError(e)
	  }
	  this.ops.push({ type : 'put', key : key, value : value })
	  this.length++
	
	  return this
	}
	
	Batch.prototype.del = function (key_, options) {
	  options = getOptions(options)
	
	  var key = this._codec.encodeKey(key_, options)
	
	  try {
	    this.batch.del(key)
	  } catch (err) {
	    throw new WriteError(err)
	  }
	  this.ops.push({ type : 'del', key : key })
	  this.length++
	
	  return this
	}
	
	Batch.prototype.clear = function () {
	  try {
	    this.batch.clear()
	  } catch (err) {
	    throw new WriteError(err)
	  }
	
	  this.ops = []
	  this.length = 0
	  return this
	}
	
	Batch.prototype.write = function (callback) {
	  var levelup = this._levelup
	    , ops     = this.ops
	
	  try {
	    this.batch.write(function (err) {
	      if (err)
	        return dispatchError(levelup, new WriteError(err), callback)
	      levelup.emit('batch', ops)
	      if (callback)
	        callback()
	    })
	  } catch (err) {
	    throw new WriteError(err)
	  }
	}
	
	module.exports = Batch


/***/ },

/***/ 2052:
/***/ function(module, exports, __webpack_require__) {

	
	var TypedError = __webpack_require__(1328)
	
	exports.InvalidSignature = TypedError({
	  type: 'invalidsignature',
	  message: 'invalid signature {sig}',
	  sig: null
	})
	
	exports.InvalidKey = TypedError({
	  type: 'invalidkey',
	  message: 'invalid key {key}',
	  key: null
	})


/***/ },

/***/ 2053:
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {
	const Cache = __webpack_require__(1142)
	
	// Would be nice to do this without monkey-patching
	// but attempts with level-updown caused fun encoding nightmares
	
	module.exports = function cachify (keeper, opts) {
	  const cache = new Cache(opts || {})
	  const getFn = keeper.get
	  const putFn = keeper.put
	  const delFn = keeper.del
	  const batchFn = keeper.batch
	
	  keeper.get = function (key, cb) {
	    const cached = cache.get(key)
	    if (cached) return process.nextTick(() => cb(null, cached))
	
	    getFn.call(keeper, key, function (err, val) {
	      if (err) return cb(err)
	
	      cache.set(key, val)
	      cb(null, val)
	    })
	  }
	
	  keeper.put = function (key, val, cb) {
	    if (cache.get(key) === val) return process.nextTick(() => cb())
	
	    cache.set(key, val)
	    // safe to pre-cache?
	    putFn.call(keeper, key, val, function (err) {
	      if (err) {
	        cache.del(key)
	        return cb(err)
	      }
	
	      cb()
	    })
	  }
	
	  keeper.del = function (key, cb) {
	    cache.del(key)
	    return delFn.call(keeper, key, cb)
	  }
	
	  keeper.batch = function (batch, cb) {
	    if (!batch) throw new Error('chained batch not supported')
	
	    batch = batch.filter(row => {
	      return !(row.type === 'put' && cache.get(row.key) === row.value)
	    })
	
	    if (!batch.length) return process.nextTick(() => cb())
	
	    batch.forEach(row => {
	      if (row.type === 'put') {
	        cache.set(row.key, row.value)
	      } else {
	        cache.del(row.key)
	      }
	    })
	
	    return batchFn.call(keeper, batch, function (err) {
	      if (err) {
	        batch.forEach(row => {
	          if (row.type === 'put') cache.del(row.key)
	
	          // TODO: restored deleted
	        })
	
	        return cb(err)
	      }
	
	      cb()
	    })
	  }
	
	  return keeper
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(294)))

/***/ }

});
//# sourceMappingURL=tradle.dbc72062f08eaa0ef7f3.js.map